### ðŸ’ª Let's go BIG

---

Do you need to open huge big IFC files fast, even on more modest devices?
If so, you are in luck! We can open virtually any model on any device in
seconds thanks to BIM TILES!
:::info BIM tiles?
The idea behind BIM tiles is pretty simple! Instead of loading the whole BIM
model at once, we just load the explicit geometries that are seen by the user.
It's way faster than opening the IFC directly, but for this you'll need
a backend (or to rely on the file system of the user if you are building a
desktop or mobile app).
:::
Let's see how to do this step by step!

### ðŸ§© Converting the IFC model to tiles

---

The first step is to transform the IFC model into BIM tiles. The reason why we
have to do this is pretty simple: geometry in IFC is implicit (e.g. a wall is
defined as an extrusion). This means that it needs to be computed and converted
to explicit geometry (triangles) so that it can be displayed in 3D. Let's start
converting the IFC geometry:

```js
const streamer = new OBC.FragmentIfcStreamConverter(components);
streamer.settings.wasm = {
  path: "https://unpkg.com/web-ifc@0.0.51/",
  absolute: true,
};
```

The `FragmentIfcStreamConverter` class takes IFC files and transform them into
tiles. You can use events to get the data. The `onGeometryStreamed` event will
give you the geometries bundled in a binary file, as well as an object with
information about the geometries contained within this file.

```js
streamer.onGeometryStreamed.add((geometry) => {
  console.log(geometry);
});
```

You can control the amount of geometries inside a file using the settings. The
way the streaming works can't guarantee a precise number of geometries within a file,
but in most cases it will be quite close to the given number.

```js
streamer.settings.minGeometrySize = 20;
```

Similarly, you can get the assets data and control the number of assets per chunk like this:

```js
streamer.onAssetStreamed.add((assets) => {
  console.log(assets);
});
streamer.settings.minAssetsSize = 1000;
```

Just like when using the normal `FragmentIfcLoader`, when you stream an IFC file you are
creating a `FragmentsGroup`. Using this event, you can get it:

```js
streamer.onIfcLoaded.add(async (groupBuffer) => {
  console.log(groupBuffer);
});
```

Finally, you can use this to get notified as the streaming process progresses:

```js
streamer.onProgress.add((progress) => {
  console.log(progress);
});
```

With everything in place, it's time to stream the IFC file and get all the tiles!

```js
const fetchedIfc = await fetch("../../../resources/small.ifc");
const ifcBuffer = await fetchedIfc.arrayBuffer();
streamer.streamFromBuffer(new Uint8Array(ifcBuffer));
```

### ðŸ“‹ Streaming the properties

---

You can also stream the properties of an IFC file. Why? Because some files can have
millions of properties, and trying to save them naively in a normal DB is not very
scalable/affordable. Using this system, you'll be able to store and retrieve the
data of models of any size without big cloud costs. We can do this conversion
using the `FragmentPropsStreamConverter`:

```js
const propsStreamer = new OBC.FragmentPropsStreamConverter(components);
propsStreamer.settings.wasm = {
  path: "https://unpkg.com/web-ifc@0.0.51/",
  absolute: true,
};
```

Similarly to geometries, here you will also get data and progress notification
using events. In addition to properties, you will get `indices`, which is an
indexation data of the properties to be able to use them effectively when
streamed.

```js
propsStreamer.onPropertiesStreamed.add(async (props) => {
  console.log(props);
});
propsStreamer.onProgress.add(async (progress) => {
  console.log(progress);
});
propsStreamer.onIndicesStreamed.add(async (props) => {
  console.log(props);
});
```

Just call the `streamFromBuffer` method and you are ready to go!

```js
propsStreamer.streamFromBuffer(new Uint8Array(ifcBuffer));
```

### ðŸ§± Assembling the data

---

Now you are ready to start streaming your data. The first step is to create 2 JSON
files so that the library can access your backend: one for the geometries and other for
the properties. You have examples of both JSONs [here](https://github.com/ThatOpen/engine_components/blob/main/resources/small.ifc-processed.json)
and [here](https://github.com/ThatOpen/engine_components/blob/main/resources/small.ifc-processed-properties.json).
The JSON file for the geometries should look like this, and you should
be able to create them with the data given in the previous steps. The `globalDataIDFile`
is expected to have a name that ends with `-global`.

```ts
interface StreamedGeometries {
  assets: {
    id: number;
    geometries: {
      color: number[];
      geometryID: number;
      transformation: number[];
    }[];
  }[];
  geometries: {
    [id: number]: {
      boundingBox: { [id: number]: number };
      hasHoles: boolean;
      geometryFile: "url-to-geometry-file-in-your-backend";
    };
  };
  globalDataFileId: "url-to-fragments-group-file-in-your-backend";
}
```

The JSON for geometries should look like this. The values in `types` and in `ids`
are the suffix of the name of the properties file in your backend. In other words,
the library expects that if your globalDataFile is called `small.ifc-global`, the
properties files will be called `small.ifc-properties-1`, `small.ifc-properties-2`,
etc. In other words: `types: {1837: [1, 2], ...}, ids: {8: 1, ...}` means that
all the items of type `1837` are in the files `small.ifc-properties-1` and
`small.ifc-properties-2`, and that the properties of the item with id 8 is in the
file `small.ifc-properties-1`.

```ts
interface StreamedProperties {
  types: {
    [typeID: number]: number[];
  };
  ids: {
    [id: number]: {
      boundingBox: { [id: number]: number };
      hasHoles: boolean;
      geometryFile: "url-to-geometry-file-in-your-backend";
    };
  };
  indexesFile: "url-to-indexes-file-in-your-backend";
}
```

Once you get both files, you are ready to start streaming!

### ðŸ§± Streaming the data

---

Now, streaming the data is quite easy once you have the JSON files.
You can just instantiate the loader, give it the base URL to your
backend and just load the models like this:

```js
let loader = new OBC.FragmentStreamLoader(components);
loader.url = "http://YOUR_BACKEND_URL";
let fragments = new OBC.FragmentManager(components);
async function loadModel(geometryURL, propertiesURL) {
  const rawGeometryData = await fetch(geometryURL);
  const geometryData = await rawGeometryData.json();
  let propertiesData;
  if (propertiesURL) {
    const rawPropertiesData = await fetch(propertiesURL);
    propertiesData = await rawPropertiesData.json();
  }
  await loader.load(geometryData, true, propertiesData);
}
await loadModel(
  "../../../resources/small.ifc-processed.json",
  "../../../resources/small.ifc-processed-properties.json",
);
```

Now, streaming works by updating the scene depending on the user's perspective
and getting the necessary geometries from the backend. A simple way to achieve
this is by updating the scene each time the user stops the camera:

```js
components.camera.controls.addEventListener("controlend", () => {
  loader.culler.needsUpdate = true;
});
```

As you can imagine, downloading the geometries from the server each time can
take time, especially for heavier geometries. This is why the stream loader
automatically caches the files locally to get them much faster. This means that
the loading experience the first time might be a bit slower, but then later
it will be much better. You can control this using the `useCache` property
and clear the cache using the `clearCache()` method:

```js
loader.useCache = true;
await loader.clearCache();
```

You can also customize the loader through the `culler` property:

- Threshold determines how bit an object must be in the screen to stream it.
- maxHiddenTime determines how long an object must be lost to remove it from the scene.
- maxLostTime determines how long an object must be lost to remove it from memory.

```js
loader.culler.threshold = 20;
loader.culler.maxHiddenTime = 1000;
loader.culler.maxLostTime = 40000;
```

This is it! Now you should be able to stream your own IFC models and open them anywhere,
no matter how big they are! ðŸ’ª We will keep improving and making this API more powerful
to handle any model on any device smoothly.
