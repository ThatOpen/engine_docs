"use strict";(self.webpackChunkengine_docs=self.webpackChunkengine_docs||[]).push([[5005],{2329:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var s=t(4848),r=t(8453);const o={},a=void 0,i={id:"Tutorials/Fragments/Fragments/FragmentsModels/SteelDetailing",title:"SteelDetailing",description:'window.open("https://thatopen.github.io/engine_fragment/examples/FragmentsModels/SteelDetailing")} >Go Full Screen',source:"@site/docs/Tutorials/Fragments/Fragments/FragmentsModels/SteelDetailing.mdx",sourceDirName:"Tutorials/Fragments/Fragments/FragmentsModels",slug:"/Tutorials/Fragments/Fragments/FragmentsModels/SteelDetailing",permalink:"/Tutorials/Fragments/Fragments/FragmentsModels/SteelDetailing",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Rebars",permalink:"/Tutorials/Fragments/Fragments/FragmentsModels/Rebars"},next:{title:"VisibilityOperations",permalink:"/Tutorials/Fragments/Fragments/FragmentsModels/VisibilityOperations"}},l={},c=[{value:"Steel Detailing \ud83d\udd27",id:"steel-detailing-",level:2},{value:"\ud83d\udd96 Importing our Libraries",id:"-importing-our-libraries",level:3},{value:"\ud83c\udf0e Setting up a Simple Scene",id:"-setting-up-a-simple-scene",level:3},{value:"\u2699\ufe0f Configuration Settings",id:"\ufe0f-configuration-settings",level:3},{value:"\ud83d\udee0\ufe0f Setting Up Fragments",id:"\ufe0f-setting-up-fragments",level:3},{value:"\ud83d\uddbc\ufe0f Material and Texture Setup",id:"\ufe0f-material-and-texture-setup",level:3},{value:"\ud83d\udcc2 Creating a New Fragments Model",id:"-creating-a-new-fragments-model",level:3},{value:"\ud83e\uddca Setting up the Geometry Engine",id:"-setting-up-the-geometry-engine",level:3},{value:"\ud83d\udd27 Creating Basic Steel Geometries",id:"-creating-basic-steel-geometries",level:3},{value:"\ud83d\udd04 Fragment Regeneration Logic",id:"-fragment-regeneration-logic",level:3},{value:"\ud83c\udfd7\ufe0f Model Regeneration",id:"\ufe0f-model-regeneration",level:3},{value:"\ud83e\udde9 Adding User Interface",id:"-adding-user-interface",level:3},{value:"\ud83d\udcf1 Mobile-Friendly Menu",id:"-mobile-friendly-menu",level:3},{value:"\u23f1\ufe0f Measuring the Performance (optional)",id:"\ufe0f-measuring-the-performance-optional",level:3},{value:"\ud83c\udf89 Congratulations!",id:"-congratulations",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",hr:"hr",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)("div",{style:{position:"relative"},children:[(0,s.jsx)("iframe",{src:"https://thatopen.github.io/engine_fragment/examples/FragmentsModels/SteelDetailing"}),(0,s.jsx)("button",{class:"full-screen-btn",onClick:()=>window.open("https://thatopen.github.io/engine_fragment/examples/FragmentsModels/SteelDetailing"),children:"Go Full Screen"})]}),"\n",(0,s.jsx)(n.admonition,{title:"Source",type:"info",children:(0,s.jsxs)(n.p,{children:["Copying and pasting? We've got you covered! You can find the full source code of this tutorial ",(0,s.jsx)(n.a,{href:"https://github.com/ThatOpen/engine_fragment/blob/main/packages/fragments/src/FragmentsModels/examples/SteelDetailing/example.ts",children:"here"}),"."]})}),"\n",(0,s.jsx)(n.h2,{id:"steel-detailing-",children:"Steel Detailing \ud83d\udd27"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"In this tutorial, we'll explore how to create detailed steel structures using the Fragments API. We'll learn how to generate steel frames, base plates, connections, and other structural steel elements with proper geometric relationships and detailing. Let's dive in!"}),"\n",(0,s.jsx)(n.h3,{id:"-importing-our-libraries",children:"\ud83d\udd96 Importing our Libraries"}),"\n",(0,s.jsx)(n.p,{children:"First things first, let's install all necessary dependencies to make this example work:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'import * as OBC from "@thatopen/components";\nimport * as OBF from "@thatopen/components-front";\nimport * as THREE from "three";\nimport * as BUI from "@thatopen/ui";\nimport * as WEBIFC from "web-ifc";\nimport Stats from "stats.js";\nimport { RGBELoader } from "three/examples/jsm/loaders/RGBELoader.js";\n// You have to import * as FRAGS from "@thatopen/fragments"\nimport * as FRAGS from "../../../index";\n'})}),"\n",(0,s.jsx)(n.h3,{id:"-setting-up-a-simple-scene",children:"\ud83c\udf0e Setting up a Simple Scene"}),"\n",(0,s.jsx)(n.p,{children:"To get started, let's set up a basic ThreeJS scene with advanced rendering capabilities. This will serve as the foundation for our application and allow us to visualize the steel structures with proper lighting, shadows, and post-processing effects:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const container = document.getElementById("container")!;\n\nconst components = new OBC.Components();\n\nconst worlds = components.get(OBC.Worlds);\n\nconst world = worlds.create<\n  OBC.ShadowedScene,\n  OBC.OrthoPerspectiveCamera,\n  OBF.PostproductionRenderer\n>();\n\nworld.scene = new OBC.ShadowedScene(components);\nworld.renderer = new OBF.PostproductionRenderer(components, container);\nworld.camera = new OBC.OrthoPerspectiveCamera(components);\n\nworld.renderer.postproduction.enabled = true;\nworld.renderer.postproduction.style = OBF.PostproductionAspect.COLOR_PEN;\n\ncomponents.init();\n\nworld.camera.controls.setLookAt(12, 6, 8, 0, 0, -10);\n\nworld.renderer.three.shadowMap.enabled = true;\nworld.renderer.three.shadowMap.type = THREE.PCFSoftShadowMap;\n\nworld.scene.setup({\n  shadows: {\n    cascade: 1,\n    resolution: 1024,\n  },\n});\n\n// const prevBackground = world.scene.three.background;\n\nawait world.scene.updateShadows();\n\nworld.camera.controls.addEventListener("rest", async () => {\n  await world.scene.updateShadows();\n});\n\nconst axes = new THREE.AxesHelper(1);\nworld.scene.three.add(axes);\n'})}),"\n",(0,s.jsx)(n.h3,{id:"\ufe0f-configuration-settings",children:"\u2699\ufe0f Configuration Settings"}),"\n",(0,s.jsx)(n.p,{children:"We'll define all the parameters that control the dimensions and properties of our steel structure. These settings will allow us to create customizable steel frames with proper detailing and connections:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// prettier-ignore\nconst settings = {\n  length: 30,\n  lengthModules: 5,\n  columnWidth: 0.2,\n  columnLength: 0.2,\n  columnThickness: 0.03,\n  columnFlangeThickness: 0.03,\n  basePlateSize: 0.5,\n  basePlateCrossHeight: 0.2,\n  basePlateCornerSize: 0.1,\n  basePlateThickness: 0.01,\n  startPoints: [\n    [0, 0, 0], [0, 8, 0], \n    [0, 8, 0], [10, 10, 0], \n    [10, 10, 0], [20, 8, 0], \n    [20, 8, 0], [20, 0, 0],\n    [20, 4, 0], [30, 4, 0],\n    [30, 4, 0], [30, 0, 0],\n  ]\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"\ufe0f-setting-up-fragments",children:"\ud83d\udee0\ufe0f Setting Up Fragments"}),"\n",(0,s.jsx)(n.p,{children:"Now, let's configure the Fragments library core. This will allow us to load models effortlessly and start working with steel structures:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const workerUrl = "https://thatopen.github.io/engine_fragment/resources/worker.mjs";\nconst fragments = components.get(OBC.FragmentsManager);\nfragments.init(workerUrl);\n'})}),"\n",(0,s.jsx)(n.h3,{id:"\ufe0f-material-and-texture-setup",children:"\ud83d\uddbc\ufe0f Material and Texture Setup"}),"\n",(0,s.jsx)(n.p,{children:"We'll set up materials and textures for our steel structures. This includes processing textures and configuring material properties for realistic steel appearance:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const processTextures = (texture: THREE.Texture) => {\n  texture.wrapS = THREE.RepeatWrapping;\n  texture.wrapT = THREE.RepeatWrapping;\n  texture.repeat.set(0.2, 0.2);\n};\n\nconst textureLoader = new THREE.TextureLoader();\n\nconst roughnessMap = textureLoader.load(\n  "https://thatopen.github.io/engine_fragment/resources/textures/concrete/Concrete012_2K-JPG_Roughness.jpg",\n);\nprocessTextures(roughnessMap);\n\nfragments.core.models.materials.list.onItemSet.add(\n  ({ key: id, value: material }) => {\n    if ("map" in material) {\n      const standardMaterial = new THREE.MeshStandardMaterial({\n        color: material.color,\n        metalness: 0.9,\n        roughnessMap,\n        // roughness: 1,\n        side: THREE.DoubleSide,\n      }) as any;\n      fragments.core.models.materials.list.set(id, standardMaterial);\n    }\n  },\n);\n\nfragments.core.models.materials.list.onItemSet.add(({ value: material }) => {\n  const isLod = "isLodMaterial" in material && material.isLodMaterial;\n  if (isLod) {\n    world.renderer!.postproduction.basePass.isolatedMaterials.push(material);\n  }\n});\n\nfragments.core.settings.graphicsQuality = 1;\n\nworld.camera.controls.addEventListener("control", () => {\n  fragments.core.update();\n});\n\nfragments.core.models.list.onItemSet.add(({ value: model }) => {\n  model.tiles.onItemSet.add(({ value: mesh }) => {\n    if (!("isLODGeometry" in mesh.geometry)) {\n      const geometry = mesh.geometry as THREE.BufferGeometry;\n\n      mesh.castShadow = true;\n      mesh.receiveShadow = true;\n\n      // Cubic UV projection\n\n      // Step 1: Determine the direction to use for projection\n\n      const indexArray = geometry.index!.array;\n      const positions = geometry.attributes.position!.array!;\n      const normals = geometry.attributes.normal!.array!;\n\n      const uvArray = new Float32Array((positions.length / 3) * 2);\n\n      for (let i = 0; i < indexArray.length; i++) {\n        const index = indexArray[i];\n        const x = positions[index * 3];\n        const y = positions[index * 3 + 1];\n        const z = positions[index * 3 + 2];\n\n        const nx1 = normals[index * 3];\n        const ny1 = normals[index * 3 + 1];\n        const nz1 = normals[index * 3 + 2];\n\n        const absNx = Math.abs(nx1);\n        const absNy = Math.abs(ny1);\n        const absNz = Math.abs(nz1);\n\n        if (absNx > absNy && absNx > absNz) {\n          // Use x direction\n          uvArray[index * 2] = y;\n          uvArray[index * 2 + 1] = z;\n        } else if (absNy > absNx && absNy > absNz) {\n          // Use y direction\n          uvArray[index * 2] = x;\n          uvArray[index * 2 + 1] = z;\n        } else {\n          // Use z direction\n          uvArray[index * 2] = x;\n          uvArray[index * 2 + 1] = y;\n        }\n      }\n\n      const attr = new THREE.BufferAttribute(uvArray, 2);\n      attr.onUpload(function callback(this: any) {\n        delete this.array;\n      });\n\n      geometry.setAttribute("uv", attr);\n    }\n  });\n});\n\nfragments.core.models.list.onItemSet.add(({ value: model }) => {\n  model.tiles.onItemSet.add(({ value: mesh }) => {\n    if ("isMesh" in mesh) {\n      const mat = mesh.material as THREE.MeshStandardMaterial[];\n      if (mat[0].opacity === 1) {\n        mesh.castShadow = true;\n        mesh.receiveShadow = true;\n      }\n    }\n  });\n\n  model.getClippingPlanesEvent = () => {\n    return Array.from(world.renderer!.three.clippingPlanes) || [];\n  };\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"-creating-a-new-fragments-model",children:"\ud83d\udcc2 Creating a New Fragments Model"}),"\n",(0,s.jsx)(n.p,{children:"We'll create a new empty Fragments model to store our steel structure elements. This model will be built programmatically with steel beams, columns, and connection details:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const bytes = FRAGS.EditUtils.newModel({ raw: true });\n\n// @ts-ignore\nconst model = await fragments.core.load(bytes, {\n  modelId: "example",\n  camera: world.camera.three,\n  raw: true,\n});\n\nworld.scene.three.add(model.object);\n\nawait fragments.core.update(true);\n'})}),"\n",(0,s.jsx)(n.h3,{id:"-setting-up-the-geometry-engine",children:"\ud83e\uddca Setting up the Geometry Engine"}),"\n",(0,s.jsx)(n.p,{children:"Now, let's set up the Geometry Engine. We'll use it to generate the steel structure geometries:"}),"\n",(0,s.jsx)(n.admonition,{title:"Geometry Engine?",type:"warning",children:(0,s.jsx)(n.p,{children:"The Geometry Engine is a library that allows us to easily generate geometry parametrically using the Fragments API."})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const api = new WEBIFC.IfcAPI();\napi.SetWasmPath("https://unpkg.com/web-ifc@0.0.72/", true);\nawait api.Init();\n\nconst geometryEngine = new FRAGS.GeometryEngine(api);\n'})}),"\n",(0,s.jsx)(n.h3,{id:"-creating-basic-steel-geometries",children:"\ud83d\udd27 Creating Basic Steel Geometries"}),"\n",(0,s.jsx)(n.p,{children:"Now we'll create all the basic geometries that will be used to construct our steel structure. These include HDRI environment, wireframe models, and various steel connection elements:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const hdriLoader = new RGBELoader();\nhdriLoader.load(\n  "https://thatopen.github.io/engine_fragment/resources/textures/envmaps/san_giuseppe_bridge_2k.hdr",\n  (texture) => {\n    texture.mapping = THREE.EquirectangularReflectionMapping;\n    // world.scene.three.background = texture;\n    world.scene.three.environment = texture;\n    // world.scene.three.environmentIntensity = 4;\n  },\n);\n\n// Create wire model\n\nconst wireGeom = new THREE.BufferGeometry();\nconst wireMat = new THREE.LineBasicMaterial({ color: 0xff0000 });\nconst wireLines = new THREE.LineSegments(wireGeom, wireMat);\nworld.scene.three.add(wireLines);\n\n// Now let\'s define the function to regenerate the fragments\n\nlet processing = false;\n\n// We\'ll use this for boolean operations\n\nconst steelElementGeometry = new THREE.BufferGeometry();\n\n// Create foundation base plate\n\nconst tempMat = new THREE.MeshLambertMaterial({ color: "white", side: 2 });\n\nconst newMesh = (geometry: THREE.BufferGeometry) => {\n  const mesh = new THREE.Mesh(geometry, tempMat);\n  mesh.receiveShadow = true;\n  mesh.castShadow = true;\n  mesh.frustumCulled = false;\n  return mesh;\n};\n\nconst newExtrusion = (\n  profilePoints: number[],\n  direction: number[],\n  length: number,\n) => {\n  const geometry = new THREE.BufferGeometry();\n  // prettier-ignore\n  geometryEngine.getExtrusion(geometry, {\n    profilePoints,\n    direction,\n    length,\n  });\n  return newMesh(geometry);\n};\n\n// const newBoolean = (target: THREE.Mesh, operands: THREE.Mesh[]) => {\n//   const geometry = new THREE.BufferGeometry();\n//   // prettier-ignore\n//   geometryEngine.getBooleanOperation(geometry, {\n//     type: "DIFFERENCE",\n//     target,\n//     operands,\n//   });\n//   return newMesh(geometry);\n// };\n\nconst getCirclePoints = (radius: number, segments: number) => {\n  const geometry = new THREE.CircleGeometry(radius, segments);\n  const profilePoints: number[] = [];\n  const index = geometry.index!.array;\n  const pos = geometry.attributes.position.array;\n  for (let i = 0; i < index.length; i++) {\n    const currentIndex = index[i];\n    profilePoints.push(pos[currentIndex * 3]);\n    profilePoints.push(pos[currentIndex * 3 + 1]);\n    profilePoints.push(pos[currentIndex * 3 + 2]);\n  }\n\n  const rotation = new THREE.Matrix4().makeRotationX(Math.PI / 2);\n  const transformedPoints = geometryEngine.transformPoints(\n    profilePoints,\n    rotation,\n  );\n  return transformedPoints;\n};\n\n// The plate is centered at the origin\nconst newPlate = (width: number, length: number, thickness: number) => {\n  // prettier-ignore\n  return newExtrusion(\n    [\n      -width / 2, 0, -length / 2, \n      -width / 2, 0, length / 2,\n      width / 2, 0, length / 2,\n      width / 2, 0, -length / 2,\n    ],\n    [0, 1, 0],\n    thickness,\n  );\n};\n\nconst newCylinder = (radius: number, height: number, segments: number) => {\n  const points = getCirclePoints(radius, segments);\n  // prettier-ignore\n  const base = newExtrusion(\n    points,\n    [0, 1, 0],\n    height,\n  );\n\n  return base;\n};\n\nconst basePlateMesh = newPlate(\n  settings.basePlateSize,\n  settings.basePlateSize,\n  settings.basePlateThickness,\n);\n\nconst baseCrossPlateMesh = newPlate(\n  settings.basePlateThickness * 2,\n  settings.basePlateSize / 2,\n  settings.basePlateCrossHeight,\n);\n\nconst cornerPlateMesh = newPlate(\n  settings.basePlateCornerSize,\n  settings.basePlateCornerSize,\n  settings.basePlateThickness,\n);\n\nconst boltHeadMesh = newCylinder(\n  settings.basePlateSize / 15,\n  settings.basePlateSize / 15,\n  6,\n);\n'})}),"\n",(0,s.jsx)(n.h3,{id:"-fragment-regeneration-logic",children:"\ud83d\udd04 Fragment Regeneration Logic"}),"\n",(0,s.jsx)(n.p,{children:"This function handles the regeneration of fragments when parameters change. It creates steel elements, base plates, connections, and other structural components based on the wireframe geometry:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const regenerateFragments = async () => {\n  if (!wireGeom.attributes.position) {\n    console.log("No wire geometry");\n    return;\n  }\n\n  const tempObject = new THREE.Object3D();\n\n  const elementsData: FRAGS.NewElementData[] = [];\n\n  await fragments.core.editor.reset(model.modelId);\n\n  const matId = fragments.core.editor.createMaterial(\n    model.modelId,\n    new THREE.MeshLambertMaterial({\n      color: new THREE.Color(1, 1, 1),\n      side: THREE.DoubleSide,\n    }),\n  );\n\n  const ltId = fragments.core.editor.createLocalTransform(\n    model.modelId,\n    new THREE.Matrix4().identity(),\n  );\n\n  // GEOMETRIES\n\n  const basePlateGeom = basePlateMesh.geometry;\n  const basePlateGeomId = fragments.core.editor.createShell(\n    model.modelId,\n    basePlateGeom,\n  );\n\n  const baseCrossPlateGeom = baseCrossPlateMesh.geometry;\n  const baseCrossPlateGeomId = fragments.core.editor.createShell(\n    model.modelId,\n    baseCrossPlateGeom,\n  );\n\n  const cornerPlateGeom = cornerPlateMesh.geometry;\n  const cornerPlateGeomId = fragments.core.editor.createShell(\n    model.modelId,\n    cornerPlateGeom,\n  );\n\n  const baseBoltGeom = boltHeadMesh.geometry;\n  const baseBoltGeomId = fragments.core.editor.createShell(\n    model.modelId,\n    baseBoltGeom,\n  );\n\n  const baseHookRadius = settings.basePlateSize / 10;\n  const baseHookThickness = settings.basePlateThickness;\n\n  const xDirection1 = new THREE.Vector3(1, 0, 0);\n  const yDirection1 = new THREE.Vector3(0, 1, 0);\n  const xDirection2 = new THREE.Vector3(1, 0, 0);\n  const yDirection2 = new THREE.Vector3(0, 1, 0);\n  tempObject.position.set(0, 0, 0);\n\n  tempObject.rotation.set(0, 0, 0);\n  tempObject.rotation.y = -Math.PI / 2;\n  tempObject.updateMatrix();\n  xDirection1.applyMatrix4(tempObject.matrix);\n  yDirection1.applyMatrix4(tempObject.matrix);\n  tempObject.rotation.set(0, 0, 0);\n  tempObject.rotation.z = Math.PI / 2;\n  tempObject.updateMatrix();\n  xDirection1.applyMatrix4(tempObject.matrix);\n  yDirection1.applyMatrix4(tempObject.matrix);\n\n  tempObject.rotation.set(0, 0, 0);\n  tempObject.rotation.y = Math.PI / 2;\n  tempObject.updateMatrix();\n  xDirection2.applyMatrix4(tempObject.matrix);\n  yDirection2.applyMatrix4(tempObject.matrix);\n  tempObject.rotation.set(0, 0, 0);\n  tempObject.rotation.z = -Math.PI / 2;\n  tempObject.updateMatrix();\n  xDirection2.applyMatrix4(tempObject.matrix);\n  yDirection2.applyMatrix4(tempObject.matrix);\n\n  // prettier-ignore\n  const baseHookGeomId = fragments.core.editor.createCircleExtrusion(\n    model.modelId,\n    {\n      radius: [baseHookThickness],\n      axes: [\n        {\n          wires: [\n            [ 0, 0.06, 0, 0, -0.6 + baseHookRadius, 0 ],\n            [ baseHookRadius, -0.6, 0, 0.15 - baseHookRadius, -0.6, 0 ],\n            [ 0.15, -0.6 + baseHookRadius, 0, 0.15, -0.5, 0 ],\n          ],\n          wireSets: [],\n          circleCurves: [\n          {\n            aperture: Math.PI / 2,\n            position: [baseHookRadius, -0.6 + baseHookRadius, 0],\n            radius: baseHookRadius,\n            xDirection: [xDirection1.x, xDirection1.y, xDirection1.z],\n            yDirection: [yDirection1.x, yDirection1.y, yDirection1.z],\n          },\n          {\n            aperture: Math.PI / 2,\n            position: [0.15-baseHookRadius, -0.6 + baseHookRadius, 0],\n            radius: baseHookRadius,\n            xDirection: [xDirection2.x, xDirection2.y, xDirection2.z],\n            yDirection: [yDirection2.x, yDirection2.y, yDirection2.z],\n          }\n        ],\n          order: [0, 1, 2, 0, 1],\n          parts: [FRAGS.AxisPartClass.WIRE, FRAGS.AxisPartClass.WIRE, FRAGS.AxisPartClass.WIRE, FRAGS.AxisPartClass.CIRCLE_CURVE, FRAGS.AxisPartClass.CIRCLE_CURVE],\n        },\n      ],\n    },\n  );\n\n  // PROFILES\n\n  const profilePoints = geometryEngine.getProfilePoints({\n    type: FRAGS.ProfileType.H,\n    width: settings.columnWidth,\n    depth: settings.columnLength,\n    thickness: settings.columnThickness,\n    flangeThickness: settings.columnFlangeThickness,\n  });\n\n  const p1 = new THREE.Vector3();\n  const p2 = new THREE.Vector3();\n\n  const wirePoints = wireGeom.attributes.position.array;\n  for (let i = 0; i < wirePoints.length; i += 6) {\n    const x1 = wirePoints[i];\n    const y1 = wirePoints[i + 1];\n    const z1 = wirePoints[i + 2];\n    const x2 = wirePoints[i + 3];\n    const y2 = wirePoints[i + 4];\n    const z2 = wirePoints[i + 5];\n    p1.set(x1, y1, z1);\n    p2.set(x2, y2, z2);\n\n    // Create base plate\n    if (y1 === 0 || y2 === 0) {\n      // Add base plate\n      const isFirst = y1 === 0;\n      const x = isFirst ? x1 : x2;\n      const y = isFirst ? y1 : y2;\n      const z = isFirst ? z1 : z2;\n      basePlateMesh.position.set(x, y, z);\n      basePlateMesh.updateMatrix();\n\n      elementsData.push({\n        attributes: {\n          _category: {\n            value: "test",\n          },\n        },\n        globalTransform: basePlateMesh.matrix.clone(),\n        samples: [\n          {\n            localTransform: ltId,\n            representation: basePlateGeomId,\n            material: matId,\n          },\n        ],\n      });\n\n      // Add base cross plates\n\n      const cpOffset = 0.1;\n      for (let i = 0; i < 2; i++) {\n        const height = -settings.basePlateCrossHeight;\n        const offset = i === 0 ? -cpOffset : cpOffset;\n        baseCrossPlateMesh.position.set(x + offset, height, z);\n        baseCrossPlateMesh.updateMatrix();\n        elementsData.push({\n          attributes: {\n            _category: {\n              value: "test",\n            },\n          },\n          globalTransform: baseCrossPlateMesh.matrix.clone(),\n          samples: [\n            {\n              localTransform: ltId,\n              representation: baseCrossPlateGeomId,\n              material: matId,\n            },\n          ],\n        });\n      }\n\n      const cOffset =\n        settings.basePlateSize / 2 - settings.basePlateCornerSize / 2;\n\n      const cornerOffsets: THREE.Vector3[] = [\n        new THREE.Vector3(cOffset, 0, cOffset),\n        new THREE.Vector3(-cOffset, 0, cOffset),\n        new THREE.Vector3(cOffset, 0, -cOffset),\n        new THREE.Vector3(-cOffset, 0, -cOffset),\n      ];\n\n      let cornerIndex = 0;\n      for (const offset of cornerOffsets) {\n        // Add corner plate\n        cornerPlateMesh.position.set(x, y + settings.basePlateThickness, z);\n        cornerPlateMesh.position.add(offset);\n        cornerPlateMesh.updateMatrix();\n        elementsData.push({\n          attributes: {\n            _category: {\n              value: "test",\n            },\n          },\n          globalTransform: cornerPlateMesh.matrix.clone(),\n          samples: [\n            {\n              localTransform: ltId,\n              representation: cornerPlateGeomId,\n              material: matId,\n            },\n          ],\n        });\n\n        // Add base bolt\n        boltHeadMesh.position.set(x, y + settings.basePlateThickness, z);\n        boltHeadMesh.position.add(offset);\n        boltHeadMesh.updateMatrix();\n        elementsData.push({\n          attributes: {\n            _category: {\n              value: "test",\n            },\n          },\n          globalTransform: boltHeadMesh.matrix.clone(),\n          samples: [\n            {\n              localTransform: ltId,\n              representation: baseBoltGeomId,\n              material: matId,\n            },\n          ],\n        });\n\n        // Add base hook\n        tempObject.position.copy(boltHeadMesh.position);\n        tempObject.rotation.set(0, 0, 0);\n        if (cornerIndex === 0 || cornerIndex === 2) {\n          tempObject.rotation.y = Math.PI;\n        }\n        tempObject.updateMatrix();\n        elementsData.push({\n          attributes: {\n            _category: {\n              value: "test",\n            },\n          },\n          globalTransform: tempObject.matrix.clone(),\n          samples: [\n            {\n              localTransform: ltId,\n              representation: baseHookGeomId,\n              material: matId,\n            },\n          ],\n        });\n        cornerIndex++;\n      }\n    }\n\n    const direction = p2.clone().sub(p1).normalize();\n\n    tempObject.position.copy(p1);\n    tempObject.lookAt(p2);\n    tempObject.position.set(0, 0, 0);\n    tempObject.updateMatrix();\n\n    const transfomedProfilePoints = geometryEngine.transformPoints(\n      [...profilePoints],\n      tempObject.matrix.clone(),\n    );\n\n    // prettier-ignore\n    geometryEngine.getExtrusion(steelElementGeometry, {\n      profilePoints: transfomedProfilePoints,\n      direction: [direction.x, direction.y, direction.z],\n      length: p1.distanceTo(p2),\n    });\n\n    const steelElementGeomId = fragments.core.editor.createShell(\n      model.modelId,\n      steelElementGeometry,\n    );\n\n    tempObject.position.copy(p1);\n    tempObject.rotation.set(0, 0, 0);\n    tempObject.updateMatrix();\n\n    elementsData.push({\n      attributes: {\n        _category: {\n          value: "test",\n        },\n      },\n      globalTransform: tempObject.matrix.clone(),\n      samples: [\n        {\n          localTransform: ltId,\n          representation: steelElementGeomId,\n          material: matId,\n        },\n      ],\n    });\n  }\n\n  await fragments.core.editor.createElements(model.modelId, elementsData);\n\n  await fragments.core.update(true);\n\n  processing = false;\n};\n\nlet lastUpdate: any = null;\nconst maxUpdateRate = 1000; // ms\nconst requestFragmentsUpdate = () => {\n  if (processing) {\n    return;\n  }\n  processing = true;\n\n  if (lastUpdate) {\n    clearTimeout(lastUpdate);\n  }\n  lastUpdate = setTimeout(() => {\n    regenerateFragments();\n  }, maxUpdateRate);\n};\n'})}),"\n",(0,s.jsx)(n.h3,{id:"\ufe0f-model-regeneration",children:"\ud83c\udfd7\ufe0f Model Regeneration"}),"\n",(0,s.jsx)(n.p,{children:"This function regenerates the entire steel structure including the wireframe geometry. It calculates all the structural connections and creates the appropriate steel element configurations:"}),"\n",(0,s.jsx)(n.admonition,{title:"Steel Structure Types",type:"info",children:(0,s.jsx)(n.p,{children:"We'll create various steel elements including main frames, transversal beams, base plates, connection details, and bolts. Each element has specific geometric requirements and connection details."})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const regenerate = () => {\n  const points: THREE.Vector3[] = [];\n\n  const lengthDistance = settings.length / settings.lengthModules;\n\n  // Main frame\n\n  for (let i = 0; i < settings.lengthModules; i++) {\n    for (let j = 0; j < settings.startPoints.length; j++) {\n      const point = settings.startPoints[j];\n      const [x, y, z] = point;\n      const offsetZ = z + lengthDistance * i;\n      points.push(new THREE.Vector3(x, y, offsetZ));\n    }\n  }\n\n  // Transversal beams\n\n  for (let i = 0; i < settings.lengthModules - 1; i++) {\n    for (let j = 0; j < settings.startPoints.length; j++) {\n      const point = settings.startPoints[j];\n      const [x1, y1, z1] = point;\n      if (y1 === 0) {\n        // We don\'t want transversal beams on the ground\n        continue;\n      }\n      const offsetZ = z1 + lengthDistance * i;\n      const x2 = x1;\n      const y2 = y1;\n      const z2 = offsetZ + lengthDistance;\n      points.push(new THREE.Vector3(x1, y1, offsetZ));\n      points.push(new THREE.Vector3(x2, y2, z2));\n    }\n  }\n\n  wireGeom.deleteAttribute("position");\n  wireGeom.setFromPoints(points);\n\n  requestFragmentsUpdate();\n};\n\nregenerate();\n'})}),"\n",(0,s.jsx)(n.h3,{id:"-adding-user-interface",children:"\ud83e\udde9 Adding User Interface"}),"\n",(0,s.jsxs)(n.p,{children:["We will use the ",(0,s.jsx)(n.code,{children:"@thatopen/ui"})," library to add some simple and cool UI elements to our app. First, we need to call the ",(0,s.jsx)(n.code,{children:"init"})," method of the ",(0,s.jsx)(n.code,{children:"BUI.Manager"})," class to initialize the library:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'BUI.Manager.init();\n\nconst [panel] = BUI.Component.create<BUI.PanelSection, any>((_) => {\n  return BUI.html`\n    <bim-panel style="min-width: 25rem;" id="controls-panel" active label="Element Editor" class="options-menu">\n\n      <bim-panel-section label="Controls">\n\n      <bim-number-input label="Length Modules" slider min=2 max=10 step=1 value=${settings.lengthModules} @change=${(\n        e: any,\n      ) => {\n        settings.lengthModules = e.target.value;\n        regenerate();\n      }}></bim-number-input>\n\n      <bim-number-input label="Length" slider min=10 max=100 step=1 value=${settings.length} @change=${(\n        e: any,\n      ) => {\n        settings.length = e.target.value;\n        regenerate();\n      }}></bim-number-input>\n      \n\n      </bim-panel-section>\n\n    </bim-panel>\n  `;\n}, {});\n\ndocument.body.append(panel);\n'})}),"\n",(0,s.jsx)(n.h3,{id:"-mobile-friendly-menu",children:"\ud83d\udcf1 Mobile-Friendly Menu"}),"\n",(0,s.jsx)(n.p,{children:"We will make some logic that adds a button to the screen when the user is visiting our app from their phone, allowing to show or hide the menu. Otherwise, the menu would make the app unusable."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const button = BUI.Component.create<BUI.PanelSection>(() => {\n  const onClick = () => {\n    if (panel.classList.contains("options-menu-visible")) {\n      panel.classList.remove("options-menu-visible");\n    } else {\n      panel.classList.add("options-menu-visible");\n    }\n  };\n\n  return BUI.html`\n    <bim-button class="phone-menu-toggler" icon="solar:settings-bold"\n      @click=${onClick}>\n    </bim-button>\n  `;\n});\n\ndocument.body.append(button);\n'})}),"\n",(0,s.jsx)(n.h3,{id:"\ufe0f-measuring-the-performance-optional",children:"\u23f1\ufe0f Measuring the Performance (optional)"}),"\n",(0,s.jsxs)(n.p,{children:["We'll use the ",(0,s.jsx)(n.a,{href:"https://github.com/mrdoob/stats.js",children:"Stats.js"})," to measure the performance of our app. We will add it to the top left corner of the viewport. This way, we'll make sure that the memory consumption and the FPS of our app are under control."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const stats = new Stats();\nstats.showPanel(2);\ndocument.body.append(stats.dom);\nstats.dom.style.left = "0px";\nstats.dom.style.zIndex = "unset";\nworld.renderer.onBeforeUpdate.add(() => stats.begin());\nworld.renderer.onAfterUpdate.add(() => stats.end());\n'})}),"\n",(0,s.jsx)(n.h3,{id:"-congratulations",children:"\ud83c\udf89 Congratulations!"}),"\n",(0,s.jsx)(n.p,{children:"You've successfully learned how to create detailed steel structures using the Fragments API! \ud83d\ude80\nNow you can create parametric steel frames with customizable dimensions, connections, and detailing. Ready to explore more? Check out our other tutorials to unlock the full potential of Fragments! \ud83d\udca1"})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var s=t(6540);const r={},o=s.createContext(r);function a(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);