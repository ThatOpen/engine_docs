"use strict";(self.webpackChunkengine_docs=self.webpackChunkengine_docs||[]).push([[1380],{6974:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>i,metadata:()=>r,toc:()=>c});var o=t(4848),s=t(8453);const i={},a=void 0,r={id:"Tutorials/Components/Core/Views",title:"Views",description:'window.open("https://thatopen.github.io/engine_components/examples/Views")} >Go Full Screen',source:"@site/docs/Tutorials/Components/Core/Views.mdx",sourceDirName:"Tutorials/Components/Core",slug:"/Tutorials/Components/Core/Views",permalink:"/Tutorials/Components/Core/Views",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Viewpoints",permalink:"/Tutorials/Components/Core/Viewpoints"},next:{title:"Worlds",permalink:"/Tutorials/Components/Core/Worlds"}},l={},c=[{value:"\ud83d\udcc4 Adding 2D Views",id:"-adding-2d-views",level:2},{value:"\ud83d\udd96 Importing our Libraries",id:"-importing-our-libraries",level:3},{value:"\ud83c\udf0e Setting up a Simple Scene",id:"-setting-up-a-simple-scene",level:3},{value:"\ud83d\udee0\ufe0f Setting Up Fragments",id:"\ufe0f-setting-up-fragments",level:3},{value:"\ud83d\udcc2 Loading Fragments Models",id:"-loading-fragments-models",level:3},{value:"\u2728 Using The Views Component",id:"-using-the-views-component",level:3},{value:"\ud83c\udfe2 Creating Views From IFC Storeys",id:"-creating-views-from-ifc-storeys",level:3},{value:"\ud83e\udded Creating Elevation Views",id:"-creating-elevation-views",level:3},{value:"\u2702\ufe0f Creating Arbitrary Views",id:"\ufe0f-creating-arbitrary-views",level:3},{value:"\ud83e\udde9 Adding some UI (optional but recommended)",id:"-adding-some-ui-optional-but-recommended",level:3},{value:"\u23f1\ufe0f Measuring the performance (optional)",id:"\ufe0f-measuring-the-performance-optional",level:3},{value:"\ud83c\udf89 Wrap up",id:"-wrap-up",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",hr:"hr",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)("div",{style:{position:"relative"},children:[(0,o.jsx)("iframe",{src:"https://thatopen.github.io/engine_components/examples/Views"}),(0,o.jsx)("button",{class:"full-screen-btn",onClick:()=>window.open("https://thatopen.github.io/engine_components/examples/Views"),children:"Go Full Screen"})]}),"\n",(0,o.jsx)(n.admonition,{title:"Source",type:"info",children:(0,o.jsxs)(n.p,{children:["Copying and pasting? We've got you covered! You can find the full source code of this tutorial ",(0,o.jsx)(n.a,{href:"https://github.com/ThatOpen/engine_components/blob/main/packages/core/src/core/Views/example.ts",children:"here"}),"."]})}),"\n",(0,o.jsx)(n.h2,{id:"-adding-2d-views",children:"\ud83d\udcc4 Adding 2D Views"}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.p,{children:"In the construction industry, 2D views such as plans, elevations, and sections are essential for understanding and communicating project details effectively. With That Open Engine, you can create and manage these views seamlessly, leveraging its powerful and efficient handling of BIM data to streamline workflows and enhance visualization. Let's see how is done!"}),"\n",(0,o.jsx)(n.h3,{id:"-importing-our-libraries",children:"\ud83d\udd96 Importing our Libraries"}),"\n",(0,o.jsx)(n.p,{children:"First things first, let's install all necessary dependencies to make this example work:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'import Stats from "stats.js";\nimport * as BUI from "@thatopen/ui";\n// You have to import * as OBC from "@thatopen/components"\nimport * as OBC from "../..";\n'})}),"\n",(0,o.jsx)(n.h3,{id:"-setting-up-a-simple-scene",children:"\ud83c\udf0e Setting up a Simple Scene"}),"\n",(0,o.jsx)(n.p,{children:"To get started, let's set up a basic ThreeJS scene. This will serve as the foundation for our application and allow us to visualize the 3D models effectively:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'const components = new OBC.Components();\n\nconst worlds = components.get(OBC.Worlds);\nconst world = worlds.create<\n  OBC.SimpleScene,\n  OBC.OrthoPerspectiveCamera,\n  OBC.SimpleRenderer\n>();\n\nworld.scene = new OBC.SimpleScene(components);\nworld.scene.setup();\nworld.scene.three.background = null;\n\nconst container = document.getElementById("container")!;\nworld.renderer = new OBC.SimpleRenderer(components, container);\nworld.camera = new OBC.OrthoPerspectiveCamera(components);\nawait world.camera.controls.setLookAt(78, 20, -2.2, 26, -4, 25);\n\ncomponents.init();\n'})}),"\n",(0,o.jsx)(n.h3,{id:"\ufe0f-setting-up-fragments",children:"\ud83d\udee0\ufe0f Setting Up Fragments"}),"\n",(0,o.jsx)(n.p,{children:"Now, let's configure the FragmentsManager. This will allow us to load models effortlessly and start manipulating them with ease:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'const githubUrl =\n  "https://thatopen.github.io/engine_fragment/resources/worker.mjs";\nconst fetchedUrl = await fetch(githubUrl);\nconst workerBlob = await fetchedUrl.blob();\nconst workerFile = new File([workerBlob], "worker.mjs", {\n  type: "text/javascript",\n});\nconst workerUrl = URL.createObjectURL(workerFile);\nconst fragments = components.get(OBC.FragmentsManager);\nfragments.init(workerUrl);\n\nworld.camera.controls.addEventListener("rest", () =>\n  fragments.core.update(true),\n);\n\nworld.onCameraChanged.add((camera) => {\n  for (const [, model] of fragments.list) {\n    model.useCamera(camera.three);\n  }\n  fragments.core.update(true);\n});\n\nfragments.list.onItemSet.add(({ value: model }) => {\n  model.useCamera(world.camera.three);\n  world.scene.three.add(model.object);\n  fragments.core.update(true);\n});\n'})}),"\n",(0,o.jsx)(n.h3,{id:"-loading-fragments-models",children:"\ud83d\udcc2 Loading Fragments Models"}),"\n",(0,o.jsx)(n.p,{children:"With the core setup complete, it's time to load a Fragments model into our scene. Fragments are optimized for fast loading and rendering, making them ideal for large-scale 3D models."}),"\n",(0,o.jsx)(n.admonition,{title:"Where can I find Fragment files?",type:"info",children:(0,o.jsx)(n.p,{children:"You can use the sample Fragment files available in our repository for testing. If you have an IFC model you'd like to convert to Fragments, check out the IfcImporter tutorial for detailed instructions."})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'const fragPaths = [\n  "https://thatopen.github.io/engine_components/resources/frags/school_arq.frag",\n  "https://thatopen.github.io/engine_components/resources/frags/school_str.frag",\n];\nawait Promise.all(\n  fragPaths.map(async (path) => {\n    const modelId = path.split("/").pop()?.split(".").shift();\n    if (!modelId) return null;\n    const file = await fetch(path);\n    const buffer = await file.arrayBuffer();\n    return fragments.core.load(buffer, { modelId });\n  }),\n);\n'})}),"\n",(0,o.jsx)(n.h3,{id:"-using-the-views-component",children:"\u2728 Using The Views Component"}),"\n",(0,o.jsx)(n.p,{children:"With just one single component, you can create any 2D view you need (plan, elevation, or section). Actually, you can create views at any arbitrary position and normal direction you want. But first things first, let's start by getting an instance of the component."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'const views = components.get(OBC.Views);\n\n// The range defines how far the view will "see".\n// You can specify a default value, but it can be changed\n// independently for each view instance after creation.\nOBC.Views.defaultRange = 100;\n'})}),"\n",(0,o.jsx)(n.p,{children:"Views created with the component need a world to be displayed. You can specify the world at creation time, but it's more convenient to set the world directly in the Views component, so all new views created will inherit the value."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"views.world = world;\n"})}),"\n",(0,o.jsx)(n.h3,{id:"-creating-views-from-ifc-storeys",children:"\ud83c\udfe2 Creating Views From IFC Storeys"}),"\n",(0,o.jsx)(n.p,{children:"Despite you can create arbitrary views with the component, it's most common use is to represent the floor plans. You can do the calculations by yourself, but the component comes with a handy method that lets create the views from the IfcStoreys. Doing it is very simple, and you can proceed as follows:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"// You can specify which models the storeys will be taken from\n// in order to create the views.\n// In this case, just the architectural model will be used.\nawait views.createFromIfcStoreys({ modelIds: [/arq/] });\n"})}),"\n",(0,o.jsx)(n.admonition,{title:"Views From Storeys",type:"note",children:(0,o.jsx)(n.p,{children:"It's worth noting that the built-in method to create views from storeys assumes your Fragments Model comes from an IFC model, as it uses the IfcBuildingStorey attributes to extract the information. If your model uses a different schema than IFC, then you must create the views yourself based on the model attributes."})}),"\n",(0,o.jsx)(n.h3,{id:"-creating-elevation-views",children:"\ud83e\udded Creating Elevation Views"}),"\n",(0,o.jsx)(n.p,{children:"Elevations are another useful type of view. They allow you to visualize the model from specific directions, such as north, south, east, or west. To achieve this, the model's bounding boxes are required. However, you don't need to do anything manually, as there is a built-in method that handles the heavy lifting. You can proceed as follows:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"views.createElevations({ combine: true });\n"})}),"\n",(0,o.jsx)(n.admonition,{title:"Z-fighting",type:"warning",children:(0,o.jsx)(n.p,{children:"Please be aware that the models used in this tutorial have z-fighting issues. This occurs because the same slabs and many walls are present in both models. Because of that, you will see some glitches in the views (even in 3D)."})}),"\n",(0,o.jsx)(n.h3,{id:"\ufe0f-creating-arbitrary-views",children:"\u2702\ufe0f Creating Arbitrary Views"}),"\n",(0,o.jsx)(n.p,{children:"So far, we have seen how to create views very easily for the most common use cases: plans and elevations. However, construction projects often require very specific 2D views to be made, called sections. As they can be located anywhere in the model, it is more convenient to create them manually. They can be created programmatically or through user interaction. In this case, let's use the Raycaster component to create sections when the user double-clicks on a surface."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'const casters = components.get(OBC.Raycasters);\nconst caster = casters.get(world);\n\nwindow.addEventListener("dblclick", async () => {\n  const result = await caster.castRay();\n  if (!result) return;\n  const { normal, point } = result;\n  if (!(normal && point)) return;\n  // you should invert the normal direction\n  // so the view looks inside\n  const invertedNormal = normal.clone().negate();\n  const view = views.create(invertedNormal, point.addScaledVector(normal, 1), {\n    id: `View - ${views.list.size + 1}`,\n    world,\n  });\n  // You can specify a different range from the default once the view is created.\n  view.range = 10;\n  // Displaying the helper is optional and is recommended only for debugging purposes.\n  view.helpersVisible = true;\n});\n'})}),"\n",(0,o.jsx)(n.h3,{id:"-adding-some-ui-optional-but-recommended",children:"\ud83e\udde9 Adding some UI (optional but recommended)"}),"\n",(0,o.jsxs)(n.p,{children:["We will use the ",(0,o.jsx)(n.code,{children:"@thatopen/ui"})," library to add some simple and cool UI elements to our app. First, we need to call the ",(0,o.jsx)(n.code,{children:"init"})," method of the ",(0,o.jsx)(n.code,{children:"BUI.Manager"})," class to initialize the library:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"BUI.Manager.init();\n"})}),"\n",(0,o.jsx)(n.p,{children:"Now we will add some UI to play around with the actions in this tutorial. For more information about the UI library, you can check the specific documentation for it!"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'type ViewsListTableData = {\n  Name: string;\n  Actions: string;\n};\n\ninterface ViewsListState {\n  components: OBC.Components;\n}\n\nconst viewsTemplate: BUI.StatefullComponent<ViewsListState> = (state) => {\n  const { components } = state;\n  const views = components.get(OBC.Views);\n\n  const onCreated = (e?: Element) => {\n    if (!e) return;\n    const table = e as BUI.Table<ViewsListTableData>;\n    table.data = [...views.list.keys()].map((key) => {\n      return {\n        data: {\n          Name: key,\n          Actions: "",\n        },\n      };\n    });\n  };\n\n  return BUI.html`<bim-table ${BUI.ref(onCreated)}></bim-table>`;\n};\n\nconst [viewsTable, updateViewsTable] = BUI.Component.create<\n  BUI.Table<ViewsListTableData>,\n  ViewsListState\n>(viewsTemplate, { components });\n\nviewsTable.headersHidden = true;\nviewsTable.noIndentation = true;\nviewsTable.columns = ["Name", { name: "Actions", width: "auto" }];\n\nviewsTable.dataTransform = {\n  Actions: (_, rowData) => {\n    const { Name } = rowData;\n    if (!Name) return _;\n    const views = components.get(OBC.Views);\n    const view = views.list.get(Name);\n    if (!view) return _;\n\n    const onOpen = () => {\n      views.open(Name);\n    };\n\n    const onRemove = () => {\n      views.list.delete(Name);\n    };\n\n    return BUI.html`\n      <bim-button label-hidden icon="solar:cursor-bold" label="Open" @click=${onOpen}></bim-button>\n      <bim-button label-hidden icon="material-symbols:delete" label="Remove" @click=${onRemove}></bim-button>\n    `;\n  },\n};\n\nconst updateFunction = () => updateViewsTable();\nviews.list.onItemSet.add(updateFunction);\nviews.list.onItemDeleted.add(updateFunction);\nviews.list.onItemUpdated.add(updateFunction);\nviews.list.onCleared.add(updateFunction);\n\nconst panel = BUI.Component.create<BUI.PanelSection>(() => {\n  const onCloseView = () => views.close();\n\n  return BUI.html`\n    <bim-panel active label="2D Views Tutorial" class="options-menu">\n      <bim-panel-section  label="Info">\n        <bim-label style="width: 16rem; white-space: normal;" icon="noto-v1:light-bulb">Tip: Go inside the building and double click a wall to create a section</bim-label>\n      </bim-panel-section>\n      <bim-panel-section  label="Views">\n        <bim-button label="Close Active 2D View" @click=${onCloseView}></bim-button>\n        ${viewsTable}\n      </bim-panel-section>\n    </bim-panel>\n  `;\n});\n\ndocument.body.append(panel);\n'})}),"\n",(0,o.jsx)(n.p,{children:"And we will make some logic that adds a button to the screen when the user is visiting our app from their phone, allowing to show or hide the menu. Otherwise, the menu would make the app unusable."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'const button = BUI.Component.create<BUI.PanelSection>(() => {\n  return BUI.html`\n      <bim-button class="phone-menu-toggler" icon="solar:settings-bold"\n        @click="${() => {\n          if (panel.classList.contains("options-menu-visible")) {\n            panel.classList.remove("options-menu-visible");\n          } else {\n            panel.classList.add("options-menu-visible");\n          }\n        }}">\n      </bim-button>\n    `;\n});\n\ndocument.body.append(button);\n'})}),"\n",(0,o.jsx)(n.h3,{id:"\ufe0f-measuring-the-performance-optional",children:"\u23f1\ufe0f Measuring the performance (optional)"}),"\n",(0,o.jsxs)(n.p,{children:["We'll use the ",(0,o.jsx)(n.a,{href:"https://github.com/mrdoob/stats.js",children:"Stats.js"})," to measure the performance of our app. We will add it to the top left corner of the viewport. This way, we'll make sure that the memory consumption and the FPS of our app are under control."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'const stats = new Stats();\nstats.showPanel(2);\ndocument.body.append(stats.dom);\nstats.dom.style.left = "0px";\nstats.dom.style.zIndex = "unset";\nworld.renderer.onBeforeUpdate.add(() => stats.begin());\nworld.renderer.onAfterUpdate.add(() => stats.end());\n'})}),"\n",(0,o.jsx)(n.h3,{id:"-wrap-up",children:"\ud83c\udf89 Wrap up"}),"\n",(0,o.jsx)(n.p,{children:"That's it! Now you're able to create 2D views such as plans, elevations, and sections programmatically in your BIM app. Congratulations! Keep going with more tutorials in the documentation."})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var o=t(6540);const s={},i=o.createContext(s);function a(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);