"use strict";(self.webpackChunkengine_docs=self.webpackChunkengine_docs||[]).push([[6611],{2182:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>a,default:()=>d,frontMatter:()=>l,metadata:()=>o,toc:()=>c});var i=t(4848),s=t(8453);const l={},a=void 0,o={id:"Tutorials/Components/Front/ClipStyler",title:"ClipStyler",description:'window.open("https://thatopen.github.io/engine_components/examples/ClipStyler")} >Go Full Screen',source:"@site/docs/Tutorials/Components/Front/ClipStyler.mdx",sourceDirName:"Tutorials/Components/Front",slug:"/Tutorials/Components/Front/ClipStyler",permalink:"/Tutorials/Components/Front/ClipStyler",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"CivilNavigators",permalink:"/Tutorials/Components/Front/CivilNavigators"},next:{title:"Highlighter",permalink:"/Tutorials/Components/Front/Highlighter"}},r={},c=[{value:"\u2702\ufe0f Fancy Clippings",id:"\ufe0f-fancy-clippings",level:2},{value:"\ud83d\udd96 Importing our Libraries",id:"-importing-our-libraries",level:3},{value:"\ud83c\udf0e Setting up a Simple Scene",id:"-setting-up-a-simple-scene",level:3},{value:"\ud83d\udee0\ufe0f Setting Up Fragments",id:"\ufe0f-setting-up-fragments",level:3},{value:"\ud83d\udcc2 Loading Fragments Models",id:"-loading-fragments-models",level:3},{value:"\u2728 Using The Clip Styler Component",id:"-using-the-clip-styler-component",level:3},{value:"\ud83d\udd8c\ufe0f Defining Styled Items",id:"\ufe0f-defining-styled-items",level:3},{value:"\ud83d\ude80 Applying Styles to Items",id:"-applying-styles-to-items",level:3},{value:"\ud83e\udde9 Adding some UI (optional but recommended)",id:"-adding-some-ui-optional-but-recommended",level:3},{value:"\u23f1\ufe0f Measuring the performance (optional)",id:"\ufe0f-measuring-the-performance-optional",level:3},{value:"\ud83c\udf89 Wrap up",id:"-wrap-up",level:3}];function p(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",hr:"hr",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)("div",{style:{position:"relative"},children:[(0,i.jsx)("iframe",{src:"https://thatopen.github.io/engine_components/examples/ClipStyler"}),(0,i.jsx)("button",{class:"full-screen-btn",onClick:()=>window.open("https://thatopen.github.io/engine_components/examples/ClipStyler"),children:"Go Full Screen"})]}),"\n",(0,i.jsx)(n.admonition,{title:"Source",type:"info",children:(0,i.jsxs)(n.p,{children:["Copying and pasting? We've got you covered! You can find the full source code of this tutorial ",(0,i.jsx)(n.a,{href:"https://github.com/ThatOpen/engine_components/blob/main/packages/front/src/core/ClipStyler/example.ts",children:"here"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"\ufe0f-fancy-clippings",children:"\u2702\ufe0f Fancy Clippings"}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:"Clipping planes are very common in BIM applications. They are used for floor plans, sections, looking inside a 3D model, etc. But simple clipping planes are not enough: they don't have fills or outlines, which are common in BIM software. That Open Engine can do them, and in this tutorial you'll learn how!"}),"\n",(0,i.jsx)(n.admonition,{title:"Fills and outlines?",type:"tip",children:(0,i.jsx)(n.p,{children:"Traditionally, architects created plans with a certain style. For instance, thick lines with solid fill for cutted walls and structure, thin lines for cutted doors and windows, etc. These same conventions are still common in BIM software."})}),"\n",(0,i.jsx)(n.h3,{id:"-importing-our-libraries",children:"\ud83d\udd96 Importing our Libraries"}),"\n",(0,i.jsx)(n.p,{children:"First things first, let's install all necessary dependencies to make this example work:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'import * as THREE from "three";\nimport { LineMaterial } from "three/examples/jsm/lines/LineMaterial.js";\nimport Stats from "stats.js";\nimport * as OBC from "@thatopen/components";\nimport * as BUI from "@thatopen/ui";\n// You have to import * as OBF from "@thatopen/components-front"\nimport * as OBF from "../..";\n'})}),"\n",(0,i.jsx)(n.h3,{id:"-setting-up-a-simple-scene",children:"\ud83c\udf0e Setting up a Simple Scene"}),"\n",(0,i.jsx)(n.p,{children:"To get started, let's set up a basic ThreeJS scene. This will serve as the foundation for our application and allow us to visualize the 3D models effectively:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const components = new OBC.Components();\n\nconst worlds = components.get(OBC.Worlds);\nconst world = worlds.create<\n  OBC.SimpleScene,\n  OBC.OrthoPerspectiveCamera,\n  OBF.PostproductionRenderer\n>();\n\nworld.scene = new OBC.SimpleScene(components);\nworld.scene.setup();\nworld.scene.three.background = null;\n\nconst container = document.getElementById("container")!;\nworld.renderer = new OBF.PostproductionRenderer(components, container);\nworld.camera = new OBC.OrthoPerspectiveCamera(components);\nawait world.camera.controls.setLookAt(68, 23, -8.5, 21.5, -5.5, 23);\n\ncomponents.init();\n'})}),"\n",(0,i.jsx)(n.h3,{id:"\ufe0f-setting-up-fragments",children:"\ud83d\udee0\ufe0f Setting Up Fragments"}),"\n",(0,i.jsx)(n.p,{children:"Now, let's configure the FragmentsManager. This will allow us to load models effortlessly and start manipulating them with ease:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const githubUrl =\n  "https://thatopen.github.io/engine_fragment/resources/worker.mjs";\nconst fetchedUrl = await fetch(githubUrl);\nconst workerBlob = await fetchedUrl.blob();\nconst workerFile = new File([workerBlob], "worker.mjs", {\n  type: "text/javascript",\n});\nconst workerUrl = URL.createObjectURL(workerFile);\nconst fragments = components.get(OBC.FragmentsManager);\nfragments.init(workerUrl);\n\nworld.camera.controls.addEventListener("rest", () =>\n  fragments.core.update(true),\n);\n\nworld.onCameraChanged.add((camera) => {\n  for (const [, model] of fragments.list) {\n    model.useCamera(camera.three);\n  }\n  fragments.core.update(true);\n  world.renderer?.postproduction.updateCamera();\n});\n\nfragments.list.onItemSet.add(({ value: model }) => {\n  model.useCamera(world.camera.three);\n  world.scene.three.add(model.object);\n  fragments.core.update(true);\n});\n'})}),"\n",(0,i.jsx)(n.h3,{id:"-loading-fragments-models",children:"\ud83d\udcc2 Loading Fragments Models"}),"\n",(0,i.jsx)(n.p,{children:"With the core setup complete, it's time to load a Fragments model into our scene. Fragments are optimized for fast loading and rendering, making them ideal for large-scale 3D models."}),"\n",(0,i.jsx)(n.admonition,{title:"Where can I find Fragment files?",type:"info",children:(0,i.jsx)(n.p,{children:"You can use the sample Fragment files available in our repository for testing. If you have an IFC model you'd like to convert to Fragments, check out the IfcImporter tutorial for detailed instructions."})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const fragPaths = ["https://thatopen.github.io/engine_components/resources/frags/school_arq.frag"];\nawait Promise.all(\n  fragPaths.map(async (path) => {\n    const modelId = path.split("/").pop()?.split(".").shift();\n    if (!modelId) return null;\n    const file = await fetch(path);\n    const buffer = await file.arrayBuffer();\n    return fragments.core.load(buffer, { modelId });\n  }),\n);\n'})}),"\n",(0,i.jsx)(n.h3,{id:"-using-the-clip-styler-component",children:"\u2728 Using The Clip Styler Component"}),"\n",(0,i.jsx)(n.p,{children:"The primary purpose of the Clip Styler component is straightforward: it generates lines and fills based on model sections (defined by ThreeJS planes) and applies colors (and thickness for lines) to them. To get started, simply obtain the component instance and define the styles to be applied."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const clipStyler = components.get(OBF.ClipStyler);\nclipStyler.world = world;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Once the component is configured, you can define styles that will be applied to sections later. Styles consist of a line material and a fill material. Let's create the first style as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'clipStyler.styles.set("Blue", {\n  linesMaterial: new LineMaterial({ color: "black", linewidth: 2 }),\n  fillsMaterial: new THREE.MeshBasicMaterial({\n    color: "lightblue",\n    side: 2,\n  }),\n});\n'})}),"\n",(0,i.jsx)(n.admonition,{title:"ThreeJS LineMaterial",type:"info",children:(0,i.jsxs)(n.p,{children:["As you may have noticed, the ",(0,i.jsx)(n.code,{children:"LineMaterial"})," uses a special type of class from ThreeJS. This class allows you to define thickness for lines, which is very convenient when styling sections."]})}),"\n",(0,i.jsx)(n.p,{children:"Cool! The same as before, we can create other styles:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'clipStyler.styles.set("Red", {\n  linesMaterial: new LineMaterial({ color: "black", linewidth: 3 }),\n  fillsMaterial: new THREE.MeshBasicMaterial({\n    color: "salmon",\n    side: 2,\n  }),\n});\n\nclipStyler.styles.set("Green", {\n  linesMaterial: new LineMaterial({ color: "black", linewidth: 2 }),\n  fillsMaterial: new THREE.MeshBasicMaterial({\n    color: "lightgreen",\n    side: 2,\n  }),\n});\n\nclipStyler.styles.set("Black", {\n  linesMaterial: new LineMaterial({ color: "black", linewidth: 2 }),\n  fillsMaterial: new THREE.MeshBasicMaterial({\n    color: "black",\n    side: 2,\n  }),\n});\n\n// You don\'t need to define both line and fill materials.\n// In this case, a style has been created with only the fill material.\n// This means that when this style is applied to a section,\n// only the fill will be visible, and no lines will be generated.\nclipStyler.styles.set("BlackFill", {\n  fillsMaterial: new THREE.MeshBasicMaterial({\n    color: "black",\n    side: 2,\n  }),\n});\n'})}),"\n",(0,i.jsx)(n.p,{children:"Now that we have defined all the styles we need, the next step is to specify which elements will have these styles applied."}),"\n",(0,i.jsx)(n.h3,{id:"\ufe0f-defining-styled-items",children:"\ud83d\udd8c\ufe0f Defining Styled Items"}),"\n",(0,i.jsx)(n.p,{children:"Styles by themselves do nothing unless you specify which elements they should be applied to. The Clip Styler component expects groups from the Classifier, so let's create some dynamic groupings to use during styling:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const finder = components.get(OBC.ItemsFinder);\nfinder.create("Walls", [{ categories: [/WALL/] }]);\nfinder.create("Slabs", [{ categories: [/SLAB/] }]);\nfinder.create("Columns", [{ categories: [/COLUMN/] }]);\nfinder.create("Doors", [{ categories: [/DOOR/] }]);\nfinder.create("Curtains", [{ categories: [/PLATE/, /MEMBER/] }]);\nfinder.create("Windows", [{ categories: [/WINDOW/] }]);\n\n// Now, define the dynamic groupings using the finder queries.\nconst classifier = components.get(OBC.Classifier);\nconst classificationName = "ClipperGroups";\nclassifier.setGroupQuery(classificationName, "Walls", { name: "Walls" });\nclassifier.setGroupQuery(classificationName, "Slabs", { name: "Slabs" });\nclassifier.setGroupQuery(classificationName, "Columns", { name: "Columns" });\nclassifier.setGroupQuery(classificationName, "Doors", { name: "Doors" });\nclassifier.setGroupQuery(classificationName, "Curtains", { name: "Curtains" });\nclassifier.setGroupQuery(classificationName, "Windows", { name: "Windows" });\n'})}),"\n",(0,i.jsx)(n.admonition,{title:"Dynamic Groupings?",type:"info",children:(0,i.jsx)(n.p,{children:"If you found the previous code snippet about the ItemsFinder and the Classifier confusing, please refer to the Classifier tutorial for more details on its implementation."})}),"\n",(0,i.jsx)(n.h3,{id:"-applying-styles-to-items",children:"\ud83d\ude80 Applying Styles to Items"}),"\n",(0,i.jsx)(n.p,{children:"Now that everything is set up, we can start specifying which styles the ClipStyler component should apply to which elements. The only thing left is to tell the ClipStyler which ThreeJS plane to use for creating the model section. You can use arbitrary ThreeJS planes or any plane created by other components in the engine. For convenience, the ClipStyler provides methods to utilize and link planes created by other components! Let's begin by applying a fill to the planes created by the clipper:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const casters = components.get(OBC.Raycasters);\ncasters.get(world);\n\n// Get an instance of the Clipper component\n// and set it enabled by default\n// so clippings can be made\nconst clipper = components.get(OBC.Clipper);\nclipper.enabled = true;\n\n// Set the creation/deletion events\ncontainer.ondblclick = () => {\n  if (clipper.enabled) clipper.create(world);\n};\n\nwindow.onkeydown = (event) => {\n  if (event.code === "Delete" || event.code === "Backspace") {\n    if (clipper.enabled) clipper.delete(world);\n  }\n};\n'})}),"\n",(0,i.jsx)(n.p,{children:"Now that the clipper is configured, we want to ensure that whenever a new clipping plane is created, the clipped items are styled using specific styles defined in the ClipStyler. To achieve this, we can proceed as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'clipper.list.onItemSet.add(({ key }) => {\n  // As you see, there is an special method to link\n  // clipping planes with the ClipStyler.\n  clipStyler.createFromClipping(key, {\n    items: { All: { style: "BlackFill" } },\n  });\n});\n'})}),"\n",(0,i.jsx)(n.p,{children:"Then, for demo purposes, let's create a default clipping plane:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"clipper.createFromNormalAndCoplanarPoint(\n  world,\n  new THREE.Vector3(0, -1, 0),\n  new THREE.Vector3(0, 3, 0),\n);\n"})}),"\n",(0,i.jsx)(n.p,{children:"Styling with clipping planes is great, but the implementation truly shines when applied to 2D views, as they also utilize ThreeJS planes to achieve the desired effect. Let's create a simple view:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const views = components.get(OBC.Views);\n\nconst sectionView = views.createFromPlane(\n  new THREE.Plane(new THREE.Vector3(-1, 0, 0), 35),\n  { id: "Section", world },\n);\n\nsectionView.range = 5;\nsectionView.helpersVisible = true;\n'})}),"\n",(0,i.jsx)(n.admonition,{title:"Views",type:"info",children:(0,i.jsx)(n.p,{children:"If the previous code snippet about views was unclear, please refer to the Views tutorial for more detailed explanations."})}),"\n",(0,i.jsx)(n.p,{children:"Once the view is ready, the ClipStyler component provides a built-in method to link the view and apply styles. This process is straightforward:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'clipStyler.createFromView(sectionView, {\n  // Use the dynamic groups to set the elements style in the plane ----\n  items: {\n    ArchElements: {\n      style: "Blue",\n      data: { [classificationName]: ["Walls", "Slabs", "Curtains", "Windows"] },\n    },\n  },\n});\n'})}),"\n",(0,i.jsx)(n.p,{children:"As you can see, we have applied the Blue style to the specified elements from the classification we defined earlier. Now, let's proceed with another view example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const [planView] = await views.createFromIfcStoreys({\n  storeyNames: [/03/],\n  world,\n  offset: 1,\n});\n\nplanView.helpersVisible = true;\n\nconst planEdges = clipStyler.createFromView(planView, {\n  // Use the dynamic groups to set the elements style in the plane ----\n  items: {\n    Walls: {\n      style: "Blue",\n      data: { [classificationName]: ["Walls"] },\n    },\n    Columns: {\n      style: "Red",\n      data: { [classificationName]: ["Columns"] },\n    },\n    Doors: {\n      style: "Green",\n      data: { [classificationName]: ["Doors"] },\n    },\n  },\n});\n\n// You can also define the styled items in the view after the creation\n// It will update everything automatically\nplanEdges.items.set("Curtains & Windows", {\n  style: "Black",\n  data: { [classificationName]: ["Curtains", "Windows"] },\n});\n\n// This is just for demo purposes in the tutorial\nconst manageVisibility = () => {\n  for (const [, clippingPlane] of clipper.list) {\n    clippingPlane.enabled = !views.hasOpenViews;\n    clippingPlane.visible = !views.hasOpenViews;\n  }\n\n  for (const [, view] of views.list) {\n    view.helpersVisible = !views.hasOpenViews;\n  }\n};\n\nplanView.onStateChanged.add(manageVisibility);\nsectionView.onStateChanged.add(manageVisibility);\n'})}),"\n",(0,i.jsx)(n.h3,{id:"-adding-some-ui-optional-but-recommended",children:"\ud83e\udde9 Adding some UI (optional but recommended)"}),"\n",(0,i.jsxs)(n.p,{children:["We will use the ",(0,i.jsx)(n.code,{children:"@thatopen/ui"})," library to add some simple and cool UI elements to our app. First, we need to call the ",(0,i.jsx)(n.code,{children:"init"})," method of the ",(0,i.jsx)(n.code,{children:"BUI.Manager"})," class to initialize the library:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"BUI.Manager.init();\n"})}),"\n",(0,i.jsx)(n.p,{children:"Now we will add some UI to play around with the actions in this tutorial. For more information about the UI library, you can check the specific documentation for it!"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'type ViewsTableData = {\n  Name: string;\n  Actions: string;\n};\n\ninterface ViewsListState {\n  components: OBC.Components;\n}\n\nconst viewsListTemplate: BUI.StatefullComponent<ViewsListState> = (state) => {\n  const { components } = state;\n  const views = components.get(OBC.Views);\n\n  const onCreated = (e?: Element) => {\n    if (!e) return;\n    const table = e as BUI.Table<ViewsTableData>;\n    table.data = [...views.list.keys()].map((key) => {\n      return {\n        data: {\n          Name: key,\n          Actions: "",\n        },\n      };\n    });\n  };\n\n  return BUI.html`<bim-table ${BUI.ref(onCreated)}></bim-table>`;\n};\n\nconst [viewsList] = BUI.Component.create<\n  BUI.Table<ViewsTableData>,\n  ViewsListState\n>(viewsListTemplate, { components });\n\nviewsList.headersHidden = true;\nviewsList.noIndentation = true;\nviewsList.columns = ["Name", { name: "Actions", width: "auto" }];\n\nviewsList.dataTransform = {\n  Actions: (_, rowData) => {\n    const { Name } = rowData;\n    if (!Name) return _;\n    const views = components.get(OBC.Views);\n    const view = views.list.get(Name);\n    if (!view) return _;\n\n    const onOpen = () => {\n      views.open(Name);\n    };\n\n    const onClose = () => {\n      views.close(Name);\n    };\n\n    return BUI.html`\n      <bim-button label-hidden icon="solar:cursor-bold" label="Open" @click=${onOpen}></bim-button>\n      <bim-button label-hidden icon="material-symbols:close" label="Close" @click=${onClose}></bim-button>\n    `;\n  },\n};\n\ntype StylesTableData = {\n  Name: string;\n  LineWidth: number;\n  LineColor: string;\n  FillColor: string;\n};\n\nconst stylesTable = BUI.Component.create(() => {\n  const onCreated = (_table?: Element) => {\n    if (!(_table instanceof BUI.Table)) return;\n    const table = _table as BUI.Table<StylesTableData>;\n    table.dataTransform = {\n      LineWidth: (value, rowData) => {\n        const name = rowData.Name!;\n        const style = clipStyler.styles.get(name);\n        if (!style) return value;\n        const { linesMaterial } = style;\n        if (!linesMaterial) return value;\n        const onChange = ({ target }: { target: BUI.NumberInput }) => {\n          linesMaterial.linewidth = target.value;\n        };\n        return BUI.html`\n          <bim-number-input .value=${value} min=0.5 max=10 slider step=0.05 @change=${onChange}></bim-number-input>\n        `;\n      },\n      LineColor: (value, rowData) => {\n        const name = rowData.Name!;\n        const style = clipStyler.styles.get(name);\n        if (!style) return value;\n        const { linesMaterial } = style;\n        if (!linesMaterial) return value;\n        const onChange = ({ target }: { target: BUI.ColorInput }) => {\n          linesMaterial.color = new THREE.Color(target.color);\n        };\n        return BUI.html`\n          <bim-color-input .color=${value} @input=${onChange}></bim-color-input>\n        `;\n      },\n      FillColor: (value, rowData) => {\n        const name = rowData.Name!;\n        const style = clipStyler.styles.get(name);\n        if (!style) return value;\n        const { fillsMaterial } = style;\n        if (!fillsMaterial) return value;\n        const onChange = ({ target }: { target: BUI.ColorInput }) => {\n          if (\n            !(\n              "color" in fillsMaterial &&\n              fillsMaterial.color instanceof THREE.Color\n            )\n          ) {\n            return;\n          }\n          fillsMaterial.color = new THREE.Color(target.color);\n        };\n        return BUI.html`\n          <bim-color-input .color=${value} @input=${onChange}></bim-color-input>\n        `;\n      },\n    };\n\n    table.data = Array.from(clipStyler.styles.entries()).map(\n      ([name, style]) => {\n        const linesMaterial = style.linesMaterial as LineMaterial | undefined;\n        const fillsMaterial = style.fillsMaterial as\n          | THREE.MeshBasicMaterial\n          | undefined;\n\n        const row: BUI.TableGroupData<StylesTableData> = {\n          data: { Name: name },\n        };\n\n        if (linesMaterial) {\n          row.data.LineWidth = linesMaterial.linewidth;\n          row.data.LineColor = `#${linesMaterial.color.getHexString()}`;\n        }\n\n        if (fillsMaterial) {\n          row.data.FillColor = `#${fillsMaterial.color.getHexString()}`;\n        }\n\n        return row;\n      },\n    );\n  };\n\n  return BUI.html`<bim-table no-indentation ${BUI.ref(onCreated)}></bim-table>`;\n});\n\nconst panel = BUI.Component.create<BUI.PanelSection>(() => {\n  return BUI.html`\n    <bim-panel active label="Clip Styler Tutorial" class="options-menu">\n      <bim-panel-section label="Styles">\n        <bim-label style="white-space: normal;">Here you can manage the clipping styles of your app. Try to change some of these while a view is open to see the effect.</bim-label>\n        ${stylesTable}\n      </bim-panel-section>\n      <bim-panel-section label="Views">\n        <bim-label style="white-space: normal;">These are the views created in the project. They are linked to the clipping styles.</bim-label>\n        ${viewsList}\n      </bim-panel-section>\n    </bim-panel>\n  `;\n});\n\ndocument.body.append(panel);\n'})}),"\n",(0,i.jsx)(n.p,{children:"And we will make some logic that adds a button to the screen when the user is visiting our app from their phone, allowing to show or hide the menu. Otherwise, the menu would make the app unusable."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const button = BUI.Component.create<BUI.PanelSection>(() => {\n  return BUI.html`\n      <bim-button class="phone-menu-toggler" icon="solar:settings-bold"\n        @click="${() => {\n          if (panel.classList.contains("options-menu-visible")) {\n            panel.classList.remove("options-menu-visible");\n          } else {\n            panel.classList.add("options-menu-visible");\n          }\n        }}">\n      </bim-button>\n    `;\n});\n\ndocument.body.append(button);\n'})}),"\n",(0,i.jsx)(n.h3,{id:"\ufe0f-measuring-the-performance-optional",children:"\u23f1\ufe0f Measuring the performance (optional)"}),"\n",(0,i.jsxs)(n.p,{children:["We'll use the ",(0,i.jsx)(n.a,{href:"https://github.com/mrdoob/stats.js",children:"Stats.js"})," to measure the performance of our app. We will add it to the top left corner of the viewport. This way, we'll make sure that the memory consumption and the FPS of our app are under control."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const stats = new Stats();\nstats.showPanel(2);\ndocument.body.append(stats.dom);\nstats.dom.style.left = "0px";\nstats.dom.style.zIndex = "unset";\nworld.renderer.onBeforeUpdate.add(() => stats.begin());\nworld.renderer.onAfterUpdate.add(() => stats.end());\n'})}),"\n",(0,i.jsx)(n.h3,{id:"-wrap-up",children:"\ud83c\udf89 Wrap up"}),"\n",(0,i.jsx)(n.p,{children:"That's it! Now you're able to create and style clipping planes, views, and dynamically update styles in your BIM application using That Open Engine. Congratulations! Keep exploring more tutorials in the documentation to enhance your skills further."})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var i=t(6540);const s={},l=i.createContext(s);function a(e){const n=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);