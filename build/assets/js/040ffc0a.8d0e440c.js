"use strict";(self.webpackChunkengine_docs=self.webpackChunkengine_docs||[]).push([[3281],{8868:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>r,metadata:()=>i,toc:()=>c});var s=t(4848),o=t(8453);const r={},a=void 0,i={id:"Tutorials/Fragments/Fragments/FragmentsModels/Raycasting",title:"Raycasting",description:'window.open("https://thatopen.github.io/engine_fragment/examples/FragmentsModels/Raycasting")} >Go Full Screen',source:"@site/docs/Tutorials/Fragments/Fragments/FragmentsModels/Raycasting.mdx",sourceDirName:"Tutorials/Fragments/Fragments/FragmentsModels",slug:"/Tutorials/Fragments/Fragments/FragmentsModels/Raycasting",permalink:"/Tutorials/Fragments/Fragments/FragmentsModels/Raycasting",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"ModelInformation",permalink:"/Tutorials/Fragments/Fragments/FragmentsModels/ModelInformation"},next:{title:"Rebars",permalink:"/Tutorials/Fragments/Fragments/FragmentsModels/Rebars"}},l={},c=[{value:"Raycasting Your Fragment Models \ud83e\udd0f",id:"raycasting-your-fragment-models-",level:2},{value:"\ud83d\udd96 Importing our Libraries",id:"-importing-our-libraries",level:3},{value:"\ud83c\udf0e Setting up a Simple Scene",id:"-setting-up-a-simple-scene",level:3},{value:"\ud83d\udee0\ufe0f Setting Up Fragments",id:"\ufe0f-setting-up-fragments",level:3},{value:"\ud83d\udcc2 Loading a Fragments Model",id:"-loading-a-fragments-model",level:3},{value:"\ud83e\udd0f Setting Up Raycaster",id:"-setting-up-raycaster",level:3},{value:"\ud83e\udde9 Adding User Interface (optional)",id:"-adding-user-interface-optional",level:3},{value:"\u23f1\ufe0f Measuring the performance (optional)",id:"\ufe0f-measuring-the-performance-optional",level:3},{value:"\ud83c\udf89 Congratulations!",id:"-congratulations",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",hr:"hr",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)("div",{style:{position:"relative"},children:[(0,s.jsx)("iframe",{src:"https://thatopen.github.io/engine_fragment/examples/FragmentsModels/Raycasting"}),(0,s.jsx)("button",{class:"full-screen-btn",onClick:()=>window.open("https://thatopen.github.io/engine_fragment/examples/FragmentsModels/Raycasting"),children:"Go Full Screen"})]}),"\n",(0,s.jsx)(n.admonition,{title:"Source",type:"info",children:(0,s.jsxs)(n.p,{children:["Copying and pasting? We've got you covered! You can find the full source code of this tutorial ",(0,s.jsx)(n.a,{href:"https://github.com/ThatOpen/engine_fragment/blob/main/packages/fragments/src/FragmentsModels/examples/Raycasting/example.ts",children:"here"}),"."]})}),"\n",(0,s.jsx)(n.h2,{id:"raycasting-your-fragment-models-",children:"Raycasting Your Fragment Models \ud83e\udd0f"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"Determining what lies beneath the mouse pointer is one of the most essential operations in any 3D application. Working with Fragments is no exception, and we provide you with convenient tools to achieve this. Let\u2019s dive in!"}),"\n",(0,s.jsx)(n.h3,{id:"-importing-our-libraries",children:"\ud83d\udd96 Importing our Libraries"}),"\n",(0,s.jsx)(n.p,{children:"First things first, let's install all necessary dependencies to make this example work:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'import * as THREE from "three";\nimport * as OBC from "@thatopen/components";\nimport * as BUI from "@thatopen/ui";\nimport Stats from "stats.js";\n// You have to import * as FRAGS from "@thatopen/fragments"\nimport * as FRAGS from "../../..";\n'})}),"\n",(0,s.jsx)(n.h3,{id:"-setting-up-a-simple-scene",children:"\ud83c\udf0e Setting up a Simple Scene"}),"\n",(0,s.jsx)(n.p,{children:"To get started, let's set up a basic ThreeJS scene. This will serve as the foundation for our application and allow us to visualize the 3D models effectively:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const components = new OBC.Components();\n\nconst worlds = components.get(OBC.Worlds);\nconst world = worlds.create<\n  OBC.SimpleScene,\n  OBC.SimpleCamera,\n  OBC.SimpleRenderer\n>();\n\nworld.scene = new OBC.SimpleScene(components);\nworld.scene.setup();\nworld.scene.three.background = null;\n\nconst container = document.getElementById("container")!;\nworld.renderer = new OBC.SimpleRenderer(components, container);\n\nworld.camera = new OBC.SimpleCamera(components);\nworld.camera.controls.setLookAt(58, 22, -25, 13, 0, 4.2); // convenient position for the model we will load\n\ncomponents.init();\n\nconst grids = components.get(OBC.Grids);\ngrids.create(world);\n'})}),"\n",(0,s.jsx)(n.admonition,{title:"Do I need @thatopen/components?",type:"info",children:(0,s.jsx)(n.p,{children:"Not necessarily! While @thatopen/components simplifies the process of setting up a scene, you can always use plain ThreeJS to create your own custom scene setup. It's entirely up to your preference and project requirements! \ud83d\ude09"})}),"\n",(0,s.jsx)(n.h3,{id:"\ufe0f-setting-up-fragments",children:"\ud83d\udee0\ufe0f Setting Up Fragments"}),"\n",(0,s.jsx)(n.p,{children:"Now, let's configure the Fragments library core. This will allow us to load models effortlessly and start manipulating them with ease:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'// You have to copy `/node_modules/@thatopen/fragments/dist/Worker/worker.mjs` to your project directory\n// and provide the relative path in `workerUrl`\n// We use here the internal route of the worker in the library for simplicity purposes\nconst workerUrl = "https://thatopen.github.io/engine_fragment/resources/worker.mjs";\nconst fragments = new FRAGS.FragmentsModels(workerUrl);\nworld.camera.controls.addEventListener("rest", () => fragments.update(true));\n\n// Once a model is available in the list, we can tell what camera to use\n// in order to perform the culling and LOD operations.\n// Also, we add the model to the 3D scene.\nfragments.models.list.onItemSet.add(({ value: model }) => {\n  model.useCamera(world.camera.three);\n  world.scene.three.add(model.object);\n  // At the end, you tell fragments to update so the model can be seen given\n  // the initial camera position\n  fragments.update(true);\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"-loading-a-fragments-model",children:"\ud83d\udcc2 Loading a Fragments Model"}),"\n",(0,s.jsx)(n.p,{children:"With the core setup complete, it's time to load a Fragments model into our scene. Fragments are optimized for fast loading and rendering, making them ideal for large-scale 3D models."}),"\n",(0,s.jsx)(n.admonition,{title:"Where can I find Fragment files?",type:"info",children:(0,s.jsx)(n.p,{children:"You can use the sample Fragment files available in our repository for testing. If you have an IFC model you'd like to convert to Fragments, check out the IfcImporter tutorial for detailed instructions."})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const file = await fetch("https://thatopen.github.io/engine_fragment/resources/frags/school_arq.frag");\nconst buffer = await file.arrayBuffer();\nconst model = await fragments.load(buffer, { modelId: "example" });\n'})}),"\n",(0,s.jsx)(n.h3,{id:"-setting-up-raycaster",children:"\ud83e\udd0f Setting Up Raycaster"}),"\n",(0,s.jsx)(n.p,{children:"Each Fragments Model comes with built-in methods to retrieve information about what lies beneath the mouse pointer (raycasting). To make this process more versatile, let's create a utility function that performs raycasting across all models loaded in the scene and returns the closest result:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const raycast = async (data: {\n  camera: THREE.PerspectiveCamera | THREE.OrthographicCamera;\n  mouse: THREE.Vector2;\n  dom: HTMLCanvasElement;\n}) => {\n  const results = [];\n  for (const [_, model] of fragments.models.list) {\n    const result = await model.raycast(data);\n    if (result) {\n      results.push(result);\n    }\n  }\n  await Promise.all(results);\n  if (results.length === 0) return null;\n\n  // Find result with smallest distance\n  let closestResult = results[0];\n  let minDistance = closestResult.distance;\n\n  for (let i = 1; i < results.length; i++) {\n    if (results[i].distance < minDistance) {\n      minDistance = results[i].distance;\n      closestResult = results[i];\n    }\n  }\n\n  return closestResult;\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"Now, that is just the helper function and we can use it however we like. For demonstration purposes, let's enhance the raycasting functionality to provide more interactivity and feedback to the user. Let's start by defining the pointer move event:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const mouse = new THREE.Vector2();\n\nlet onRaycastHoverResult = (_result: FRAGS.RaycastResult | null) => {};\ncontainer.addEventListener("pointermove", async (event) => {\n  mouse.x = event.clientX;\n  mouse.y = event.clientY;\n  const result = await raycast({\n    camera: world.camera.three,\n    mouse,\n    dom: world.renderer!.three.domElement!,\n  });\n  onRaycastHoverResult(result);\n});\n'})}),"\n",(0,s.jsx)(n.admonition,{title:"Performance Tip!",type:"info",children:(0,s.jsx)(n.p,{children:"Continuously raycasting on every pointer move might seem like the obvious choice, but it can introduce performance bottlenecks. This is because each raycast request is sent to a worker, and there is a small delay for the data to return. A more efficient approach is to trigger raycasting only after the pointer has stopped moving for a short duration."})}),"\n",(0,s.jsx)(n.p,{children:"To provide visual feedback, we'll draw a ThreeJS line at the hit position. This line will orient itself to align with the surface normal at the hit point. Additionally, we'll log the raycast result to the console for further inspection:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const lineGeometry = new THREE.BufferGeometry().setFromPoints([\n  new THREE.Vector3(0, 0, 0),\n  new THREE.Vector3(0, 0, 2),\n]);\n\nconst lineMaterial = new THREE.LineBasicMaterial({ color: "#6528d7" });\nconst line = new THREE.Line(lineGeometry, lineMaterial);\nworld.scene.three.add(line);\n\nonRaycastHoverResult = (result) => {\n  line.visible = !!result;\n  if (!result) return;\n  console.log(result);\n  const { point, normal } = result;\n  if (!normal) return;\n  line.position.copy(point);\n  const look = point.clone().add(normal);\n  line.lookAt(look);\n};\n'})}),"\n",(0,s.jsx)(n.p,{children:"Let's enhance the interactivity by creating a sphere at the location where the user clicks. This will provide a visual cue for the click position:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'let onRaycastClickResult = (_result: FRAGS.RaycastResult | null) => {};\ncontainer.addEventListener("click", async (event) => {\n  mouse.x = event.clientX;\n  mouse.y = event.clientY;\n  const result = await model.raycast({\n    camera: world.camera.three,\n    mouse,\n    dom: world.renderer!.three.domElement!,\n  });\n  onRaycastClickResult(result);\n});\n\nconst sphereGeometry = new THREE.SphereGeometry(0.4);\n\nconst sphereMaterial = new THREE.MeshLambertMaterial({\n  color: "#bcf124",\n  transparent: true,\n  opacity: 0.8,\n});\n\nonRaycastClickResult = (result) => {\n  if (!result) return;\n  const { point } = result;\n  const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);\n  sphere.position.copy(point);\n  world.scene.three.add(sphere);\n};\n'})}),"\n",(0,s.jsx)(n.admonition,{title:"What's Next?",type:"info",children:(0,s.jsx)(n.p,{children:"Curious about how to leverage the raycast results for advanced operations like data retrieval or material changing? Check out the other Fragments tutorials for more in-depth examples and use cases."})}),"\n",(0,s.jsx)(n.h3,{id:"-adding-user-interface-optional",children:"\ud83e\udde9 Adding User Interface (optional)"}),"\n",(0,s.jsxs)(n.p,{children:["We will use the ",(0,s.jsx)(n.code,{children:"@thatopen/ui"})," library to add some simple and cool UI elements to our app. First, we need to call the ",(0,s.jsx)(n.code,{children:"init"})," method of the ",(0,s.jsx)(n.code,{children:"BUI.Manager"})," class to initialize the library:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"BUI.Manager.init();\n"})}),"\n",(0,s.jsx)(n.p,{children:"Now we will add some UI to handle the logic of this tutorial. For more information about the UI library, you can check the specific documentation for it!"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const panel = BUI.Component.create<BUI.PanelSection>(() => {\n  return BUI.html`\n    <bim-panel id="controls-panel" active label="Raycasting" class="options-menu">\n      <bim-panel-section fixed label="Info">\n        <bim-label style="white-space: normal;">\ud83d\udca1 To better experience this tutorial, open your browser console to see the data logs.</bim-label>\n      </bim-panel-section>\n    </bim-panel>\n  `;\n});\n\ndocument.body.append(panel);\n'})}),"\n",(0,s.jsx)(n.p,{children:"And we will make some logic that adds a button to the screen when the user is visiting our app from their phone, allowing to show or hide the menu. Otherwise, the menu would make the app unusable."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const button = BUI.Component.create<BUI.PanelSection>(() => {\n  const onClick = () => {\n    if (panel.classList.contains("options-menu-visible")) {\n      panel.classList.remove("options-menu-visible");\n    } else {\n      panel.classList.add("options-menu-visible");\n    }\n  };\n\n  return BUI.html`\n    <bim-button class="phone-menu-toggler" icon="solar:settings-bold"\n      @click=${onClick}>\n    </bim-button>\n  `;\n});\n\ndocument.body.append(button);\n'})}),"\n",(0,s.jsx)(n.h3,{id:"\ufe0f-measuring-the-performance-optional",children:"\u23f1\ufe0f Measuring the performance (optional)"}),"\n",(0,s.jsxs)(n.p,{children:["We'll use the ",(0,s.jsx)(n.a,{href:"https://github.com/mrdoob/stats.js",children:"Stats.js"})," to measure the performance of our app. We will add it to the top left corner of the viewport. This way, we'll make sure that the memory consumption and the FPS of our app are under control."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const stats = new Stats();\nstats.showPanel(2);\ndocument.body.append(stats.dom);\nstats.dom.style.left = "0px";\nstats.dom.style.zIndex = "unset";\nworld.renderer.onBeforeUpdate.add(() => stats.begin());\nworld.renderer.onAfterUpdate.add(() => stats.end());\n'})}),"\n",(0,s.jsx)(n.h3,{id:"-congratulations",children:"\ud83c\udf89 Congratulations!"}),"\n",(0,s.jsx)(n.p,{children:"You've successfully implemented raycasting in your 3D scene! \ud83d\ude80\nNow you can identify objects beneath your mouse pointer and interact with them dynamically.\nReady to explore more? Check out our other tutorials to unlock the full potential of Fragments! \ud83d\udca1"})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var s=t(6540);const o={},r=s.createContext(o);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);