"use strict";(self.webpackChunkengine_docs=self.webpackChunkengine_docs||[]).push([[1175],{3174:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>i,metadata:()=>a,toc:()=>d});var t=o(4848),r=o(8453);const i={},s=void 0,a={id:"Tutorials/Components/Core/BoundingBoxer",title:"BoundingBoxer",description:'window.open("https://thatopen.github.io/engine_components/examples/BoundingBoxer")} >Go Full Screen',source:"@site/docs/Tutorials/Components/Core/BoundingBoxer.mdx",sourceDirName:"Tutorials/Components/Core",slug:"/Tutorials/Components/Core/BoundingBoxer",permalink:"/Tutorials/Components/Core/BoundingBoxer",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"BCFTopics",permalink:"/Tutorials/Components/Core/BCFTopics"},next:{title:"Classifier",permalink:"/Tutorials/Components/Core/Classifier"}},l={},d=[{value:"\ud83d\udcc4 Playing with Boxes",id:"-playing-with-boxes",level:2},{value:"\ud83d\udd96 Importing our Libraries",id:"-importing-our-libraries",level:3},{value:"\ud83c\udf0e Setting up a Simple Scene",id:"-setting-up-a-simple-scene",level:3},{value:"\ud83d\udee0\ufe0f Setting Up Fragments",id:"\ufe0f-setting-up-fragments",level:3},{value:"\ud83d\udcc2 Loading Fragments Models",id:"-loading-fragments-models",level:3},{value:"\u2728 Using The Bounding Boxer Component",id:"-using-the-bounding-boxer-component",level:3},{value:"\ud83d\udee0\ufe0f Other Bounding Boxer Utilities",id:"\ufe0f-other-bounding-boxer-utilities",level:3},{value:"\ud83d\udcd0 Bounding Helpers",id:"-bounding-helpers",level:3},{value:"\ud83e\udde9 Adding some UI (optional but recommended)",id:"-adding-some-ui-optional-but-recommended",level:3},{value:"\u23f1\ufe0f Measuring the performance (optional)",id:"\ufe0f-measuring-the-performance-optional",level:3},{value:"\ud83c\udf89 Wrap up",id:"-wrap-up",level:3}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)("div",{style:{position:"relative"},children:[(0,t.jsx)("iframe",{src:"https://thatopen.github.io/engine_components/examples/BoundingBoxer"}),(0,t.jsx)("button",{class:"full-screen-btn",onClick:()=>window.open("https://thatopen.github.io/engine_components/examples/BoundingBoxer"),children:"Go Full Screen"})]}),"\n",(0,t.jsx)(n.admonition,{title:"Source",type:"info",children:(0,t.jsxs)(n.p,{children:["Copying and pasting? We've got you covered! You can find the full source code of this tutorial ",(0,t.jsx)(n.a,{href:"https://github.com/ThatOpen/engine_components/blob/main/packages/core/src/fragments/BoundingBoxer/example.ts",children:"here"}),"."]})}),"\n",(0,t.jsx)(n.h2,{id:"-playing-with-boxes",children:"\ud83d\udcc4 Playing with Boxes"}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.p,{children:"In this tutorial, you'll learn to easily create the bounding boxes of a Fragments Model. This can be useful for knowing the overall position and dimension of your models, which can be used, for instance, to make the camera fit a whole BIM model in the screen. Let's get started!"}),"\n",(0,t.jsx)(n.admonition,{title:"Bounding boxes?",type:"tip",children:(0,t.jsx)(n.p,{children:"Bounding boxes (AABB or Axis-Aligned Bounding Boxes) are the boxes aligned with the X, Y and Z axes of a 3D model that contain one or many objects. They are very common in 3D applications to make fast computations that require to know the whole dimension or position of one or many objects."})}),"\n",(0,t.jsx)(n.h3,{id:"-importing-our-libraries",children:"\ud83d\udd96 Importing our Libraries"}),"\n",(0,t.jsx)(n.p,{children:"First things first, let's install all necessary dependencies to make this example work:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'import * as THREE from "three";\nimport Stats from "stats.js";\nimport * as BUI from "@thatopen/ui";\n// You have to import * as OBC from "@thatopen/components"\nimport * as OBC from "../..";\n'})}),"\n",(0,t.jsx)(n.h3,{id:"-setting-up-a-simple-scene",children:"\ud83c\udf0e Setting up a Simple Scene"}),"\n",(0,t.jsx)(n.p,{children:"To get started, let's set up a basic ThreeJS scene. This will serve as the foundation for our application and allow us to visualize the 3D models effectively:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'const components = new OBC.Components();\n\nconst worlds = components.get(OBC.Worlds);\nconst world = worlds.create<\n  OBC.SimpleScene,\n  OBC.OrthoPerspectiveCamera,\n  OBC.SimpleRenderer\n>();\n\nworld.scene = new OBC.SimpleScene(components);\nworld.scene.setup();\nworld.scene.three.background = null;\n\nconst container = document.getElementById("container")!;\nworld.renderer = new OBC.SimpleRenderer(components, container);\nworld.camera = new OBC.OrthoPerspectiveCamera(components);\nawait world.camera.controls.setLookAt(78, 20, -2.2, 26, -4, 25);\n\ncomponents.init();\n'})}),"\n",(0,t.jsx)(n.h3,{id:"\ufe0f-setting-up-fragments",children:"\ud83d\udee0\ufe0f Setting Up Fragments"}),"\n",(0,t.jsx)(n.p,{children:"Now, let's configure the FragmentsManager. This will allow us to load models effortlessly and start manipulating them with ease:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'const githubUrl =\n  "https://thatopen.github.io/engine_fragment/resources/worker.mjs";\nconst fetchedUrl = await fetch(githubUrl);\nconst workerBlob = await fetchedUrl.blob();\nconst workerFile = new File([workerBlob], "worker.mjs", {\n  type: "text/javascript",\n});\nconst workerUrl = URL.createObjectURL(workerFile);\nconst fragments = components.get(OBC.FragmentsManager);\nfragments.init(workerUrl);\n\nworld.camera.controls.addEventListener("rest", () =>\n  fragments.core.update(true),\n);\n\nworld.onCameraChanged.add((camera) => {\n  for (const [, model] of fragments.list) {\n    model.useCamera(camera.three);\n  }\n  fragments.core.update(true);\n});\n\nfragments.list.onItemSet.add(({ value: model }) => {\n  model.useCamera(world.camera.three);\n  world.scene.three.add(model.object);\n  fragments.core.update(true);\n});\n'})}),"\n",(0,t.jsx)(n.h3,{id:"-loading-fragments-models",children:"\ud83d\udcc2 Loading Fragments Models"}),"\n",(0,t.jsx)(n.p,{children:"With the core setup complete, it's time to load a Fragments model into our scene. Fragments are optimized for fast loading and rendering, making them ideal for large-scale 3D models."}),"\n",(0,t.jsx)(n.admonition,{title:"Where can I find Fragment files?",type:"info",children:(0,t.jsx)(n.p,{children:"You can use the sample Fragment files available in our repository for testing. If you have an IFC model you'd like to convert to Fragments, check out the IfcImporter tutorial for detailed instructions."})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'const fragPaths = [\n  "https://thatopen.github.io/engine_components/resources/frags/school_arq.frag",\n  "https://thatopen.github.io/engine_components/resources/frags/school_str.frag",\n];\n\nawait Promise.all(\n  fragPaths.map(async (path) => {\n    const modelId = path.split("/").pop()?.split(".").shift();\n    if (!modelId) return null;\n    const file = await fetch(path);\n    const buffer = await file.arrayBuffer();\n    return fragments.core.load(buffer, { modelId });\n  }),\n);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"-using-the-bounding-boxer-component",children:"\u2728 Using The Bounding Boxer Component"}),"\n",(0,t.jsxs)(n.p,{children:["Now that our setup is done, lets see how you can create the bounding boxes of the model. BIM models are complex, but don't worry: creating the ",(0,t.jsx)(n.a,{href:"https://threejs.org/docs/?q=bound#api/en/math/Box3",children:"bounding boxes"})," is a piece of cake thanks to the ",(0,t.jsx)(n.code,{children:"BoundingBoxer"}),". First, get an instance of the component:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const boxer = components.get(OBC.BoundingBoxer);\n"})}),"\n",(0,t.jsx)(n.p,{children:"Next, it's just a matter of adding items, entire models, or previously computed boxes to the component so the merged bounding boxes can be calculated. To keep it simple, let's create a function that retrieves the merged bounding box of all loaded models:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const getLoadedModelsBoundings = () => {\n  // As a good practice, always clean up the boxer list first\n  // so no previous boxes added are taken into account\n  boxer.list.clear();\n  boxer.addFromModels();\n  // This computes the merged box of the list.\n  const box = boxer.get();\n  // As a good practice, always clean up the boxer list after the calculation\n  boxer.list.clear();\n  return box;\n};\n"})}),"\n",(0,t.jsx)(n.p,{children:"While knowing the overall bounding box of the entire context is useful, it is often more practical to determine the bounding box of a specific collection of elements. For instance, this can be used to focus the camera on those elements for a close-up view. Let's dive in and create a function that, given a category, get the elements boundings in the architectural model."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const getByCategory = async (category: string) => {\n  const arqId = [...fragments.list.keys()].find((modelId) =>\n    /arq/.test(modelId),\n  );\n  if (!arqId) return null;\n  const model = fragments.list.get(arqId);\n  if (!model) return null;\n  const items = await model.getItemsOfCategories([new RegExp(`^${category}$`)]);\n  const localIds = Object.values(items).flat();\n\n  // As elements from categories are dispersed around the whole model\n  // the camera fit based on the boundings will be very imperceptible.\n  // For this reason, we will take the first element of the category\n  // so its easier to see the result\n  const effectiveIds = localIds.slice(0, 1);\n\n  // An OBC.ModelIdMap represents selections within the engine.\n  // Here, we are defining a selection for the architectural model\n  // that includes all items belonging to the specified category.\n  const modelIdMap: OBC.ModelIdMap = { [arqId]: new Set(effectiveIds) };\n  boxer.list.clear();\n  await boxer.addFromModelIdMap(modelIdMap);\n  const box = boxer.get();\n  boxer.list.clear();\n  return box;\n};\n"})}),"\n",(0,t.jsx)(n.admonition,{title:"Adding from ModelIdMap",type:"tip",children:(0,t.jsx)(n.p,{children:"Adding bounding boxes from a ModelIdMap (selections in That Open Engine) becomes very powerful when combined with other components, such as the ItemsFinder. Check out the tutorial for that component!"})}),"\n",(0,t.jsx)(n.h3,{id:"\ufe0f-other-bounding-boxer-utilities",children:"\ud83d\udee0\ufe0f Other Bounding Boxer Utilities"}),"\n",(0,t.jsx)(n.p,{children:"Bounding boxes are incredibly versatile and, when used correctly, can be adapted to various workflows. One convenient use case is moving the camera to view the scene from specific angles, such as the bottom, top, left, right, front, or back of the entire viewer context. This operation is commonly combined with a view cube. The bounding boxer includes a built-in method that provides the necessary camera information to set the view perfectly. Here's how you can do it:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'const viewFromOrientation = async (\n  orientation: "front" | "back" | "left" | "right" | "top" | "bottom",\n) => {\n  const camera = world.camera;\n  if (!camera.hasCameraControls()) return;\n  const { position, target } = await boxer.getCameraOrientation(orientation);\n  await camera.controls.setLookAt(\n    position.x,\n    position.y,\n    position.z,\n    target.x,\n    target.y,\n    target.z,\n    true,\n  );\n};\n'})}),"\n",(0,t.jsx)(n.h3,{id:"-bounding-helpers",children:"\ud83d\udcd0 Bounding Helpers"}),"\n",(0,t.jsx)(n.p,{children:"Visualizing the bounding box can often be very helpful. Fortunately, ThreeJS provides a convenient helper for this purpose. Let's create a function to generate a helper for a given bounding box:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"let helpers: THREE.Box3Helper[] = [];\n\nconst createBoxHelper = (box: THREE.Box3) => {\n  const helper = new THREE.Box3Helper(box);\n  world.scene.three.add(helper);\n  helpers.push(helper);\n};\n\nconst disposeHelpers = () => {\n  const disposer = components.get(OBC.Disposer);\n  for (const helper of helpers) {\n    disposer.destroy(helper);\n  }\n  helpers = [];\n};\n"})}),"\n",(0,t.jsx)(n.h3,{id:"-adding-some-ui-optional-but-recommended",children:"\ud83e\udde9 Adding some UI (optional but recommended)"}),"\n",(0,t.jsxs)(n.p,{children:["We will use the ",(0,t.jsx)(n.code,{children:"@thatopen/ui"})," library to add some simple and cool UI elements to our app. First, we need to call the ",(0,t.jsx)(n.code,{children:"init"})," method of the ",(0,t.jsx)(n.code,{children:"BUI.Manager"})," class to initialize the library:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"BUI.Manager.init();\n"})}),"\n",(0,t.jsx)(n.p,{children:"Now we will add some UI to play around with the actions in this tutorial. For more information about the UI library, you can check the specific documentation for it!"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'const panel = BUI.Component.create<BUI.PanelSection>(() => {\n  let categoriesDropdown: BUI.Dropdown | undefined;\n  let orientationsDropdown: BUI.Dropdown | undefined;\n\n  const onFitModels = ({ target }: { target: BUI.Button }) => {\n    target.loading = true;\n    const box = getLoadedModelsBoundings();\n    const sphere = new THREE.Sphere();\n    box.getBoundingSphere(sphere);\n    world.camera.controls.fitToSphere(sphere, true);\n    target.loading = false;\n  };\n\n  const onAddModelsHelper = () => {\n    const box = getLoadedModelsBoundings();\n    createBoxHelper(box);\n  };\n\n  const onAddCategoryHelper = async ({ target }: { target: BUI.Button }) => {\n    if (!categoriesDropdown) return;\n    target.loading = true;\n    const [category] = categoriesDropdown.value;\n    const box = await getByCategory(category);\n    if (!box) {\n      target.loading = false;\n      return;\n    }\n    createBoxHelper(box);\n    target.loading = false;\n  };\n\n  const onCategoriesDropdownCreated = async (e?: Element) => {\n    if (!e) return;\n\n    const arqId = [...fragments.list.keys()].find((modelId) =>\n      /arq/.test(modelId),\n    );\n    if (!arqId) return;\n    const model = fragments.list.get(arqId);\n    if (!model) return;\n\n    const dropdown = e as BUI.Dropdown;\n    categoriesDropdown = dropdown;\n    dropdown.innerHTML = "";\n\n    const modelCategories = await model.getItemsWithGeometryCategories();\n    for (const [index, category] of modelCategories.entries()) {\n      const option = BUI.Component.create(\n        () =>\n          BUI.html`<bim-option ?checked=${index === 0} label=${category}></bim-option>`,\n      );\n      dropdown.append(option);\n    }\n  };\n\n  const onFitCategoryItem = async ({ target }: { target: BUI.Button }) => {\n    if (!categoriesDropdown) return;\n    target.loading = true;\n    const [category] = categoriesDropdown.value;\n    const box = await getByCategory(category);\n    if (!box) {\n      target.loading = false;\n      return;\n    }\n    const sphere = new THREE.Sphere();\n    box.getBoundingSphere(sphere);\n    world.camera.controls.fitToSphere(sphere, true);\n    target.loading = false;\n  };\n\n  const onDisposeHelpers = () => {\n    disposeHelpers();\n  };\n\n  const onOrientationsDropdownCreated = (e?: Element) => {\n    if (!e) return;\n    orientationsDropdown = e as BUI.Dropdown;\n  };\n\n  const onSetOrientation = async ({ target }: { target: BUI.Button }) => {\n    if (!orientationsDropdown) return;\n    target.loading = true;\n    const [orientation] = orientationsDropdown.value;\n    await viewFromOrientation(orientation);\n    target.loading = false;\n  };\n\n  return BUI.html`\n    <bim-panel active label="Bounding Boxer Tutorial" class="options-menu">\n      <bim-panel-section label="General">\n        <bim-label style="width: 15rem; white-space: normal;">Get rid of all helpers created, to prevent memory leaks.</bim-label>\n        <bim-button label="Dispose Helpers" @click=${onDisposeHelpers}></bim-button>\n      </bim-panel-section>\n      <bim-panel-section label="By Models">\n        <bim-button label="Fit Models" @click=${onFitModels}></bim-button>\n        <bim-button label="Add Helper" @click=${onAddModelsHelper}></bim-button>\n      </bim-panel-section>\n      <bim-panel-section label="By Categories">\n        <bim-label style="width: 15rem; white-space: normal;">As elements from categories are dispersed around the whole model, the camera fit will take the first element of the category so its easier to see the result.</bim-label>\n        <bim-dropdown ${BUI.ref(onCategoriesDropdownCreated)} required></bim-dropdown>\n        <bim-button label="Fit Category Item" @click=${onFitCategoryItem}></bim-button>\n        <bim-button label="Add Helper" @click=${onAddCategoryHelper}></bim-button>\n      </bim-panel-section>\n      <bim-panel-section label="Orientation">\n        <bim-label style="width: 15rem; white-space: normal;">Please, be aware there may be some discrepancies between Back, Front, Left and Right because of how the model was created in the authoring software.</bim-label>\n        <bim-dropdown ${BUI.ref(onOrientationsDropdownCreated)} required>\n          <bim-option label="Back" value="back"></bim-option>\n          <bim-option label="Left" value="left"></bim-option>\n          <bim-option label="Right" value="right"></bim-option>\n          <bim-option label="Top" value="top"></bim-option>\n          <bim-option label="Bottom" value="bottom"></bim-option>\n        </bim-dropdown>\n        <bim-button label="Set Camera Orientation" @click=${onSetOrientation}></bim-button>\n      </bim-panel-section>\n    </bim-panel>\n  `;\n});\n\ndocument.body.append(panel);\n'})}),"\n",(0,t.jsx)(n.p,{children:"And we will make some logic that adds a button to the screen when the user is visiting our app from their phone, allowing to show or hide the menu. Otherwise, the menu would make the app unusable."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'const button = BUI.Component.create<BUI.PanelSection>(() => {\n  return BUI.html`\n      <bim-button class="phone-menu-toggler" icon="solar:settings-bold"\n        @click="${() => {\n          if (panel.classList.contains("options-menu-visible")) {\n            panel.classList.remove("options-menu-visible");\n          } else {\n            panel.classList.add("options-menu-visible");\n          }\n        }}">\n      </bim-button>\n    `;\n});\n\ndocument.body.append(button);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"\ufe0f-measuring-the-performance-optional",children:"\u23f1\ufe0f Measuring the performance (optional)"}),"\n",(0,t.jsxs)(n.p,{children:["We'll use the ",(0,t.jsx)(n.a,{href:"https://github.com/mrdoob/stats.js",children:"Stats.js"})," to measure the performance of our app. We will add it to the top left corner of the viewport. This way, we'll make sure that the memory consumption and the FPS of our app are under control."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'const stats = new Stats();\nstats.showPanel(2);\ndocument.body.append(stats.dom);\nstats.dom.style.left = "0px";\nstats.dom.style.zIndex = "unset";\nworld.renderer.onBeforeUpdate.add(() => stats.begin());\nworld.renderer.onAfterUpdate.add(() => stats.end());\n'})}),"\n",(0,t.jsx)(n.h3,{id:"-wrap-up",children:"\ud83c\udf89 Wrap up"}),"\n",(0,t.jsx)(n.p,{children:"That's it! Now you're able to:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Compute and visualize bounding boxes for entire models or specific selections."}),"\n",(0,t.jsx)(n.li,{children:"Use bounding boxes to adjust camera views dynamically.\nCongratulations! Keep going with more tutorials in the documentation."}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>s,x:()=>a});var t=o(6540);const r={},i=t.createContext(r);function s(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);