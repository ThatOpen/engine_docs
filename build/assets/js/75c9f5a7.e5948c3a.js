"use strict";(self.webpackChunkengine_docs=self.webpackChunkengine_docs||[]).push([[5384],{8720:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var o=t(4848),i=t(8453);const s={},a=void 0,r={id:"Tutorials/Components/Core/Viewpoints",title:"Viewpoints",description:'window.open("https://thatopen.github.io/engine_components/examples/Viewpoints")} >Go Full Screen',source:"@site/docs/Tutorials/Components/Core/Viewpoints.mdx",sourceDirName:"Tutorials/Components/Core",slug:"/Tutorials/Components/Core/Viewpoints",permalink:"/Tutorials/Components/Core/Viewpoints",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"ShadowedScene",permalink:"/Tutorials/Components/Core/ShadowedScene"},next:{title:"Views",permalink:"/Tutorials/Components/Core/Views"}},l={},c=[{value:"\ud83d\udcc4 Storing View Information",id:"-storing-view-information",level:2},{value:"\ud83c\udf0e Setting up a Simple Scene",id:"-setting-up-a-simple-scene",level:3},{value:"\ud83d\udee0\ufe0f Setting Up Fragments",id:"\ufe0f-setting-up-fragments",level:3},{value:"\ud83d\udcc2 Loading Fragments Models",id:"-loading-fragments-models",level:3},{value:"\u2728 Using The Viewpoints Component",id:"-using-the-viewpoints-component",level:3},{value:"\ud83e\uddf1 Adding and Retrieving Model Elements",id:"-adding-and-retrieving-model-elements",level:3},{value:"\ud83d\udd17 Linking Viewpoints to Topics",id:"-linking-viewpoints-to-topics",level:3},{value:"\ud83e\udde9 Adding some UI (optional but recommended)",id:"-adding-some-ui-optional-but-recommended",level:3},{value:"\u23f1\ufe0f Measuring the performance (optional)",id:"\ufe0f-measuring-the-performance-optional",level:3},{value:"\ud83c\udf89 Wrap up",id:"-wrap-up",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",hr:"hr",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)("div",{style:{position:"relative"},children:[(0,o.jsx)("iframe",{src:"https://thatopen.github.io/engine_components/examples/Viewpoints"}),(0,o.jsx)("button",{class:"full-screen-btn",onClick:()=>window.open("https://thatopen.github.io/engine_components/examples/Viewpoints"),children:"Go Full Screen"})]}),"\n",(0,o.jsx)(n.admonition,{title:"Source",type:"info",children:(0,o.jsxs)(n.p,{children:["Copying and pasting? We've got you covered! You can find the full source code of this tutorial ",(0,o.jsx)(n.a,{href:"https://github.com/ThatOpen/engine_components/blob/main/packages/core/src/core/Viewpoints/example.ts",children:"here"}),"."]})}),"\n",(0,o.jsx)(n.h2,{id:"-storing-view-information",children:"\ud83d\udcc4 Storing View Information"}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.p,{children:"Most 3D applications commonly store camera positions for easy retrieval. In BIM apps, it's also useful to store selected and filtered elements. While there isn't a universal standard for this, the BCF schema (used for communication between BIM apps) includes topics and viewpoints."}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsx)(n.p,{children:"Topics store communication details like title, type, status, assignee, and comments. Viewpoints define camera positions, targets, selected elements, and isolations."})}),"\n",(0,o.jsx)(n.p,{children:"The Viewpoints component in That Open Engine extracts BCF viewpoints, enabling you to manage camera positions and related elements effectively. Let's explore how to use it!"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'import * as THREE from "three";\nimport Stats from "stats.js";\nimport * as BUI from "@thatopen/ui";\n// You have to import * as OBC from "@thatopen/components"\nimport * as OBC from "../..";\n'})}),"\n",(0,o.jsx)(n.h3,{id:"-setting-up-a-simple-scene",children:"\ud83c\udf0e Setting up a Simple Scene"}),"\n",(0,o.jsx)(n.p,{children:"To get started, let's set up a basic ThreeJS scene. This will serve as the foundation for our application and allow us to visualize the 3D models effectively:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'const components = new OBC.Components();\n\nconst worlds = components.get(OBC.Worlds);\nconst world = worlds.create<\n  OBC.SimpleScene,\n  OBC.OrthoPerspectiveCamera,\n  OBC.SimpleRenderer\n>();\n\nworld.scene = new OBC.SimpleScene(components);\nworld.scene.setup();\nworld.scene.three.background = null;\n\nconst container = document.getElementById("container")!;\nworld.renderer = new OBC.SimpleRenderer(components, container);\nworld.camera = new OBC.OrthoPerspectiveCamera(components);\nawait world.camera.controls.setLookAt(78, 20, -2.2, 26, -4, 25);\n\ncomponents.init();\n'})}),"\n",(0,o.jsx)(n.h3,{id:"\ufe0f-setting-up-fragments",children:"\ud83d\udee0\ufe0f Setting Up Fragments"}),"\n",(0,o.jsx)(n.p,{children:"Now, let's configure the FragmentsManager. This will allow us to load models effortlessly and start manipulating them with ease:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'const workerUrl =\n  "https://thatopen.github.io/engine_fragment/resources/worker.mjs";\nconst fragments = components.get(OBC.FragmentsManager);\nfragments.init(workerUrl);\n\nworld.camera.controls.addEventListener("rest", () =>\n  fragments.core.update(true),\n);\n\nworld.onCameraChanged.add((camera) => {\n  for (const [, model] of fragments.list) {\n    model.useCamera(camera.three);\n  }\n  fragments.core.update(true);\n});\n\nfragments.list.onItemSet.add(({ value: model }) => {\n  model.useCamera(world.camera.three);\n  world.scene.three.add(model.object);\n  fragments.core.update(true);\n});\n'})}),"\n",(0,o.jsx)(n.h3,{id:"-loading-fragments-models",children:"\ud83d\udcc2 Loading Fragments Models"}),"\n",(0,o.jsx)(n.p,{children:"With the core setup complete, it's time to load a Fragments model into our scene. Fragments are optimized for fast loading and rendering, making them ideal for large-scale 3D models."}),"\n",(0,o.jsx)(n.admonition,{title:"Where can I find Fragment files?",type:"info",children:(0,o.jsx)(n.p,{children:"You can use the sample Fragment files available in our repository for testing. If you have an IFC model you'd like to convert to Fragments, check out the IfcImporter tutorial for detailed instructions."})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'const fragPaths = [\n  "https://thatopen.github.io/engine_components/resources/frags/school_arq.frag",\n  "https://thatopen.github.io/engine_components/resources/frags/school_str.frag",\n];\n\nawait Promise.all(\n  fragPaths.map(async (path) => {\n    const modelId = path.split("/").pop()?.split(".").shift();\n    if (!modelId) return null;\n    const file = await fetch(path);\n    const buffer = await file.arrayBuffer();\n    return fragments.core.load(buffer, { modelId });\n  }),\n);\n'})}),"\n",(0,o.jsx)(n.h3,{id:"-using-the-viewpoints-component",children:"\u2728 Using The Viewpoints Component"}),"\n",(0,o.jsx)(n.p,{children:"Creating viewpoints is extremely simple. Let's start by getting the component's instance to use it along the example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const viewpoints = components.get(OBC.Viewpoints);\nviewpoints.world = world;\n"})}),"\n",(0,o.jsx)(n.p,{children:"Once completed, creating the viewpoint is straightforward. Let's define a helper function to streamline the process, allowing us to maintain the flow of the example and execute the function from the UI."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'let viewpoint: OBC.Viewpoint | undefined;\nconst createViewpoint = async () => {\n  viewpoint = viewpoints.create();\n  // You can set an optional title for UI purposes\n  viewpoint.title = "My Viewpoint";\n\n  // Update the viewpoint to capture the current camera data, as this is the most common use case:\n  await viewpoint.updateCamera();\n};\n'})}),"\n",(0,o.jsx)(n.p,{children:"By default, the method used to update the viewpoint camera captures a snapshot of the current world's camera view. This snapshot is included when the viewpoint is exported as part of a BCF topic. You can update the snapshot at any time:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const updateSnapshot = () => {\n  if (!viewpoint) return;\n  viewpoint.takeSnapshot();\n};\n"})}),"\n",(0,o.jsx)(n.p,{children:"The viewpoint position is automatically set based on the world's camera by default. If you need to update it, you can adjust the camera position and trigger the corresponding method. For demonstration purposes, let's create a general function that can be triggered later using a button:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'const updateViewpointCamera = async () => {\n  if (!viewpoint) return;\n  console.log("Position before updating", viewpoint.position);\n  await viewpoint.updateCamera();\n  console.log("Position after updating", viewpoint.position);\n};\n'})}),"\n",(0,o.jsx)(n.p,{children:"Setting the camera back to the viewpoint position is straightforward. Let's create a simple function that can be triggered from the UI:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'const setWorldCamera = async () => {\n  if (!viewpoint) return;\n  const initialPosition = new THREE.Vector3();\n  world.camera.controls.getPosition(initialPosition);\n  console.log("Camera position before updating", initialPosition);\n  await viewpoint.go();\n  const finalPosition = new THREE.Vector3();\n  world.camera.controls.getPosition(finalPosition);\n  console.log("Camera position before updating", finalPosition);\n};\n'})}),"\n",(0,o.jsx)(n.h3,{id:"-adding-and-retrieving-model-elements",children:"\ud83e\uddf1 Adding and Retrieving Model Elements"}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.p,{children:"Viewpoints make it easy to store and retrieve selected elements. You can add elements using GUIDs obtained from ModelIdMaps. For instance, if you already have some GUIDs, you can add them to a viewpoint. Since the viewpoint will be created dynamically using the UI in this example, let's listen for the creation of a new viewpoint and add some default items to it:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'viewpoints.list.onItemSet.add(({ value: viewpoint }) => {\n  viewpoint.selectionComponents.add(\n    "3V$FMCDUfCoPwUaHMPfteW",\n    "1fIVuvFffDJRV_SJESOtCZ",\n  );\n});\n'})}),"\n",(0,o.jsx)(n.p,{children:"While GUIDs are ideal for transferring selections between BIM apps, within That Open Engine, ModelIdMaps are more commonly used for selections. For example, the Highlighter component generates these maps based on model selections. Here's how to programmatically create a ModelIdMap for all doors in the model and add it to the viewpoint:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"// Once again, as the viewpoint will be created on demand\n// let's listen for the creation event to assing the doors to it\nviewpoints.list.onItemSet.add(async ({ value: viewpoint }) => {\n  const finder = components.get(OBC.ItemsFinder);\n  const doors = await finder.getItems([{ categories: [/DOOR/] }]);\n  const guids = await fragments.modelIdMapToGuids(doors);\n  viewpoint.selectionComponents.add(...guids);\n});\n"})}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsx)(n.p,{children:"In BCF, the elements associated with a viewpoint are referred to as components. If you're unsure how to use the ItemsFinder to retrieve the elements you need, check out the corresponding component tutorial for guidance."})}),"\n",(0,o.jsx)(n.p,{children:"Viewpoint components include the GUIDs added earlier and new ones from the FragmentIdMap. Here's a simple function to log selection components as GUIDs and a FragmentIdMap for use with Highlighter or Hider:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const reportComponents = async () => {\n  if (!viewpoint) return;\n  const selectionGuids = viewpoint.selectionComponents;\n  const selectionMap = await viewpoint.getSelectionMap();\n  console.log(selectionGuids, selectionMap);\n};\n"})}),"\n",(0,o.jsx)(n.p,{children:"To make things more engaging, let's isolate the elements associated with the viewpoint as follows:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const isolateComponents = async () => {\n  if (!viewpoint) return;\n  const items = await viewpoint.getSelectionMap();\n  const hider = components.get(OBC.Hider);\n  hider.isolate(items);\n};\n"})}),"\n",(0,o.jsx)(n.h3,{id:"-linking-viewpoints-to-topics",children:"\ud83d\udd17 Linking Viewpoints to Topics"}),"\n",(0,o.jsx)(n.p,{children:"Viewpoints can be linked to topics to enhance communication. While topics and viewpoints are created independently, you can associate one or more viewpoint GUIDs with a topic as follows:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"// Once again, as the viewpoint will be created on demand\n// let's listen for the creation event to assing the doors to it\nviewpoints.list.onItemSet.add(({ value: viewpoint }) => {\n  const bcfTopics = components.get(OBC.BCFTopics);\n  const topic = bcfTopics.create();\n  topic.viewpoints.add(viewpoint.guid);\n});\n"})}),"\n",(0,o.jsx)(n.p,{children:"Simple as that! Using GUIDs instead of full viewpoint objects helps avoid memory leaks when deleting viewpoints. Finally, just for fun, let's get the data from the viewpoint snapshot so it can be displayed in the UI"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const getViewpointSnapshotData = () => {\n  if (!viewpoint) return null;\n  const data = viewpoints.snapshots.get(viewpoint.snapshot);\n  if (!data) return null;\n  return data;\n};\n"})}),"\n",(0,o.jsx)(n.h3,{id:"-adding-some-ui-optional-but-recommended",children:"\ud83e\udde9 Adding some UI (optional but recommended)"}),"\n",(0,o.jsxs)(n.p,{children:["We will use the ",(0,o.jsx)(n.code,{children:"@thatopen/ui"})," library to add some simple and cool UI elements to our app. First, we need to call the ",(0,o.jsx)(n.code,{children:"init"})," method of the ",(0,o.jsx)(n.code,{children:"BUI.Manager"})," class to initialize the library:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"BUI.Manager.init();\n"})}),"\n",(0,o.jsx)(n.p,{children:"Now we will add some UI to play around with the actions in this tutorial. For more information about the UI library, you can check the specific documentation for it!"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'const [panel, updatePanel] = BUI.Component.create<BUI.PanelSection, {}>((_) => {\n  const onResetVisibility = async ({ target }: { target: BUI.Button }) => {\n    target.loading = true;\n    const hider = components.get(OBC.Hider);\n    await hider.set(true);\n    target.loading = false;\n  };\n\n  let controls = BUI.html`\n    <bim-panel-section label="Viewpoint Creation">\n      <bim-label>To start, hit the button below to create a new viewpoint</bim-label>\n      <bim-button label="Create Viewpoint" @click=${createViewpoint}></bim-button>\n    </bim-panel-section>\n  `;\n\n  if (viewpoint) {\n    const snapshotData = getViewpointSnapshotData();\n\n    let snapshotElement: BUI.TemplateResult | undefined;\n    if (snapshotData) {\n      const blob = new Blob([snapshotData], { type: "image/png" });\n      const url = URL.createObjectURL(blob);\n      snapshotElement = BUI.html`\n        <img src="${url}" alt="Viewpoint Snapshot" style="max-width: 20rem;"/>\n      `;\n    }\n\n    const onDeleteViewpoint = () => {\n      if (!viewpoint) return;\n      const { guid } = viewpoint;\n      viewpoint = undefined;\n      viewpoints.list.delete(guid);\n    };\n\n    controls = BUI.html`\n      <bim-panel-section label="Controls">\n        <bim-button @click=${updateSnapshot} label="Update Snapshot"></bim-button>\n        ${snapshotElement}\n        <bim-button @click=${updateViewpointCamera} label="Update Viewpoint Camera"></bim-button>\n        <bim-button @click=${setWorldCamera} label="Set World Camera"></bim-button>\n        <bim-button @click=${reportComponents} label="Report Selection Components"></bim-button>\n        <bim-button @click=${isolateComponents} label="Isolate Components"></bim-button>\n        <bim-button @click=${onDeleteViewpoint} label="Delete Viewpoint"></bim-button>\n      </bim-panel-section>\n    `;\n  }\n\n  return BUI.html`\n    <bim-panel active label="Viewpoints Tutorial" class="options-menu">\n      <bim-panel-section label="Information">\n        <bim-label style="white-space: normal; width: 18rem;">To better experience this tutorial, open the developer tool\'s console in your browser to see some logs.</bim-label>\n        <bim-button label="Reset Visibility" @click=${onResetVisibility}></bim-button>\n      </bim-panel-section>\n      ${controls}\n    </bim-panel>\n  `;\n}, {});\n\nviewpoints.list.onItemDeleted.add(() => updatePanel());\nviewpoints.list.onItemUpdated.add(() => updatePanel());\n\ndocument.body.append(panel);\n'})}),"\n",(0,o.jsx)(n.p,{children:"And we will make some logic that adds a button to the screen when the user is visiting our app from their phone, allowing to show or hide the menu. Otherwise, the menu would make the app unusable."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'const button = BUI.Component.create<BUI.PanelSection>(() => {\n  return BUI.html`\n      <bim-button class="phone-menu-toggler" icon="solar:settings-bold"\n        @click="${() => {\n          if (panel.classList.contains("options-menu-visible")) {\n            panel.classList.remove("options-menu-visible");\n          } else {\n            panel.classList.add("options-menu-visible");\n          }\n        }}">\n      </bim-button>\n    `;\n});\n\ndocument.body.append(button);\n'})}),"\n",(0,o.jsx)(n.h3,{id:"\ufe0f-measuring-the-performance-optional",children:"\u23f1\ufe0f Measuring the performance (optional)"}),"\n",(0,o.jsxs)(n.p,{children:["We'll use the ",(0,o.jsx)(n.a,{href:"https://github.com/mrdoob/stats.js",children:"Stats.js"})," to measure the performance of our app. We will add it to the top left corner of the viewport. This way, we'll make sure that the memory consumption and the FPS of our app are under control."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'const stats = new Stats();\nstats.showPanel(2);\ndocument.body.append(stats.dom);\nstats.dom.style.left = "0px";\nstats.dom.style.zIndex = "unset";\nworld.renderer.onBeforeUpdate.add(() => stats.begin());\nworld.renderer.onAfterUpdate.add(() => stats.end());\n'})}),"\n",(0,o.jsx)(n.h3,{id:"-wrap-up",children:"\ud83c\udf89 Wrap up"}),"\n",(0,o.jsx)(n.p,{children:"That's it! Now you're able to create, update, and manage viewpoints effectively using That Open Engine. Congratulations! Keep exploring more tutorials in the documentation to enhance your skills further."})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var o=t(6540);const i={},s=o.createContext(i);function a(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);