"use strict";(self.webpackChunkengine_docs=self.webpackChunkengine_docs||[]).push([[1586],{7040:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>d});var r=t(4848),a=t(8453);const o={},i=void 0,l={id:"Tutorials/Fragments/Fragments/FragmentsModels/EditProperties",title:"EditProperties",description:'window.open("https://thatopen.github.io/engine_fragment/examples/FragmentsModels/EditProperties")} >Go Full Screen',source:"@site/docs/Tutorials/Fragments/Fragments/FragmentsModels/EditProperties.mdx",sourceDirName:"Tutorials/Fragments/Fragments/FragmentsModels",slug:"/Tutorials/Fragments/Fragments/FragmentsModels/EditProperties",permalink:"/Tutorials/Fragments/Fragments/FragmentsModels/EditProperties",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"EditElements",permalink:"/Tutorials/Fragments/Fragments/FragmentsModels/EditElements"},next:{title:"Materials",permalink:"/Tutorials/Fragments/Fragments/FragmentsModels/Materials"}},s={},d=[{value:"Editing BIM Properties \ud83e\ude91",id:"editing-bim-properties-",level:2},{value:"\ud83d\udd96 Importing our Libraries",id:"-importing-our-libraries",level:3},{value:"\ud83c\udf0e Setting up a Simple Scene",id:"-setting-up-a-simple-scene",level:3},{value:"\ud83d\udee0\ufe0f Setting Up Fragments",id:"\ufe0f-setting-up-fragments",level:3},{value:"\ud83d\udcc2 Loading a Fragments Model",id:"-loading-a-fragments-model",level:3},{value:"\u270f\ufe0f Setting up the model editor",id:"\ufe0f-setting-up-the-model-editor",level:3},{value:"\ud83e\udde9 Adding User Interface (optional)",id:"-adding-user-interface-optional",level:3},{value:"\u23f1\ufe0f Measuring the performance (optional)",id:"\ufe0f-measuring-the-performance-optional",level:3},{value:"\ud83c\udf89 Congratulations!",id:"-congratulations",level:3}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",hr:"hr",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)("div",{style:{position:"relative"},children:[(0,r.jsx)("iframe",{src:"https://thatopen.github.io/engine_fragment/examples/FragmentsModels/EditProperties"}),(0,r.jsx)("button",{class:"full-screen-btn",onClick:()=>window.open("https://thatopen.github.io/engine_fragment/examples/FragmentsModels/EditProperties"),children:"Go Full Screen"})]}),"\n",(0,r.jsx)(n.admonition,{title:"Source",type:"info",children:(0,r.jsxs)(n.p,{children:["Copying and pasting? We've got you covered! You can find the full source code of this tutorial ",(0,r.jsx)(n.a,{href:"https://github.com/ThatOpen/engine_fragment/blob/main/packages/fragments/src/FragmentsModels/examples/EditProperties/example.ts",children:"here"}),"."]})}),"\n",(0,r.jsx)(n.h2,{id:"editing-bim-properties-",children:"Editing BIM Properties \ud83e\ude91"}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:"In this tutorial, we'll explore how to easily edit BIM properties using the Fragments Edit API. We will create, delete, edit and relate properties, register everything in a history that we can revert and more. Let\u2019s dive in!"}),"\n",(0,r.jsx)(n.h3,{id:"-importing-our-libraries",children:"\ud83d\udd96 Importing our Libraries"}),"\n",(0,r.jsx)(n.p,{children:"First things first, let's install all necessary dependencies to make this example work:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'import * as OBC from "@thatopen/components";\nimport Stats from "stats.js";\nimport * as THREE from "three";\nimport * as BUI from "@thatopen/ui";\n// You have to import * as FRAGS from "@thatopen/fragments"\nimport * as FRAGS from "../../../index";\n'})}),"\n",(0,r.jsx)(n.h3,{id:"-setting-up-a-simple-scene",children:"\ud83c\udf0e Setting up a Simple Scene"}),"\n",(0,r.jsx)(n.p,{children:"To get started, let's set up a basic ThreeJS scene. This will serve as the foundation for our application and allow us to visualize the 3D models effectively:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'const components = new OBC.Components();\nconst worlds = components.get(OBC.Worlds);\nconst container = document.getElementById("container") as HTMLDivElement;\n\nconst world = worlds.create<\n  OBC.ShadowedScene,\n  OBC.OrthoPerspectiveCamera,\n  OBC.SimpleRenderer\n>();\n\nworld.scene = new OBC.ShadowedScene(components);\nworld.renderer = new OBC.SimpleRenderer(components, container);\nworld.camera = new OBC.OrthoPerspectiveCamera(components);\n\ncomponents.init();\n\nworld.scene.three.add(new THREE.AxesHelper());\n\nworld.camera.three.far = 10000;\n\nworld.renderer.three.shadowMap.enabled = true;\nworld.renderer.three.shadowMap.type = THREE.PCFSoftShadowMap;\n\nworld.scene.setup({\n  shadows: {\n    cascade: 1,\n    resolution: 1024,\n  },\n});\n\nawait world.scene.updateShadows();\n\nworld.camera.controls.addEventListener("rest", async () => {\n  await world.scene.updateShadows();\n});\n'})}),"\n",(0,r.jsx)(n.admonition,{title:"Do I need @thatopen/components?",type:"info",children:(0,r.jsx)(n.p,{children:"Not necessarily! While @thatopen/components simplifies the process of setting up a scene, you can always use plain ThreeJS to create your own custom scene setup. It's entirely up to your preference and project requirements! \ud83d\ude09"})}),"\n",(0,r.jsx)(n.h3,{id:"\ufe0f-setting-up-fragments",children:"\ud83d\udee0\ufe0f Setting Up Fragments"}),"\n",(0,r.jsx)(n.p,{children:"Now, let's configure the Fragments library core. This will allow us to load models effortlessly and start manipulating them with ease:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'// You have to copy `/node_modules/@thatopen/fragments/dist/Worker/worker.mjs` to your project directory\n// and provide the relative path in `workerUrl`\n// We use here the internal route of the worker in the library for simplicity purposes\nconst workerUrl = "https://thatopen.github.io/engine_fragment/resources/worker.mjs";\nconst fragments = new FRAGS.FragmentsModels(workerUrl);\nworld.camera.controls.addEventListener("control", () => fragments.update());\n\nfragments.models.list.onItemSet.add(({ value: model }) => {\n  model.tiles.onItemSet.add(({ value: mesh }) => {\n    if ("isMesh" in mesh) {\n      const mat = mesh.material as THREE.MeshStandardMaterial[];\n      if (mat[0].opacity === 1) {\n        mesh.castShadow = true;\n        mesh.receiveShadow = true;\n      }\n    }\n  });\n});\n'})}),"\n",(0,r.jsx)(n.h3,{id:"-loading-a-fragments-model",children:"\ud83d\udcc2 Loading a Fragments Model"}),"\n",(0,r.jsx)(n.p,{children:"With the core setup complete, it's time to load a Fragments model into our scene. Fragments are optimized for fast loading and rendering, making them ideal for large-scale 3D models."}),"\n",(0,r.jsx)(n.admonition,{title:"Where can I find Fragment files?",type:"info",children:(0,r.jsx)(n.p,{children:"You can use the sample Fragment files available in our repository for testing. If you have an IFC model you'd like to convert to Fragments, check out the IfcImporter tutorial for detailed instructions."})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'const fetched = await fetch("https://thatopen.github.io/engine_fragment/resources/frags/school_arq.frag");\nconst buffer = await fetched.arrayBuffer();\nconst model = await fragments.load(buffer, {\n  modelId: "medium_test",\n  camera: world.camera.three,\n});\n\nworld.scene.three.add(model.object);\nawait fragments.update(true);\n'})}),"\n",(0,r.jsx)(n.h3,{id:"\ufe0f-setting-up-the-model-editor",children:"\u270f\ufe0f Setting up the model editor"}),"\n",(0,r.jsx)(n.p,{children:"Now we'll set up all the logic to edit its properties."}),"\n",(0,r.jsx)(n.admonition,{title:"How to edit the model?",type:"info",children:(0,r.jsx)(n.p,{children:'When building an authoring app, objects could be edited in many ways: from just moving them and changing their material, to smart logic specific to their geometry (e.g. revit system families). For that reason, it\'s better to encapsulate the edit logic in a class that defines HOW we want to edit the elements. That way we can build multiple "editors" that we can use across our app.'})}),"\n",(0,r.jsx)(n.p,{children:"In this tutorial, we'll create a general Editor that can edit, create and delete properties and edit, create and delete relations. Let's start by defining some basic types:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'type TableData = {\n  Name: string;\n  Value?: string | number | boolean;\n  LocalId: number;\n  ParentLocalId?: number;\n  ParentName?: string;\n  Type?: "relation" | "related";\n};\n\ntype TableNode = {\n  data: TableData;\n  children?: TableNode[];\n};\n\ntype AttributeType = {\n  name: string;\n  type: string;\n  value: string;\n};\n'})}),"\n",(0,r.jsx)(n.p,{children:"Now, let's create our editor:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'class PropertyEditor {\n  // Now we\'ll define some basic events to update the UI\n  onItemCreated = new OBC.Event<void>();\n  onPropertiesUpdated = new OBC.Event<TableNode[]>();\n  onCategoriesUpdated = new OBC.Event<void>();\n\n  // We will store the data config here used to retrieve the\n  // properties and relations from the model\n  elementConfig: FRAGS.ElementConfig = {\n    data: {\n      attributesDefault: true,\n      relations: {\n        IsDefinedBy: { attributes: true, relations: true },\n        DefinesOcurrence: { attributes: false, relations: false },\n      },\n    },\n  };\n\n  // We\'ll need a reference to the currently used element and meshes\n  currentElement: FRAGS.Element | null = null;\n  currentMesh: THREE.Group | null = null;\n\n  // Here we\'ll store the current data we are editing in the UI\n  itemsDataById = new Map<number, FRAGS.ItemData>();\n  updatedItems = new Set<number>();\n  currentRelation: { id: number; name: string; ids: number[] } | null = null;\n  currentCategory: string | null = null;\n  currentAttributes: AttributeType[] = [];\n\n  // And here we\'ll have a list of all categories to select\n  // items by category in the UI\n  allCategories: string[] = [];\n\n  private _world: OBC.World;\n\n  constructor(world: OBC.World) {\n    this._world = world;\n    this.setupEvents();\n  }\n\n  // We\'ll initialize the categories here because it\'s async,\n  // so we can\'t do it in the constructor\n  async init() {\n    this.allCategories = await model.getCategories();\n  }\n\n  // We\'ll use this when the user clicks the "Add attribute" button in the UI\n  // to add a new empty attribute to the current list of attributes\n  addEmptyAttribute() {\n    this.currentAttributes.push({\n      name: "",\n      type: "",\n      value: "",\n    });\n  }\n\n  // We\'ll use this when the user clicks the "Delete attribute" button in the UI\n  // to remove the attribute from the current list of attributes\n  deleteAttribute(attribute: AttributeType) {\n    const index = this.currentAttributes.indexOf(attribute);\n    this.currentAttributes.splice(index, 1);\n  }\n\n  // We\'ll use this when the user types in the "Value" input in the UI\n  // to update the value of the attribute\n  updateAttribute(row: Partial<TableData>, e: any) {\n    if (!this.currentElement) return;\n    const localId = row.LocalId as number;\n    const item = this.itemsDataById.get(localId);\n    if (!item) {\n      throw new Error(`Item ${localId} not found`);\n    }\n    const attr = item[row.Name!] as FRAGS.ItemAttribute;\n    attr.value = e.target.value;\n    this.updatedItems.add(localId);\n  }\n\n  // We\'ll use this to regenerate the properties table in the UI\n  updatePropertiesTable = async () => {\n    if (!this.currentElement) {\n      return;\n    }\n    this.itemsDataById.clear();\n    this.updatedItems.clear();\n    const data = await this.currentElement.getData();\n    const rootNode = this.getTableRecursively(data);\n    this.onPropertiesUpdated.trigger([rootNode]);\n  };\n\n  // We\'ll use this to apply all the changes to properties and relations\n\n  async applyChanges() {\n    if (!this.currentElement) {\n      return;\n    }\n\n    for (const localId of this.updatedItems) {\n      const item = this.itemsDataById.get(localId);\n      if (!item) {\n        throw new Error(`Item ${localId} not found`);\n      }\n      fragments.editor.setItem(model.modelId, item);\n    }\n\n    await fragments.editor.applyChanges(model.modelId);\n\n    if (this.currentElement && this.currentMesh) {\n      this.currentElement.disposeMeshes(this.currentMesh);\n    }\n\n    this.onPropertiesUpdated.trigger([]);\n    this.itemsDataById.clear();\n\n    await fragments.update(true);\n    this.currentElement = null;\n    this.updatePropertiesTable();\n  }\n\n  // We\'ll use this to create a new relation between items\n  // E.g. to assign a property to a property set\n  async relate() {\n    if (!this.currentRelation) {\n      return;\n    }\n    const { id, name, ids } = this.currentRelation;\n    await fragments.editor.relate(model.modelId, id, name, ids);\n    await fragments.editor.applyChanges(model.modelId);\n    await this.updatePropertiesTable();\n  }\n\n  // We\'ll use this to remove a relation between items\n  // E.g. to remove a property from a property set\n  async unrelate() {\n    if (!this.currentRelation) {\n      return;\n    }\n    const { id, name, ids } = this.currentRelation;\n    await fragments.editor.unrelate(model.modelId, id, name, ids);\n    await fragments.editor.applyChanges(model.modelId);\n    await this.updatePropertiesTable();\n  }\n\n  // We\'ll use this to create a new item\n  async createItem() {\n    if (!this.currentCategory) return;\n\n    const data: Record<string, FRAGS.ItemAttribute> = {};\n    const guid = THREE.MathUtils.generateUUID();\n\n    for (const attribute of this.currentAttributes) {\n      if (attribute.name && attribute.value) {\n        data[attribute.name] = {\n          type: attribute.type,\n          value: attribute.value,\n        };\n      }\n    }\n\n    fragments.editor.createItem(model.modelId, {\n      data,\n      category: this.currentCategory,\n      guid,\n    });\n\n    await fragments.editor.applyChanges(model.modelId);\n\n    this.allCategories = await model.getCategories();\n    this.onCategoriesUpdated.trigger();\n\n    this.onItemCreated.trigger();\n  }\n\n  // We\'ll use this to delete items from the model\n  async deleteItem(localId: number) {\n    if (!this.currentElement) {\n      return;\n    }\n    await fragments.editor.deleteData(model.modelId, {\n      itemIds: [localId],\n    });\n    await fragments.editor.applyChanges(model.modelId);\n    await this.updatePropertiesTable();\n  }\n\n  // This method allows us to build the property tree of a given item\n  // E.g. including all it\'s attribtes and certain relations recursively\n  // (not all relations to avoid infinite recursion)\n  private getTableRecursively(data: FRAGS.ItemData, parent?: TableNode) {\n    const localId = (data._localId as FRAGS.ItemAttribute).value;\n    this.itemsDataById.set(localId, data);\n\n    const currentNode: TableNode = {\n      data: {\n        Name: localId,\n        LocalId: localId,\n        Type: "related",\n      },\n      children: [],\n    };\n\n    if (parent) {\n      parent.children!.push(currentNode);\n      currentNode.data.ParentLocalId = parent.data.LocalId;\n      currentNode.data.ParentName = parent.data.Name;\n    }\n\n    for (const name in data) {\n      const current = data[name];\n      if (Array.isArray(current)) {\n        // Is rel\n        const relNode: TableNode = {\n          data: {\n            Name: name,\n            LocalId: localId,\n            Type: "relation",\n          },\n          children: [],\n        };\n\n        currentNode.children!.push(relNode);\n        for (const item of current) {\n          this.getTableRecursively(item, relNode);\n        }\n      } else {\n        // Is attribute\n        if (current.value === undefined || current.value === null) {\n          continue;\n        }\n        if (name.startsWith("_")) {\n          continue;\n        }\n        currentNode.children!.push({\n          data: {\n            Name: name,\n            Value: current.value,\n            LocalId: localId,\n          },\n        });\n      }\n    }\n\n    return currentNode;\n  }\n\n  // We\'ll use this to setup the events:\n  // - Double click to select an element\n  // - Escape to deselect the current element\n  private setupEvents() {\n    const mouse = new THREE.Vector2();\n    const canvas = world.renderer!.three.domElement!;\n    canvas.addEventListener("dblclick", async (event) => {\n      mouse.x = event.clientX;\n      mouse.y = event.clientY;\n      let result: any;\n\n      if (this.currentElement && this.currentMesh) {\n        this.currentElement.disposeMeshes(this.currentMesh);\n      }\n\n      // Raycast all models, including delta models\n\n      for (const [, model] of fragments.models.list) {\n        const promises: Promise<FRAGS.RaycastResult | null>[] = [];\n        promises.push(\n          model.raycast({\n            camera: world.camera.three,\n            mouse,\n            dom: world.renderer!.three.domElement!,\n          }),\n        );\n        const results = await Promise.all(promises);\n        let smallestDistance = Infinity;\n        for (const current of results) {\n          if (current) {\n            if (current.distance < smallestDistance) {\n              smallestDistance = current.distance;\n              result = current;\n            }\n          }\n        }\n      }\n      if (!result) {\n        return;\n      }\n\n      const [element] = await fragments.editor.getElements(model.modelId, [\n        result.localId,\n      ]);\n\n      this.currentElement = element;\n      this.currentElement.config = this.elementConfig;\n\n      if (!element) {\n        return;\n      }\n\n      this.currentMesh = await element.getMeshes();\n      this.currentMesh.traverse((child) => {\n        if (child instanceof THREE.Mesh) {\n          const mat = child.material as THREE.MeshLambertMaterial;\n          mat.depthTest = false;\n          mat.color.set("gold");\n        }\n      });\n      this._world.scene.three.add(this.currentMesh);\n\n      this.updatePropertiesTable();\n    });\n\n    window.addEventListener("keydown", async (event) => {\n      if (event.key === "Escape") {\n        if (!this.currentElement) {\n          return;\n        }\n\n        if (this.currentElement && this.currentMesh) {\n          this.currentElement.disposeMeshes(this.currentMesh);\n        }\n\n        this.currentElement.getRequests();\n\n        this.currentAttributes = [];\n        this.onPropertiesUpdated.trigger([]);\n        this.itemsDataById.clear();\n        await fragments.update(true);\n        this.currentElement = null;\n        this.updatePropertiesTable();\n      }\n    });\n  }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Great! Now we just need to instantiate and initialize the editor we just built, and we'll be ready to start editing properties and relations."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const editor = new PropertyEditor(world);\nawait editor.init();\n"})}),"\n",(0,r.jsx)(n.h3,{id:"-adding-user-interface-optional",children:"\ud83e\udde9 Adding User Interface (optional)"}),"\n",(0,r.jsxs)(n.p,{children:["We will use the ",(0,r.jsx)(n.code,{children:"@thatopen/ui"})," library to add some simple and cool UI elements to our app. First, we need to call the ",(0,r.jsx)(n.code,{children:"init"})," method of the ",(0,r.jsx)(n.code,{children:"BUI.Manager"})," class to initialize the library:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"BUI.Manager.init();\n"})}),"\n",(0,r.jsx)(n.p,{children:"Now we will create various UI elements to use the logic of the editor we just made. We will start by defining a table to edit the properties of the selected element."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'const propertiesTable = document.createElement(\n  "bim-table",\n) as BUI.Table<TableData>;\npropertiesTable.headersHidden = true;\npropertiesTable.expanded = true;\npropertiesTable.hiddenColumns = [\n  "LocalId",\n  "Type",\n  "ParentLocalId",\n  "ParentName",\n];\n'})}),"\n",(0,r.jsx)(n.p,{children:"Now, before defining the properties table, we will define 3 modals. One for adding new items to a relation, one for creating new items and one for adding new relations. Let's start with the modal to add new items to a relation!"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'const onCloseAddItemModal = new OBC.Event<void>();\n\nconst [addItemModal, updateAddItemModal] = BUI.Component.create<\n  HTMLDialogElement,\n  any\n>((_) => {\n  const itemIdsDropdownContainer = BUI.Component.create<HTMLDivElement>(() => {\n    return BUI.html`\n    <div></div>\n    `;\n  });\n\n  // We\'ll define a function to get a list of items to select\n\n  const updateItemIds = async (category: string | undefined) => {\n    const children = [...itemIdsDropdownContainer.children];\n    for (const child of children) {\n      child.remove();\n    }\n\n    const itemIdsDropdown = BUI.Component.create<BUI.PanelSection>(() => {\n      return BUI.html`\n      <bim-dropdown label="Select items" multiple @change=${(e: any) => {\n        if (!editor.currentRelation) return;\n        editor.currentRelation.ids = e.target.value as number[];\n      }}>\n      </bim-dropdown>\n      `;\n    });\n\n    itemIdsDropdownContainer.appendChild(itemIdsDropdown);\n\n    if (!category) {\n      return;\n    }\n\n    const regexp = new RegExp(category);\n    const itemIdsByCategory = await model.getItemsOfCategories([regexp]);\n\n    for (const categoryName in itemIdsByCategory) {\n      const itemIds = itemIdsByCategory[categoryName];\n      for (const itemId of itemIds) {\n        const itemIdOption = BUI.Component.create<BUI.Option>(() => {\n          return BUI.html`\n          <bim-option value=${itemId} label=${itemId}></bim-option>\n          `;\n        });\n        itemIdsDropdown.appendChild(itemIdOption);\n      }\n    }\n  };\n\n  // And now we\'ll create the dropdown to select the category of the item to add\n\n  const categoriesDropdown = BUI.Component.create<BUI.Dropdown>(() => {\n    return BUI.html`\n        <bim-dropdown label="Select category" @change=${(e: any) => {\n          if (e.target.value[0]) {\n            updateItemIds(e.target.value[0]);\n          }\n        }}>\n        ${editor.allCategories.map((category) => {\n          return BUI.html`\n          <bim-option value=${category} label=${category}>\n          </bim-option>`;\n        })}\n        </bim-dropdown>\n    `;\n  });\n\n  // Now, when closing the modal, we\'ll reset the data\n\n  onCloseAddItemModal.reset();\n  onCloseAddItemModal.add(() => {\n    categoriesDropdown.value = [];\n    updateAddItemModal();\n  });\n\n  // And now we\'ll return the HTML for the modal itself\n\n  return BUI.html`\n    <dialog class="blurred-dialog">\n     <bim-panel style="border-radius: var(--bim-ui_size-base); width: 22rem;">\n      <bim-panel-section fixed label="Add item to relation">\n        ${categoriesDropdown}\n        ${itemIdsDropdownContainer}\n        <bim-button label="Apply" @click=${() => {\n          if (editor.currentElement && editor.currentRelation) {\n            editor.relate().then(() => {\n              addItemModal.close();\n            });\n          }\n        }}></bim-button>\n      </bim-panel-section>\n     </bim-panel> \n    </dialog>\n  `;\n}, {});\n\n// Now, let\'s add the modal to the app and set up some last events\n\ndocument.body.appendChild(addItemModal);\n\naddItemModal.addEventListener("close", () => {\n  onCloseAddItemModal.trigger();\n});\n\neditor.onCategoriesUpdated.add(() => {\n  updateAddItemModal();\n});\n'})}),"\n",(0,r.jsx)(n.p,{children:"Now, let's create the modal to create new items. It will be a form that allows users to set arbitrary attributes for the new item."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'const onCloseCreateItemModal = new OBC.Event<void>();\n\nconst [createItemModal, updateCreateItemModal] = BUI.Component.create<\n  HTMLDialogElement,\n  any\n>((_) => {\n  // We\'ll start by creating a container for the form\n  const formContainer = BUI.Component.create<HTMLDivElement>(() => {\n    return BUI.html`\n    <div style="display: flex; flex-direction: column; gap: 0.5rem;"></div>\n    `;\n  });\n\n  // We\'ll add an empty attribute if there are no attributes yet\n\n  if (editor.currentAttributes.length === 0) {\n    editor.addEmptyAttribute();\n  }\n\n  // And now we\'ll create a form entry for each attribute\n\n  for (const attribute of editor.currentAttributes) {\n    const entry = BUI.Component.create<HTMLDivElement>(() => {\n      return BUI.html`\n      <div style="display: flex; align-items: center; gap: 0.5rem;">\n        <bim-text-input placeholder="Name" value=${attribute.name} @input=${(\n          e: any,\n        ) => {\n          attribute.name = e.target.value;\n        }}></bim-text-input>\n        <bim-text-input placeholder="Type" value=${attribute.type} @input=${(\n          e: any,\n        ) => {\n          attribute.type = e.target.value;\n        }}></bim-text-input>\n        <bim-text-input placeholder="Value" value=${attribute.value} @input=${(\n          e: any,\n        ) => {\n          attribute.value = e.target.value;\n        }}></bim-text-input>\n        <bim-button icon="material-symbols:delete" @click=${() => {\n          editor.deleteAttribute(attribute);\n          updateCreateItemModal();\n        }}></bim-button>\n      </div>\n      `;\n    });\n    formContainer.appendChild(entry);\n  }\n\n  // Now, when closing the modal, we\'ll reset the data\n\n  onCloseCreateItemModal.reset();\n  onCloseCreateItemModal.add(() => {\n    editor.currentAttributes = [];\n    updateCreateItemModal();\n  });\n\n  // And now we\'ll return the HTML for the modal itself\n\n  return BUI.html`\n    <dialog class="blurred-dialog">\n     <bim-panel style="border-radius: var(--bim-ui_size-base); width: 22rem;">\n         \n      <bim-panel-section fixed label="Create new element">\n\n      <bim-text-input label="Category" @input=${(e: any) => {\n        editor.currentCategory = e.target.value as string;\n      }}></bim-text-input>\n        \n        ${formContainer}\n        <bim-button label="Add attribute" icon="ic:baseline-add" @click=${() => {\n          editor.addEmptyAttribute();\n          updateCreateItemModal();\n        }}></bim-button>\n        <bim-button label="Apply" @click=${() => {\n          editor.createItem();\n        }}></bim-button>\n      </bim-panel-section>\n     </bim-panel> \n    </dialog>\n  `;\n}, {});\n\n// Now, let\'s add the modal to the app and set up some last events\n\ndocument.body.appendChild(createItemModal);\n\neditor.onItemCreated.add(() => {\n  createItemModal.close();\n});\n\ncreateItemModal.addEventListener("close", () => {\n  onCloseCreateItemModal.trigger();\n});\n\neditor.onCategoriesUpdated.add(() => {\n  updateCreateItemModal();\n});\n'})}),"\n",(0,r.jsx)(n.p,{children:"Now let's create the modal to add new relations. It will be a form that allows users to select the category of the items to relate and the items themselves."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'const onCloseAddRelationModal = new OBC.Event<void>();\n\nconst [addRelationModal, updateAddRelationModal] = BUI.Component.create<\n  HTMLDialogElement,\n  any\n>((_) => {\n  // We\'ll start by creating a container for the dropdown to select the items\n  const itemIdsDropdownContainer = BUI.Component.create<HTMLDivElement>(() => {\n    return BUI.html`\n    <div></div>\n    `;\n  });\n\n  // We\'ll create a input to set the name of the relation\n\n  const relationNameInput = BUI.Component.create<BUI.PanelSection>(() => {\n    return BUI.html`\n    <bim-text-input label="Relation name" @input=${(e: any) => {\n      if (!editor.currentRelation) return;\n      editor.currentRelation.name = e.target.value as string;\n    }}>\n    </bim-text-input>\n    `;\n  });\n\n  // We\'ll define a function to get a list of items to select\n\n  const updateItemIds = async (category: string | undefined) => {\n    const children = [...itemIdsDropdownContainer.children];\n    for (const child of children) {\n      child.remove();\n    }\n\n    const itemIdsDropdown = BUI.Component.create<BUI.PanelSection>(() => {\n      return BUI.html`\n      <bim-dropdown label="Select items" multiple @change=${(e: any) => {\n        if (!editor.currentRelation) return;\n        editor.currentRelation.ids = e.target.value as number[];\n      }}>\n      </bim-dropdown>\n      `;\n    });\n\n    itemIdsDropdownContainer.appendChild(itemIdsDropdown);\n\n    if (!category) {\n      return;\n    }\n\n    const regexp = new RegExp(category);\n    const itemIdsByCategory = await model.getItemsOfCategories([regexp]);\n\n    for (const categoryName in itemIdsByCategory) {\n      const itemIds = itemIdsByCategory[categoryName];\n      for (const itemId of itemIds) {\n        const itemIdOption = BUI.Component.create<BUI.Option>(() => {\n          return BUI.html`\n          <bim-option value=${itemId} label=${itemId}></bim-option>\n          `;\n        });\n        itemIdsDropdown.appendChild(itemIdOption);\n      }\n    }\n  };\n\n  // And now we\'ll create the dropdown to select the category of the item to relate\n\n  const categoriesDropdown = BUI.Component.create<BUI.Dropdown>(() => {\n    return BUI.html`\n        <bim-dropdown label="Select category" @change=${(e: any) => {\n          if (e.target.value[0]) {\n            updateItemIds(e.target.value[0]);\n          }\n        }}>\n        ${editor.allCategories.map((category) => {\n          return BUI.html`<bim-option value=${category} label=${category}></bim-option>`;\n        })}\n        </bim-dropdown>\n    `;\n  });\n\n  // Now, when closing the modal, we\'ll reset the data\n\n  onCloseAddItemModal.reset();\n  onCloseAddRelationModal.add(() => {\n    categoriesDropdown.value = [];\n    updateAddRelationModal();\n  });\n\n  // And now we\'ll return the HTML for the modal itself\n\n  return BUI.html`\n    <dialog class="blurred-dialog">\n     <bim-panel style="border-radius: var(--bim-ui_size-base); width: 22rem;">\n      <bim-panel-section fixed label="Add new relation">\n        ${relationNameInput}\n        ${categoriesDropdown}\n        ${itemIdsDropdownContainer}\n        <bim-button label="Create relation" @click=${() => {\n          if (editor.currentElement && editor.currentRelation) {\n            editor.elementConfig.data.relations[editor.currentRelation.name] = {\n              attributes: true,\n              relations: true,\n            };\n            editor.relate().then(() => {\n              addRelationModal.close();\n            });\n          }\n        }}></bim-button>\n      </bim-panel-section>\n     </bim-panel> \n    </dialog>\n  `;\n}, {});\n\n// Now, let\'s add the modal to the app and set up some last events\n\ndocument.body.appendChild(addRelationModal);\n\naddRelationModal.addEventListener("close", () => {\n  onCloseAddRelationModal.trigger();\n});\n'})}),"\n",(0,r.jsx)(n.p,{children:"And now, we can finally define the properties table"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'propertiesTable.dataTransform = {\n  Name: (value: any, row: Partial<TableData>) => {\n    if (!row.Name || row.Name[0] === "_") {\n      return value;\n    }\n\n    if (row.Type === "relation") {\n      return BUI.html`\n        <div style="display: flex; align-items: center; gap: 0.5rem;">\n          <bim-label>${value}</bim-label>\n          <bim-button icon="ic:baseline-plus" style="border: 1px solid var(--bim-ui_main-base); transform: scale(0.8);" @click=${() => {\n            // Add existing item to relation\n            editor.currentRelation = {\n              id: row.LocalId as number,\n              name: value,\n              ids: [],\n            };\n            addItemModal.showModal();\n          }}></bim-button>\n        </div>\n      `;\n    }\n\n    if (row.Type === "related") {\n      return BUI.html`\n        <div style="display: flex; align-items: center;">\n          <bim-label>${value}</bim-label>\n          ${\n            row.ParentLocalId !== undefined\n              ? BUI.html`<bim-button icon="ic:baseline-close" style="transform: scale(0.8);" @click=${() => {\n                  // Remove this item from relation\n                  if (editor.currentElement) {\n                    editor.currentRelation = {\n                      id: row.ParentLocalId as number,\n                      name: row.ParentName as string,\n                      ids: [row.LocalId as number],\n                    };\n                    editor.unrelate();\n                  }\n                }}></bim-button>\n\n                <bim-button icon="material-symbols:delete" style="transform: scale(0.8);" @click=${() => {\n                  // Remove this item entirely\n                  if (editor.currentElement) {\n                    editor.deleteItem(row.LocalId as number);\n                  }\n                }}></bim-button>\n              `\n              : ""\n          }\n\n          <bim-button icon="flowbite:paper-clip-outline" style="transform: scale(0.8);" @click=${() => {\n            // Add new relation\n            if (editor.currentElement) {\n              editor.currentRelation = {\n                id: row.LocalId as number,\n                name: value,\n                ids: [],\n              };\n              addRelationModal.showModal();\n            }\n          }}></bim-button>\n          \n        </div>\n      `;\n    }\n\n    return value;\n  },\n  Value: (value: any, row: Partial<TableData>) => {\n    if (!row.Name || row.Name[0] === "_") {\n      return value;\n    }\n\n    if (typeof value === "string") {\n      return BUI.html`<bim-text-input value=${value} @input=${(e: any) => {\n        editor.updateAttribute(row, e);\n      }}></bim-text-input>`;\n    }\n\n    if (typeof value === "number") {\n      return BUI.html`<bim-number-input value=${value} @change=${(e: any) => {\n        editor.updateAttribute(row, e);\n      }}></bim-number-input>`;\n    }\n\n    return BUI.html`<bim-checkbox ?checked=${value} @change=${(e: any) => {\n      editor.updateAttribute(row, e);\n    }}></bim-checkbox>`;\n  },\n};\n'})}),"\n",(0,r.jsx)(n.p,{children:"Next, let's create a function to export the edited model."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'const exportModel = async () => {\n  await fragments.editor.save(model.modelId);\n  window.setTimeout(async () => {\n    const exportedBuffer = await model.getBuffer();\n    const exportedBytes = new Uint8Array(exportedBuffer);\n    const exportedBlob = new Blob([exportedBytes]);\n    const exportedUrl = URL.createObjectURL(exportedBlob);\n    const exportedLink = document.createElement("a");\n    exportedLink.href = exportedUrl;\n    exportedLink.download = "exported.frag";\n    document.body.appendChild(exportedLink);\n    exportedLink.click();\n    document.body.removeChild(exportedLink);\n    URL.revokeObjectURL(exportedUrl);\n  }, 1000);\n};\n'})}),"\n",(0,r.jsx)(n.p,{children:"Let's define the last pieces of UI and put them all together."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'const updateTableButton = BUI.Component.create<BUI.Button>(() => {\n  return BUI.html`\n    <bim-button label="Apply changes" @click=${() => {\n      editor.applyChanges();\n    }}></bim-button>\n  `;\n});\n\neditor.onPropertiesUpdated.add((data) => {\n  propertiesTable.data = data;\n  const tableVisible = propertiesTable.data.length > 0;\n  updateTableButton.style.display = tableVisible ? "block" : "none";\n});\n\nconst [panel] = BUI.Component.create<BUI.PanelSection, any>((_) => {\n  return BUI.html`\n    <bim-panel style="min-width: 25rem;" id="controls-panel" active label="Element Editor" class="options-menu">\n      <bim-panel-section label="Controls">\n      <bim-button label="Save" @click=${exportModel}></bim-button>\n      <bim-button label="Create new item" @click=${() => {\n        createItemModal.showModal();\n      }}></bim-button>\n      ${updateTableButton}\n        ${propertiesTable}\n      </bim-panel-section>\n    </bim-panel>\n  `;\n}, {});\n\ndocument.body.append(panel);\n'})}),"\n",(0,r.jsx)(n.p,{children:"And we will make some logic that adds a button to the screen when the user is visiting our app from their phone, allowing to show or hide the menu. Otherwise, the menu would make the app unusable."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'const button = BUI.Component.create<BUI.PanelSection>(() => {\n  const onClick = () => {\n    if (panel.classList.contains("options-menu-visible")) {\n      panel.classList.remove("options-menu-visible");\n    } else {\n      panel.classList.add("options-menu-visible");\n    }\n  };\n\n  return BUI.html`\n    <bim-button class="phone-menu-toggler" icon="solar:settings-bold"\n      @click=${onClick}>\n    </bim-button>\n  `;\n});\n\ndocument.body.append(button);\n'})}),"\n",(0,r.jsx)(n.h3,{id:"\ufe0f-measuring-the-performance-optional",children:"\u23f1\ufe0f Measuring the performance (optional)"}),"\n",(0,r.jsxs)(n.p,{children:["We'll use the ",(0,r.jsx)(n.a,{href:"https://github.com/mrdoob/stats.js",children:"Stats.js"})," to measure the performance of our app. We will add it to the top left corner of the viewport. This way, we'll make sure that the memory consumption and the FPS of our app are under control."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'const stats = new Stats();\nstats.showPanel(2);\ndocument.body.append(stats.dom);\nstats.dom.style.left = "0px";\nstats.dom.style.zIndex = "unset";\nworld.renderer.onBeforeUpdate.add(() => stats.begin());\nworld.renderer.onAfterUpdate.add(() => stats.end());\n'})}),"\n",(0,r.jsx)(n.h3,{id:"-congratulations",children:"\ud83c\udf89 Congratulations!"}),"\n",(0,r.jsx)(n.p,{children:"You've successfully learned how to edit delete and create BIM properties using the Fragments Properties API! \ud83d\ude80"})]})}function m(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>l});var r=t(6540);const a={},o=r.createContext(a);function i(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);