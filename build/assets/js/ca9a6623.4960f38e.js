"use strict";(self.webpackChunkengine_docs=self.webpackChunkengine_docs||[]).push([[4280],{2348:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>l,default:()=>c,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var s=t(4848),a=t(8453);const o={},l=void 0,r={id:"Tutorials/Fragments/Fragments/FragmentsModels/EditElements",title:"EditElements",description:'window.open("https://thatopen.github.io/engine_fragment/examples/FragmentsModels/EditElements")} >Go Full Screen',source:"@site/docs/Tutorials/Fragments/Fragments/FragmentsModels/EditElements.mdx",sourceDirName:"Tutorials/Fragments/Fragments/FragmentsModels",slug:"/Tutorials/Fragments/Fragments/FragmentsModels/EditElements",permalink:"/Tutorials/Fragments/Fragments/FragmentsModels/EditElements",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"EditApi",permalink:"/Tutorials/Fragments/Fragments/FragmentsModels/EditApi"},next:{title:"EditProperties",permalink:"/Tutorials/Fragments/Fragments/FragmentsModels/EditProperties"}},i={},d=[{value:"Editing BIM Elements \ud83e\ude91",id:"editing-bim-elements-",level:2},{value:"\ud83d\udd96 Importing our Libraries",id:"-importing-our-libraries",level:3},{value:"\ud83c\udf0e Setting up a Simple Scene",id:"-setting-up-a-simple-scene",level:3},{value:"\ud83d\udee0\ufe0f Setting Up Fragments",id:"\ufe0f-setting-up-fragments",level:3},{value:"\ud83d\udcc2 Loading a Fragments Model",id:"-loading-a-fragments-model",level:3},{value:"\u270f\ufe0f Setting up the model editor",id:"\ufe0f-setting-up-the-model-editor",level:3},{value:"\ud83e\udde9 Adding User Interface (optional)",id:"-adding-user-interface-optional",level:3},{value:"\u23f1\ufe0f Measuring the performance (optional)",id:"\ufe0f-measuring-the-performance-optional",level:3},{value:"\ud83c\udf89 Congratulations!",id:"-congratulations",level:3}];function m(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",hr:"hr",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)("div",{style:{position:"relative"},children:[(0,s.jsx)("iframe",{src:"https://thatopen.github.io/engine_fragment/examples/FragmentsModels/EditElements"}),(0,s.jsx)("button",{class:"full-screen-btn",onClick:()=>window.open("https://thatopen.github.io/engine_fragment/examples/FragmentsModels/EditElements"),children:"Go Full Screen"})]}),"\n",(0,s.jsx)(n.admonition,{title:"Source",type:"info",children:(0,s.jsxs)(n.p,{children:["Copying and pasting? We've got you covered! You can find the full source code of this tutorial ",(0,s.jsx)(n.a,{href:"https://github.com/ThatOpen/engine_fragment/blob/main/packages/fragments/src/FragmentsModels/examples/EditElements/example.ts",children:"here"}),"."]})}),"\n",(0,s.jsx)(n.h2,{id:"editing-bim-elements-",children:"Editing BIM Elements \ud83e\ude91"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"In this tutorial, we'll explore how to easily edit BIM elements using the Fragments Edit API. We will move things around, change its materials, edit its instance attributes, register everything in a history that we can revert and more. Let\u2019s dive in!"}),"\n",(0,s.jsx)(n.h3,{id:"-importing-our-libraries",children:"\ud83d\udd96 Importing our Libraries"}),"\n",(0,s.jsx)(n.p,{children:"First things first, let's install all necessary dependencies to make this example work:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'import * as OBC from "@thatopen/components";\nimport Stats from "stats.js";\nimport * as THREE from "three";\nimport * as BUI from "@thatopen/ui";\nimport { TransformControls } from "three/examples/jsm/controls/TransformControls.js";\n// You have to import * as FRAGS from "@thatopen/fragments"\nimport * as FRAGS from "../../../index";\n'})}),"\n",(0,s.jsx)(n.h3,{id:"-setting-up-a-simple-scene",children:"\ud83c\udf0e Setting up a Simple Scene"}),"\n",(0,s.jsx)(n.p,{children:"To get started, let's set up a basic ThreeJS scene. This will serve as the foundation for our application and allow us to visualize the 3D models effectively:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const components = new OBC.Components();\nconst worlds = components.get(OBC.Worlds);\nconst container = document.getElementById("container") as HTMLDivElement;\n\nconst world = worlds.create<\n  OBC.ShadowedScene,\n  OBC.OrthoPerspectiveCamera,\n  OBC.SimpleRenderer\n>();\n\nworld.scene = new OBC.ShadowedScene(components);\nworld.renderer = new OBC.SimpleRenderer(components, container);\nworld.camera = new OBC.OrthoPerspectiveCamera(components);\n\ncomponents.init();\n\nworld.scene.three.add(new THREE.AxesHelper());\n\nworld.camera.three.far = 10000;\n\nworld.renderer.three.shadowMap.enabled = true;\nworld.renderer.three.shadowMap.type = THREE.PCFSoftShadowMap;\n\nworld.scene.setup({\n  shadows: {\n    cascade: 1,\n    resolution: 1024,\n  },\n});\n\nawait world.scene.updateShadows();\n\nworld.camera.controls.addEventListener("rest", async () => {\n  await world.scene.updateShadows();\n});\n'})}),"\n",(0,s.jsx)(n.admonition,{title:"Do I need @thatopen/components?",type:"info",children:(0,s.jsx)(n.p,{children:"Not necessarily! While @thatopen/components simplifies the process of setting up a scene, you can always use plain ThreeJS to create your own custom scene setup. It's entirely up to your preference and project requirements! \ud83d\ude09"})}),"\n",(0,s.jsx)(n.h3,{id:"\ufe0f-setting-up-fragments",children:"\ud83d\udee0\ufe0f Setting Up Fragments"}),"\n",(0,s.jsx)(n.p,{children:"Now, let's configure the Fragments library core. This will allow us to load models effortlessly and start manipulating them with ease:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'// You have to copy `/node_modules/@thatopen/fragments/dist/Worker/worker.mjs` to your project directory\n// and provide the relative path in `workerUrl`\n// We use here the internal route of the worker in the library for simplicity purposes\nconst workerUrl = "https://thatopen.github.io/engine_fragment/resources/worker.mjs";\nconst fragments = new FRAGS.FragmentsModels(workerUrl);\nworld.camera.controls.addEventListener("control", () => fragments.update());\n\n// Once a model is available in the list, we can tell what camera to use\n// in order to perform the culling and LOD operations.\n// Also, we add the model to the 3D scene.\nfragments.models.list.onItemSet.add(({ value: model }) => {\n  model.useCamera(world.camera.three);\n  world.scene.three.add(model.object);\n  // At the end, you tell fragments to update so the model can be seen given\n  // the initial camera position\n\n  // We will also set up the shadows of all the loaded models here\n  model.tiles.onItemSet.add(({ value: mesh }) => {\n    if ("isMesh" in mesh) {\n      const mat = mesh.material as THREE.MeshStandardMaterial[];\n      if (mat[0].opacity === 1) {\n        mesh.castShadow = true;\n        mesh.receiveShadow = true;\n      }\n    }\n  });\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"-loading-a-fragments-model",children:"\ud83d\udcc2 Loading a Fragments Model"}),"\n",(0,s.jsx)(n.p,{children:"With the core setup complete, it's time to load a Fragments model into our scene. Fragments are optimized for fast loading and rendering, making them ideal for large-scale 3D models."}),"\n",(0,s.jsx)(n.admonition,{title:"Where can I find Fragment files?",type:"info",children:(0,s.jsx)(n.p,{children:"You can use the sample Fragment files available in our repository for testing. If you have an IFC model you'd like to convert to Fragments, check out the IfcImporter tutorial for detailed instructions."})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const fetched = await fetch("https://thatopen.github.io/engine_fragment/resources/frags/school_arq.frag");\nconst buffer = await fetched.arrayBuffer();\nconst model = await fragments.load(buffer, {\n  modelId: "medium_test",\n  camera: world.camera.three,\n});\n\nworld.scene.three.add(model.object);\nawait fragments.update(true);\n'})}),"\n",(0,s.jsx)(n.h3,{id:"\ufe0f-setting-up-the-model-editor",children:"\u270f\ufe0f Setting up the model editor"}),"\n",(0,s.jsx)(n.p,{children:"Now we'll set up all the logic to edit it. We will use the Elements API, which allows you to work directly with three.js objects (Meshes, Geometries, Materials, etc.) and then apply the changes directly to the fragments model. This makes it a lot easier to build an app that can edit / author fragments."}),"\n",(0,s.jsx)(n.admonition,{title:"How to edit the model?",type:"info",children:(0,s.jsx)(n.p,{children:'When building an authoring app, objects could be edited in many ways: from just moving them and changing their material, to smart logic specific to their geometry (e.g. revit system families). For that reason, it\'s better to encapsulate the edit logic in a class that defines HOW we want to edit the elements. That way we can build multiple "editors" that we can use across our app.'})}),"\n",(0,s.jsx)(n.p,{children:"In this tutorial, we'll create a general Editor that can edit the global and local transform of an element, edit the geometry of an element, edit the materials (color and opacity) of an element and edit the samples (geometry, material and local transform) of an element."}),"\n",(0,s.jsx)(n.admonition,{title:"Before we start",type:"warning",children:(0,s.jsx)(n.p,{children:"Before we start, here's the key things you need to know about elements. Each element has a global transform and is made by samples (instances). Each sample is made by a geometry, a material and a local transform. Samples can share the same geometry, material and local transform. This last point is important because it means that when we edit a material, geometry or local transform, it can affect multiple samples."})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'class GeneralEditor {\n  // We\'ll start by creating 2 events that will be useful for UI updates\n  readonly onUpdated = new OBC.Event<void>();\n  readonly sampleMaterialsUpdated = new OBC.Event<void>();\n\n  // We\'ll need a reference to the currently used world\n  private _world: OBC.World;\n\n  // This is the current element that we are editing\n  private _element: FRAGS.Element | null = null;\n\n  // This is the current three.js mesh that we will use to make edits to the selected element\n  private _mesh: THREE.Group | null = null;\n\n  // These are the global and local transform controls that we will use to edit the selected element\n  private _gControls: TransformControls;\n  private _lControls: TransformControls[] = [];\n\n  // This is the transform that we will be editing: global or local\n  private _controlType: "global" | "local" = "global";\n\n  // Here we will store a list of materials, local transformsIds and geometries ids\n  // We will use it to allow the user to change the material, local transform or geometry of a sample\n  // The reason why we store the whole material and not only the ID is to display its color in the select menu\n  private _materials: Map<number, FRAGS.RawMaterial> | null = null;\n  private _localTransformsIds: number[] = [];\n  private _geometriesIds: number[] = [];\n\n  // We need to get the materials, local transforms and geometries asynchronously, so we can\'t get them\n  // in the constructor. We need to wait for the model to be initialized first. So we will define getters\n  // that will throw an error if the model is not initialized yet.\n\n  get materials() {\n    if (!this._materials) {\n      throw new Error("Editor not initialized");\n    }\n    return this._materials;\n  }\n\n  get localTransformsIds() {\n    if (!this._localTransformsIds.length) {\n      throw new Error("Editor not initialized");\n    }\n    return this._localTransformsIds;\n  }\n\n  get geometriesIds() {\n    if (!this._geometriesIds.length) {\n      throw new Error("Editor not initialized");\n    }\n    return this._geometriesIds;\n  }\n\n  // We will also define a getter to expose the samples of the selected element,\n  // which will be used for the UI to edit them.\n\n  get samples() {\n    if (!this._element) {\n      throw new Error("No element selected");\n    }\n    return this._element.core.samples;\n  }\n\n  // We will also define a getter to check if an element is currently selected\n\n  get elementSelected() {\n    return this._element !== null;\n  }\n\n  // In the constructor we\'ll simply set up the basic elements and events\n\n  constructor(world: OBC.World) {\n    this._world = world;\n    this._gControls = new TransformControls(\n      world.camera.three,\n      world.renderer!.three.domElement!,\n    );\n    this.setupEvents();\n  }\n\n  // We will also define a method to initialize the editor.\n  // This will be used to fetch all data necessary to build the UI.\n  // We don\'t do this in the constructor because it\'s async.\n\n  async init() {\n    this._materials = await model.getMaterials();\n    const allLtIds = await model.getLocalTransformsIds();\n    const allGeomsIds = await model.getRepresentationsIds();\n    this._localTransformsIds = [allLtIds[0], allLtIds[1]];\n    this._geometriesIds = [allGeomsIds[0], allGeomsIds[1]];\n  }\n\n  // This method will return the list of Threejs materials\n  // used by the currently selected element.\n\n  get3dMaterials() {\n    if (!this._mesh) {\n      return [];\n    }\n    const materialList = new Map<string, THREE.MeshLambertMaterial>();\n\n    this._mesh.traverse((object) => {\n      if (object instanceof THREE.Mesh) {\n        materialList.set(\n          object.material.userData.localId,\n          object.material as THREE.MeshLambertMaterial,\n        );\n      }\n    });\n\n    return Array.from(materialList.values());\n  }\n\n  // Now we\'ll define a method that allows to change the material of a sample\n\n  async setSampleMaterial(id: number, material: number) {\n    if (!this._element) {\n      return;\n    }\n    this._element.core.samples[id].material = material;\n    await this.updateSamples();\n    this.sampleMaterialsUpdated.trigger();\n  }\n\n  // Now we\'ll define a method that will update the materials list.\n  // This is needed to update the UI material color when a material was edited\n\n  async updateMaterials() {\n    if (!this._materials) {\n      return;\n    }\n    this._materials = await model.getMaterials();\n  }\n\n  // This method illustrates how to override the geometry of a sample\n  // This is useful for building editors that rely on our geometry engine\n  // (e.g. to build something similar to Revit Wall System Family)\n\n  overrideGeometryWithCube() {\n    if (!this._mesh) {\n      return;\n    }\n    this._mesh.traverse((object) => {\n      if (object instanceof THREE.Mesh) {\n        const geometry = object.geometry as THREE.BufferGeometry;\n        const boxGeometry = new THREE.BoxGeometry(1, 1, 1);\n        geometry.setAttribute("position", boxGeometry.attributes.position);\n        geometry.setIndex(boxGeometry.index);\n        geometry.setAttribute("normal", boxGeometry.attributes.normal);\n      }\n    });\n  }\n\n  // This method will apply the changes to the selected element\n  // Then it will unselect it\n\n  async applyChanges() {\n    if (!this._element || !this._mesh) {\n      return;\n    }\n\n    // This generates the requests to apply the changes to the selected mesh\n    await this._element.setMeshes(this._mesh);\n\n    // This unselects the element and disposes everything related to it\n    this.dispose();\n\n    // This applies the generated changes to Fragments\n    const requests = this._element.getRequests();\n    if (requests) {\n      await fragments.editor.edit(model.modelId, requests);\n    }\n\n    // If no changes were made, we show the hidden items\n    if (!this._element.elementChanged) {\n      // No changes: show hidden items\n      await this.setVisible(true);\n    }\n\n    // This updates the viewer to see the changes\n    await fragments.update(true);\n\n    // This resets the element and mesh variables\n    this._element = null;\n    this._mesh = null;\n\n    // This triggers the UI update\n    this.onUpdated.trigger();\n  }\n\n  // This method will set the mode of the global and local transform controls\n  // Fragments only support translate and rotate\n\n  setControlsMode(mode: "translate" | "rotate") {\n    this._gControls.setMode(mode);\n    for (const localTransformControl of this._lControls) {\n      localTransformControl.setMode(mode);\n    }\n  }\n\n  // This method allows to change between local and global transform controls\n\n  setControlsTarget(target = this._controlType) {\n    const globalGizmo = this._gControls.getHelper();\n    if (target === "global") {\n      this._world.scene.three.add(globalGizmo);\n      this._gControls.enabled = true;\n      for (const localTransformControl of this._lControls) {\n        const localGizmo = localTransformControl.getHelper();\n        localGizmo.removeFromParent();\n        localTransformControl.enabled = false;\n      }\n    } else {\n      globalGizmo.removeFromParent();\n      this._gControls.enabled = false;\n      for (const localTransformControl of this._lControls) {\n        const localGizmo = localTransformControl.getHelper();\n        this._world.scene.three.add(localGizmo);\n        localTransformControl.enabled = true;\n      }\n    }\n    this._controlType = target;\n  }\n\n  // This method will update the samples of the selected element\n  // as well as regenerate the current mesh while maintaining\n  // the transform controls\n  async updateSamples() {\n    if (!this._element || !this._mesh) {\n      return;\n    }\n    const prevTransform = this._mesh.matrixWorld.clone();\n    await this._element.updateSamples();\n    this.dispose();\n\n    this._mesh = await this._element.getMeshes();\n    this._world.scene.three.add(this._mesh);\n    await this.createControls();\n    this._mesh.position.set(0, 0, 0);\n    this._mesh.rotation.set(0, 0, 0);\n    this._mesh.applyMatrix4(prevTransform);\n  }\n\n  // Here we\'ll create the Three.js TransformControls\n  // for global and local transforms\n\n  private async createControls() {\n    if (!this._mesh) {\n      return;\n    }\n\n    this._gControls.attach(this._mesh);\n\n    for (const localMesh of this._mesh.children) {\n      const localTransformControl = new TransformControls(\n        world.camera.three,\n        world.renderer!.three.domElement!,\n      );\n      localTransformControl.attach(localMesh);\n      localTransformControl.setMode(this._gControls.mode);\n      this._lControls.push(localTransformControl);\n      localTransformControl.addEventListener("dragging-changed", (event) => {\n        if (world.camera.hasCameraControls()) {\n          world.camera.controls.enabled = !event.value;\n        }\n      });\n    }\n\n    this.setControlsTarget();\n  }\n\n  // This unselects the current element and disposes the transform controls\n\n  private dispose() {\n    // Dispose meshes\n\n    if (this._mesh && this._element) {\n      this._element.disposeMeshes(this._mesh);\n    }\n    // Dispose global transform controls\n    const globalGizmo = this._gControls.getHelper();\n    globalGizmo.removeFromParent();\n    this._gControls.detach();\n    if (!this._mesh || !this._element) {\n      return;\n    }\n    for (const localTransformControl of this._lControls) {\n      localTransformControl.detach();\n      localTransformControl.dispose();\n    }\n    this._lControls.length = 0;\n  }\n\n  // This is used to control the visibility of the existing / edited objects\n  // When we use the edit API, fragments creates a new Fragments Model called\n  // delta model that contains only the changed objects. This is done to avoid\n  // having to recompute the whole model when only a few objects were changed.\n  // We then hide the edited objects in the original model.\n  // This method manages the visibility both in the original model and in the delta model\n  // making sure the same element is not visible in both models at the same time.\n\n  private async setVisible(visible: boolean) {\n    if (!this._element) {\n      return;\n    }\n    const promises: Promise<void>[] = [];\n    for (const [, model] of fragments.models.list) {\n      if (model.deltaModelId) {\n        if (visible === true) {\n          const editedElements = new Set(await model.getEditedElements());\n          if (visible && editedElements.has(this._element.localId)) {\n            continue;\n          }\n        }\n      }\n\n      promises.push(model.setVisible([this._element.localId], visible));\n    }\n    await Promise.all(promises);\n  }\n\n  // Here we\'ll setup the events for the global transform controls\n  // as well as the double click and keydown events\n  private setupEvents() {\n    // Prevent camera move when using the global transform controls\n    this._gControls.addEventListener("dragging-changed", (event) => {\n      if (this._world.camera.hasCameraControls()) {\n        this._world.camera.controls.enabled = !event.value;\n      }\n    });\n\n    // Double click event logic to select an element\n    const mouse = new THREE.Vector2();\n    const canvas = this._world.renderer!.three.domElement!;\n    canvas.addEventListener("dblclick", async (event) => {\n      mouse.x = event.clientX;\n      mouse.y = event.clientY;\n      let result: any;\n\n      // Raycast all models, including delta models\n      for (const [, model] of fragments.models.list) {\n        const promises: Promise<FRAGS.RaycastResult | null>[] = [];\n        promises.push(\n          model.raycast({\n            camera: world.camera.three,\n            mouse,\n            dom: world.renderer!.three.domElement!,\n          }),\n        );\n        const results = await Promise.all(promises);\n        let smallestDistance = Infinity;\n        for (const current of results) {\n          if (current) {\n            if (current.distance < smallestDistance) {\n              smallestDistance = current.distance;\n              result = current;\n            }\n          }\n        }\n      }\n\n      // If nothing is found, return\n      if (!result) {\n        return;\n      }\n\n      // If an element was already selected, reset the visibility\n      if (this._element) {\n        await this.setVisible(true);\n      }\n\n      // Get the selected element\n      const [element] = await fragments.editor.getElements(model.modelId, [\n        result.localId,\n      ]);\n      this._element = element;\n      if (!element) {\n        return;\n      }\n\n      // Dispose the previous mesh, if any\n      if (this._mesh) {\n        this.dispose();\n      }\n\n      // Set the visibility of the selected elements to false in the original model\n      await this.setVisible(false);\n\n      // Add the selected meshes to the scene and add the transform controls\n      this._mesh = await element.getMeshes();\n      this._world.scene.three.add(this._mesh);\n      await this.createControls();\n\n      // Update the viewer to see the changes\n      await fragments.update(true);\n\n      // Trigger the UI update\n      this.onUpdated.trigger();\n    });\n\n    // Keydown event logic to cancel the edit when pressing the escape key\n\n    window.addEventListener("keydown", async (event) => {\n      if (event.key === "Escape") {\n        if (!this._element || !this._mesh) {\n          return;\n        }\n\n        // Clear the existing edit requests\n        this._element.getRequests();\n        this.dispose();\n\n        // All canceled: show hidden items\n        this.setVisible(true);\n\n        // Update the viewer to see the changes\n        await fragments.update(true);\n\n        // Reset the element and mesh variables\n        this._element = null;\n        this._mesh = null;\n\n        // Trigger the UI update\n        this.onUpdated.trigger();\n      }\n    });\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Great! Now we just need to instantiate and initialize the editor we just built, and we'll be ready to start editing the model."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const generalEditor = new GeneralEditor(world);\nawait generalEditor.init();\n"})}),"\n",(0,s.jsx)(n.h3,{id:"-adding-user-interface-optional",children:"\ud83e\udde9 Adding User Interface (optional)"}),"\n",(0,s.jsxs)(n.p,{children:["We will use the ",(0,s.jsx)(n.code,{children:"@thatopen/ui"})," library to add some simple and cool UI elements to our app. First, we need to call the ",(0,s.jsx)(n.code,{children:"init"})," method of the ",(0,s.jsx)(n.code,{children:"BUI.Manager"})," class to initialize the library:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"BUI.Manager.init();\n"})}),"\n",(0,s.jsx)(n.p,{children:"Now we will create various UI elements to use the logic of the editor we just made. We will start by defining a panel to edit the samples of the selected element."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const [samplesPanel, updateSamplesPanel] = BUI.Component.create<\n  BUI.PanelSection,\n  any\n>((_) => {\n  const tempColor = new THREE.Color();\n\n  const samplesMenus: BUI.PanelSection[] = [];\n\n  if (generalEditor.elementSelected) {\n    const samples = generalEditor.samples;\n    for (const id in samples) {\n      const sample = samples[id];\n\n      const materialMenu = BUI.Component.create<BUI.PanelSection>(() => {\n        return BUI.html`\n             <bim-dropdown label="Material" @change=${async (e: any) => {\n               if (!e.target.value[0]) return;\n               const idNum = parseInt(id, 10);\n               await generalEditor.setSampleMaterial(idNum, e.target.value[0]);\n             }}>\n            </bim-dropdown>\n        `;\n      });\n\n      generalEditor.updateMaterials().then(() => {\n        for (const [materialId, material] of generalEditor.materials) {\n          const { r, g, b } = material;\n          tempColor.setRGB(r / 255, g / 255, b / 255);\n          const colorString = `#${tempColor.getHexString()}`;\n          const option = BUI.Component.create<BUI.PanelSection>(() => {\n            return BUI.html`<bim-option icon="icon-park-outline:material" label=${materialId} ?checked=${sample.material === materialId}>\n            <div style="width: 1rem; height: 1rem; background-color: ${colorString}"></div>\n          </bim-option>`;\n          });\n          materialMenu.appendChild(option);\n        }\n      });\n\n      const sampleMenu = BUI.Component.create<BUI.PanelSection>(() => {\n        return BUI.html`\n          <div style="display: flex; gap: 0.5rem; flex-direction: column;">\n\n            <div style="display: flex; gap: 0.5rem;">\n              <bim-label icon="f7:cube" style="font-weight: bold;">Sample ${id}</bim-label>\n            </div>\n\n            ${materialMenu}\n\n            <bim-dropdown label="Local Transform" @change=${async (e: any) => {\n              if (!e.target.value[0]) return;\n              const sample = samples[id];\n              if (!sample) return;\n              sample.localTransform = e.target.value[0];\n              await generalEditor.updateSamples();\n            }}>\n\n              ${[\n                ...new Set([\n                  ...generalEditor.localTransformsIds,\n                  sample.localTransform,\n                ]),\n              ].map((ltId) => {\n                return BUI.html`<bim-option icon="iconoir:axes" label=${ltId} ?checked=${sample.localTransform === ltId}>\n                </bim-option>`;\n              })}\n            </bim-dropdown>\n\n            <bim-dropdown label="Geometry" @change=${async (e: any) => {\n              if (!e.target.value[0]) return;\n              const sample = samples[id];\n              if (!sample) return;\n              sample.representation = e.target.value[0];\n              await generalEditor.updateSamples();\n            }}>\n\n              ${[\n                ...new Set([\n                  ...generalEditor.geometriesIds,\n                  sample.representation,\n                ]),\n              ].map((geometryId) => {\n                return BUI.html`<bim-option icon="fluent:select-object-24-filled" label=${geometryId} ?checked=${sample.representation === geometryId}>\n                </bim-option>`;\n              })}\n            </bim-dropdown>\n          </div>\n          `;\n      });\n      samplesMenus.push(sampleMenu);\n    }\n  }\n\n  return BUI.html`<bim-panel-section label="Samples">\n  ${samplesMenus.map((menu) => menu)}\n  </bim-panel-section>`;\n}, {});\n'})}),"\n",(0,s.jsx)(n.p,{children:"Now we will create another panel to edit the materials of the selected element."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const [matsPanel, updateMatsPanel] = BUI.Component.create<\n  BUI.PanelSection,\n  any\n>((_) => {\n  const materials = generalEditor.get3dMaterials();\n\n  return BUI.html`\n    <div style="display: flex; flex-direction: column; gap: 0.5rem;">\n        ${materials.map(\n          (material) =>\n            BUI.html`\n\n          <div style="display: flex; gap: 0.5rem;">\n          <bim-color-input color=#${material.color.getHexString()} label=${material.userData.localId} @input=${(\n            e: any,\n          ) => {\n            material.color.set(e.target.color);\n          }}>\n          </bim-color-input>\n\n          <bim-number-input slider min=0 max=1 step=0.01 value=${material.opacity} @change=${(\n            e: any,\n          ) => {\n            material.opacity = e.target.value;\n          }}></bim-number-input>\n\n          </div>`,\n        )}\n        </div>\n  `;\n}, {});\n\ngeneralEditor.sampleMaterialsUpdated.add(updateMatsPanel);\n'})}),"\n",(0,s.jsx)(n.p,{children:"And finally, we will create a panel to show the history of the edits made to the model so that we can also revert them."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const historyMenu = document.getElementById("history-menu") as HTMLDivElement;\n\nlet selectedRequestIndex: number | null = null;\n\nconst updateHistoryMenu = async () => {\n  const { requests, undoneRequests } = await fragments.editor.getModelRequests(\n    model.modelId,\n  );\n\n  const allRequests = [...requests, ...undoneRequests];\n\n  historyMenu.innerHTML = "";\n\n  let selectedButton: BUI.Button | null = null;\n\n  for (let i = 0; i < allRequests.length; i++) {\n    const request = allRequests[i];\n\n    const nextExists = i < allRequests.length - 1;\n\n    const requestButton = BUI.Component.create<BUI.Button>(() => {\n      return BUI.html`\n        <bim-button icon="solar:arrow-right-bold"></bim-button>\n      `;\n    });\n\n    const isSelected = selectedRequestIndex === i;\n    const noSelectionAndIsLast = selectedRequestIndex === null && !nextExists;\n    if (isSelected || noSelectionAndIsLast) {\n      requestButton.classList.add("selected-request");\n      selectedButton = requestButton;\n    }\n\n    const currentIndex = i;\n    // eslint-disable-next-line no-loop-func\n    requestButton.addEventListener("click", async () => {\n      if (selectedButton) {\n        selectedButton.classList.remove("selected-request");\n      }\n      selectedButton = requestButton;\n      requestButton.classList.add("selected-request");\n      await fragments.editor.selectRequest(model.modelId, currentIndex);\n      await model.setVisible(undefined, true);\n      selectedRequestIndex = currentIndex;\n      await fragments.editor.edit(model.modelId, [], {\n        removeRedo: false,\n      });\n      await fragments.update(true);\n    });\n\n    const requestMenu = BUI.Component.create<BUI.PanelSection>(() => {\n      return BUI.html`\n      <div class="history-request">\n        ${nextExists ? BUI.html`<div class="history-line"></div>` : ""}\n        ${requestButton}\n        <div>\n          <bim-label class="history-request-title">${FRAGS.EditRequestTypeNames[request.type]}</bim-label>\n          <bim-label class="history-request-subtitle">ID: ${request.localId}</bim-label>\n        </div>\n      </div>\n      `;\n    });\n\n    historyMenu.appendChild(requestMenu);\n  }\n\n  selectedRequestIndex = null;\n};\n\nfragments.editor.onEdit.add(updateHistoryMenu);\n'})}),"\n",(0,s.jsx)(n.p,{children:"Now, let's put all the UI elemnets together:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const [panel, updatePanel] = BUI.Component.create<BUI.PanelSection, any>(\n  (_) => {\n    const geometryButton = BUI.html`<bim-button label="Change geometry" @click=${() => {\n      generalEditor.overrideGeometryWithCube();\n    }}></bim-button>`;\n    updateSamplesPanel();\n    updateMatsPanel();\n\n    return BUI.html`\n    <bim-panel style="min-width: 25rem;" id="controls-panel" active label="Element Editor" class="options-menu">\n      <bim-panel-section label="Controls">\n        <bim-button data-name="arq" label="Apply changes" @click=${() => generalEditor.applyChanges()}></bim-button>\n        <bim-dropdown required label="Tranform Mode" \n            @change="${({ target }: { target: BUI.Dropdown }) => {\n              const selected = target.value[0] as "rotate" | "translate";\n              generalEditor.setControlsMode(selected);\n            }}">\n          <bim-option checked  label="translate"></bim-option>\n          <bim-option label="rotate"></bim-option>\n        </bim-dropdown>\n        <bim-dropdown required label="Transform Target" \n            @change="${({ target }: { target: BUI.Dropdown }) => {\n              const selected = target.value[0] as "global" | "local";\n              generalEditor.setControlsTarget(selected);\n            }}">\n          <bim-option checked  label="global"></bim-option>\n          <bim-option label="local"></bim-option>\n        </bim-dropdown>\n        ${geometryButton}\n        ${matsPanel}\n      </bim-panel-section>\n      ${samplesPanel}\n    </bim-panel>\n  `;\n  },\n  {},\n);\n\ngeneralEditor.onUpdated.add(() => {\n  updatePanel();\n});\n\ndocument.body.append(panel);\n'})}),"\n",(0,s.jsx)(n.p,{children:"And we will make some logic that adds a button to the screen when the user is visiting our app from their phone, allowing to show or hide the menu. Otherwise, the menu would make the app unusable."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const button = BUI.Component.create<BUI.PanelSection>(() => {\n  const onClick = () => {\n    if (panel.classList.contains("options-menu-visible")) {\n      panel.classList.remove("options-menu-visible");\n    } else {\n      panel.classList.add("options-menu-visible");\n    }\n  };\n\n  return BUI.html`\n    <bim-button class="phone-menu-toggler" icon="solar:settings-bold"\n      @click=${onClick}>\n    </bim-button>\n  `;\n});\n\ndocument.body.append(button);\n\nwindow.dispatchEvent(new Event("resize"));\n'})}),"\n",(0,s.jsx)(n.h3,{id:"\ufe0f-measuring-the-performance-optional",children:"\u23f1\ufe0f Measuring the performance (optional)"}),"\n",(0,s.jsxs)(n.p,{children:["We'll use the ",(0,s.jsx)(n.a,{href:"https://github.com/mrdoob/stats.js",children:"Stats.js"})," to measure the performance of our app. We will add it to the top left corner of the viewport. This way, we'll make sure that the memory consumption and the FPS of our app are under control."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const stats = new Stats();\nstats.showPanel(2);\ndocument.body.append(stats.dom);\nstats.dom.style.right = "0px";\nstats.dom.style.bottom = "0px";\nstats.dom.style.left = "unset";\nstats.dom.style.top = "unset";\nstats.dom.style.zIndex = "unset";\nworld.renderer.onBeforeUpdate.add(() => stats.begin());\nworld.renderer.onAfterUpdate.add(() => stats.end());\n'})}),"\n",(0,s.jsx)(n.h3,{id:"-congratulations",children:"\ud83c\udf89 Congratulations!"}),"\n",(0,s.jsx)(n.p,{children:"You've successfully learned how to edit BIM models using the Fragments Elements API! \ud83d\ude80\nNow, you can start building your own authoring app with Fragments! \ud83d\udca1"})]})}function c(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(m,{...e})}):m(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>r});var s=t(6540);const a={},o=s.createContext(a);function l(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);