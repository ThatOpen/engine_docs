"use strict";(self.webpackChunkengine_docs=self.webpackChunkengine_docs||[]).push([[6423],{4263:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>s,metadata:()=>l,toc:()=>r});var o=n(4848),a=n(8453);const s={},i=void 0,l={id:"Tutorials/UserInterface/Core/Component",title:"Component",description:'window.open("https://thatopen.github.io/engine_ui-components/examples/Component")} >Go Full Screen',source:"@site/docs/Tutorials/UserInterface/Core/Component.mdx",sourceDirName:"Tutorials/UserInterface/Core",slug:"/Tutorials/UserInterface/Core/Component",permalink:"/Tutorials/UserInterface/Core/Component",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"UserInterface",permalink:"/Tutorials/UserInterface/"},next:{title:"Table",permalink:"/Tutorials/UserInterface/Core/Table/"}},c={},r=[{value:"Leveling up your app with custom components! \ud83d\udd0c",id:"leveling-up-your-app-with-custom-components-",level:2},{value:"Creating an stateless component",id:"creating-an-stateless-component",level:3},{value:"Creating a statefull component",id:"creating-a-statefull-component",level:3},{value:"Nesting components",id:"nesting-components",level:3}];function h(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)("div",{style:{position:"relative"},children:[(0,o.jsx)("iframe",{src:"https://thatopen.github.io/engine_ui-components/examples/Component"}),(0,o.jsx)("button",{class:"full-screen-btn",onClick:()=>window.open("https://thatopen.github.io/engine_ui-components/examples/Component"),children:"Go Full Screen"})]}),"\n",(0,o.jsx)(t.admonition,{title:"Source",type:"info",children:(0,o.jsxs)(t.p,{children:["Copying and pasting? We've got you covered! You can find the full source code of this tutorial ",(0,o.jsx)(t.a,{href:"https://github.com/ThatOpen/engine_ui-components/blob/main/packages/core/src/core/Component/example.ts",children:"here"}),"."]})}),"\n",(0,o.jsx)(t.h2,{id:"leveling-up-your-app-with-custom-components-",children:"Leveling up your app with custom components! \ud83d\udd0c"}),"\n",(0,o.jsx)(t.hr,{}),"\n",(0,o.jsxs)(t.p,{children:["One of the greatest things about the library is that you can create your own reactive and non reactive elements (statefull and stateless components respectively) in a very simple and efficient way, all thanks to the power of ",(0,o.jsx)(t.a,{href:"https://lit.dev/docs/libraries/standalone-templates/",children:"lit-html"})," \ud83d\udcaa.\nThe ",(0,o.jsx)(t.code,{children:"Component"})," class has a static method to create functional components (UI defined as a function) that can be updated anytime. The method is ",(0,o.jsx)(t.code,{children:"Component.create"}),"."]}),"\n",(0,o.jsx)(t.admonition,{type:"note",children:(0,o.jsxs)(t.p,{children:["Despite the ",(0,o.jsx)(t.code,{children:"Component"})," is a class that can be instantiated or extended, from a developer perspective using the library is most likely it will only use the create method."]})}),"\n",(0,o.jsx)(t.h3,{id:"creating-an-stateless-component",children:"Creating an stateless component"}),"\n",(0,o.jsx)(t.p,{children:"To start learning how to create custom components, let's create a custom component that uses the panel section:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:'const statelessPanelSection = BUI.Component.create<BUI.PanelSection>(() => {\n  return BUI.html`\n    <bim-panel-section label="Stateless Panel Section">\n      <bim-color-input label="Color"></bim-color-input>\n    </bim-panel-section>\n  `;\n});\n'})}),"\n",(0,o.jsx)(t.admonition,{type:"warning",children:(0,o.jsxs)(t.p,{children:["Remember to first call ",(0,o.jsx)(t.code,{children:"Manager.init()"})," before anything else!"]})}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"Component.create"})," requires you to provide a function declaration that returns an HTML string made with the ",(0,o.jsx)(t.code,{children:"html"})," tag function, and the result of the function is the HTMLElement it self."]}),"\n",(0,o.jsx)(t.admonition,{type:"note",children:(0,o.jsx)(t.p,{children:"Tag functions are special declarations that are always set before a template literal to process the string."})}),"\n",(0,o.jsxs)(t.p,{children:["Did you notice the component is named ",(0,o.jsx)(t.code,{children:"statelessPanelSection"}),"? Well, the reason is because components can have an optional state. Technically speaking, that makes the create method to have two overloads: one for components with state (statefull) and another for components without state (stateless).\nThe main difference is that statefull components lets you update them with new states (so the UI component will efficiently re-render and display new data) while stateless components never needs to be updated as they are static.\nThe component we just created is stateless, because it doesn't have any state in which its user interface depends on."]}),"\n",(0,o.jsx)(t.h3,{id:"creating-a-statefull-component",children:"Creating a statefull component"}),"\n",(0,o.jsx)(t.p,{children:"Now, let's take a look at how to create a component that can be updated based on state changes:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:'interface PanelSectionUIState {\n  label: string;\n  counter: number;\n}\n\nconst [statefullPanelSection, updateStatefullPanelSection] =\n  BUI.Component.create<BUI.PanelSection, PanelSectionUIState>(\n    (state: PanelSectionUIState) => {\n      const { label, counter } = state;\n      const msg = `This panel section has been updated ${counter} ${counter === 1 ? "time" : "times"}`;\n      return BUI.html`\n      <bim-panel-section label=${label}>\n        <bim-label>${msg}</bim-label>\n      </bim-panel-section>\n    `;\n    },\n    { label: "Statefull Panel Section", counter: 0 },\n  );\n'})}),"\n",(0,o.jsx)(t.p,{children:"When you pass an object as the argument in your create function, the component has now become statefull. As you see, there are a couple of differences between the stateless and statefull components:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"The statefull component requires an state object (it must be an object) to be passed in the function declaration. Think on this as the classic properties object you pass to a component in a framework like React."}),"\n",(0,o.jsxs)(t.li,{children:["When the component is statefull, ",(0,o.jsx)(t.code,{children:"Component.create"})," must have a second argument to specify the initial state of the component."]}),"\n",(0,o.jsxs)(t.li,{children:["Now, ",(0,o.jsx)(t.code,{children:"Component.create"})," does not return the HTMLElement it self, but an array where the first item is the HTMLElement and second is a function to update the component based on an updated state. Think on this as when you use the useState hook in frameworks like React."]}),"\n"]}),"\n",(0,o.jsx)(t.admonition,{type:"note",children:(0,o.jsx)(t.p,{children:"As for now, a statefull component can't update itself! However, you can nest other components that updates the state of some other."})}),"\n",(0,o.jsx)(t.h3,{id:"nesting-components",children:"Nesting components"}),"\n",(0,o.jsx)(t.p,{children:"Now, in order to see the two components in action, let's create a third component to integrate (nest) the two previous:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:'const panel = BUI.Component.create<BUI.Panel>(() => {\n  let counter = 0;\n  const onUpdateBtnClick = () => {\n    counter++;\n    if (counter >= 5) {\n      updateStatefullPanelSection({\n        label: "Powered Statefull Panel Section \ud83d\udcaa",\n        counter,\n      });\n    } else {\n      updateStatefullPanelSection({ counter });\n    }\n  };\n\n  return BUI.html`\n    <bim-panel label="My Panel">\n      <bim-panel-section label="Update Functions">\n        <bim-button @click=${onUpdateBtnClick} label="Update Statefull Section"></bim-button>\n      </bim-panel-section>\n      ${statelessPanelSection}\n      ${statefullPanelSection}\n    </bim-panel>\n  `;\n});\n'})}),"\n",(0,o.jsxs)(t.p,{children:["As you see, the create function doesn't need to immediately return the HTML, but you can also do any other logic you want inside. In this case, the logic adds a listener to ",(0,o.jsx)(t.code,{children:"bim-button"})," in order to update the state of the statefullPanelSection we created earlier. A couple of things to notice here:"]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"You're not forced to update the whole component state, but just the things you need. In this case, we just updated the panel section label in case the counter is greater than or equals to 5. However, in this case the counter is always updated."}),"\n",(0,o.jsx)(t.li,{children:"Despite we updated the component inside the logic of the panel, you can update your statefull components from anywhere in your code by just using the update function."}),"\n",(0,o.jsx)(t.li,{children:"You can nest any component in any other: statefull in stateless, stateless in stateless, etc. In this case, panel is a stateless component, but it has an statefull component inside. That means contents of a stateless component can be updated but because that content is a statefull component."}),"\n",(0,o.jsxs)(t.li,{children:["You see how we integrated the two previous components into the panel? Yes, its as easy as adding them as an expression (",(0,o.jsx)(t.code,{children:"${statelessPanelSection}"})," and ",(0,o.jsx)(t.code,{children:"${statefullPanelSection}"})," in this case)."]}),"\n"]}),"\n",(0,o.jsx)(t.admonition,{type:"tip",children:(0,o.jsxs)(t.p,{children:["In order to know the syntax you can write inside the template literal tagged by the html function, look at the ",(0,o.jsx)(t.a,{href:"https://lit.dev/docs/templates/overview/",children:"lit-html"})," documentation."]})}),"\n",(0,o.jsx)(t.p,{children:"Finally, you can add your panel component anywhere you want as its an HTMLElement just like any other!"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"document.body.append(panel);\n"})}),"\n",(0,o.jsx)(t.p,{children:"Congratulations! You already know how to create your own custom reactive components. Don't stop learning! Take a look at more tutorials in the documentation \ud83d\ude42."}),"\n",(0,o.jsx)(t.admonition,{type:"tip",children:(0,o.jsxs)(t.p,{children:["The complementary packages of the library such as ",(0,o.jsx)(t.code,{children:"@thatopen/ui-obc"})," have premade functional components just like the ones we've learned to create in this tutorial, so you don't need to bother to create them by yourself \ud83d\ude09"]})})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>l});var o=n(6540);const a={},s=o.createContext(a);function i(e){const t=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);