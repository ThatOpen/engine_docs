"use strict";(self.webpackChunkengine_docs=self.webpackChunkengine_docs||[]).push([[5950],{8075:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var s=n(4848),a=n(8453);const i={},o=void 0,l={id:"Tutorials/Fragments/Fragments/FragmentsModels/EditApi",title:"EditApi",description:'window.open("https://thatopen.github.io/engine_fragment/examples/FragmentsModels/EditApi")} >Go Full Screen',source:"@site/docs/Tutorials/Fragments/Fragments/FragmentsModels/EditApi.mdx",sourceDirName:"Tutorials/Fragments/Fragments/FragmentsModels",slug:"/Tutorials/Fragments/Fragments/FragmentsModels/EditApi",permalink:"/Tutorials/Fragments/Fragments/FragmentsModels/EditApi",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"BuildingConfigurator",permalink:"/Tutorials/Fragments/Fragments/FragmentsModels/BuildingConfigurator"},next:{title:"EditElements",permalink:"/Tutorials/Fragments/Fragments/FragmentsModels/EditElements"}},r={},d=[{value:"Editing Fragment Models \ud83e\udd0f",id:"editing-fragment-models-",level:2},{value:"\ud83d\udd96 Importing our Libraries",id:"-importing-our-libraries",level:3},{value:"\ud83c\udf0e Setting up a Simple Scene",id:"-setting-up-a-simple-scene",level:3},{value:"\ud83d\udee0\ufe0f Setting Up Fragments",id:"\ufe0f-setting-up-fragments",level:3},{value:"\ud83d\udcc2 Loading a Fragments Model",id:"-loading-a-fragments-model",level:3},{value:"\u270f\ufe0f\u2728\ud83e\udde8 How Editing Works",id:"\ufe0f-how-editing-works",level:3},{value:"\u270f\ufe0f\ud83c\udfa8 Editing materials",id:"\ufe0f-editing-materials",level:3},{value:"\u270f\ufe0f\ud83e\uddca Editing geometries",id:"\ufe0f-editing-geometries",level:3},{value:"\u270f\ufe0f\ud83c\udf63 Editing instances",id:"\ufe0f-editing-instances",level:3},{value:"\u270f\ufe0f\ud83c\udf0d Editing global transforms",id:"\ufe0f-editing-global-transforms",level:3},{value:"\u270f\ufe0f\ud83c\udf0d Editing local transforms",id:"\ufe0f-editing-local-transforms",level:3},{value:"\u270f\ufe0f\ud83d\udcc4 Editing items",id:"\ufe0f-editing-items",level:3},{value:"\u270f\ufe0f\ud83d\udcf0 Editing metadata",id:"\ufe0f-editing-metadata",level:3},{value:"\u270f\ufe0f\ud83c\udf33 Editing the spatial structure",id:"\ufe0f-editing-the-spatial-structure",level:3},{value:"\u2728\ud83c\udfa8 Creating materials",id:"-creating-materials",level:3},{value:"\u2728\ud83e\uddca Creating geometries",id:"-creating-geometries",level:3},{value:"\u2728\ud83c\udf63 Creating instances",id:"-creating-instances",level:3},{value:"\u2728\ud83c\udf0d Creating global transforms (and items)",id:"-creating-global-transforms-and-items",level:3},{value:"\u2728\ud83c\udf0d Creating local transforms",id:"-creating-local-transforms",level:3},{value:"\u2728\ud83d\udcc4 Creating items",id:"-creating-items",level:3},{value:"\ud83e\udde8\ud83c\udfa8 Deleting materials",id:"-deleting-materials",level:3},{value:"\ud83e\udde8\ud83e\uddca Deleting geometries",id:"-deleting-geometries",level:3},{value:"\ud83e\udde8\ud83c\udf63 Deleting instances",id:"-deleting-instances",level:3},{value:"\ud83e\udde8\ud83c\udf0d Deleting global transforms",id:"-deleting-global-transforms",level:3},{value:"\ud83e\udde8\ud83c\udf0d Deleting local transforms",id:"-deleting-local-transforms",level:3},{value:"\ud83e\udde8\ud83c\udf0d Deleting items",id:"-deleting-items",level:3},{value:"\ud83d\udcbe Saving the model",id:"-saving-the-model",level:3},{value:"\ud83e\udde9 Adding User Interface (optional)",id:"-adding-user-interface-optional",level:3},{value:"\u23f1\ufe0f Measuring the performance (optional)",id:"\ufe0f-measuring-the-performance-optional",level:3},{value:"\ud83c\udf89 Congratulations!",id:"-congratulations",level:3}];function m(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",hr:"hr",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)("div",{style:{position:"relative"},children:[(0,s.jsx)("iframe",{src:"https://thatopen.github.io/engine_fragment/examples/FragmentsModels/EditApi"}),(0,s.jsx)("button",{class:"full-screen-btn",onClick:()=>window.open("https://thatopen.github.io/engine_fragment/examples/FragmentsModels/EditApi"),children:"Go Full Screen"})]}),"\n",(0,s.jsx)(t.admonition,{title:"Source",type:"info",children:(0,s.jsxs)(t.p,{children:["Copying and pasting? We've got you covered! You can find the full source code of this tutorial ",(0,s.jsx)(t.a,{href:"https://github.com/ThatOpen/engine_fragment/blob/main/packages/fragments/src/FragmentsModels/examples/EditApi/example.ts",children:"here"}),"."]})}),"\n",(0,s.jsx)(t.h2,{id:"editing-fragment-models-",children:"Editing Fragment Models \ud83e\udd0f"}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.p,{children:"Viewing BIM models is cool, but sometimes we also need to edit the information of existing BIM models. In this tutorial, we'll explore how to edit BIM models using the Fragments Edit API, covering most of the edit operations."}),"\n",(0,s.jsx)(t.h3,{id:"-importing-our-libraries",children:"\ud83d\udd96 Importing our Libraries"}),"\n",(0,s.jsx)(t.p,{children:"First things first, let's install all necessary dependencies to make this example work:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'import * as OBC from "@thatopen/components";\nimport Stats from "stats.js";\nimport * as THREE from "three";\nimport * as BUI from "@thatopen/ui";\n// You have to import * as FRAGS from "@thatopen/fragments"\nimport * as FRAGS from "../../../index";\n'})}),"\n",(0,s.jsx)(t.h3,{id:"-setting-up-a-simple-scene",children:"\ud83c\udf0e Setting up a Simple Scene"}),"\n",(0,s.jsx)(t.p,{children:"To get started, let's set up a basic ThreeJS scene with shadows. This will serve as the foundation for our application and allow us to visualize the 3D models effectively:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'const components = new OBC.Components();\nconst worlds = components.get(OBC.Worlds);\nconst container = document.getElementById("container") as HTMLDivElement;\n\nconst world = worlds.create<\n  OBC.ShadowedScene,\n  OBC.OrthoPerspectiveCamera,\n  OBC.SimpleRenderer\n>();\n\nworld.scene = new OBC.ShadowedScene(components);\nworld.renderer = new OBC.SimpleRenderer(components, container);\nworld.camera = new OBC.OrthoPerspectiveCamera(components);\n\ncomponents.init();\n\nworld.scene.three.add(new THREE.AxesHelper());\n\nworld.camera.three.far = 10000;\n\nworld.renderer.three.shadowMap.enabled = true;\nworld.renderer.three.shadowMap.type = THREE.PCFSoftShadowMap;\n\nworld.scene.setup({\n  shadows: {\n    cascade: 1,\n    resolution: 1024,\n  },\n});\n\nawait world.scene.updateShadows();\n\nworld.camera.controls.addEventListener("rest", async () => {\n  await world.scene.updateShadows();\n});\n'})}),"\n",(0,s.jsx)(t.p,{children:"We will also define a disk bounding box and a disk geometry to use in some of the edits we'll make later."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"// @ts-ignore\nconst diskBbox = [0, 0, 0, 1, 1, 1];\n// @ts-ignore\nconst diskGeometry: FRAGS.RawShell = {\n  points: [\n    [0, 0, 0],\n    [1, 0, 0],\n    [1, 1, 0],\n    [0, 1, 0],\n    [0.25, 0.25, 0],\n    [0.75, 0.25, 0],\n    [0.75, 0.75, 0],\n    [0.25, 0.75, 0],\n  ],\n  profiles: new Map([[0, [0, 1, 2, 3]]]),\n  holes: new Map([[0, [[4, 5, 6, 7]]]]),\n  bigProfiles: new Map(),\n  bigHoles: new Map(),\n  type: FRAGS.ShellType.NONE,\n  profilesFaceIds: [0],\n};\n"})}),"\n",(0,s.jsx)(t.admonition,{title:"Do I need @thatopen/components?",type:"info",children:(0,s.jsx)(t.p,{children:"Not necessarily! While @thatopen/components simplifies the process of setting up a scene, you can always use plain ThreeJS to create your own custom scene setup. It's entirely up to your preference and project requirements! \ud83d\ude09"})}),"\n",(0,s.jsx)(t.h3,{id:"\ufe0f-setting-up-fragments",children:"\ud83d\udee0\ufe0f Setting Up Fragments"}),"\n",(0,s.jsx)(t.p,{children:"Now, let's configure the Fragments library core. This will allow us to load models effortlessly and start manipulating them with ease:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'// You have to copy `/node_modules/@thatopen/fragments/dist/Worker/worker.mjs` to your project directory\n// and provide the relative path in `workerUrl`\n// We use here the internal route of the worker in the library for simplicity purposes\nconst workerUrl = "https://thatopen.github.io/engine_fragment/resources/worker.mjs";\nconst fragments = new FRAGS.FragmentsModels(workerUrl);\nworld.camera.controls.addEventListener("update", () => fragments.update());\n\n// Once a model is available in the list, we can tell what camera to use\n// in order to perform the culling and LOD operations.\n// Also, we add the model to the 3D scene.\nfragments.models.list.onItemSet.add(({ value: model }) => {\n  model.useCamera(world.camera.three);\n  world.scene.three.add(model.object);\n  // At the end, you tell fragments to update so the model can be seen given\n  // the initial camera position\n\n  // We will also set up the shadows of all the loaded models here\n  model.tiles.onItemSet.add(({ value: mesh }) => {\n    if ("isMesh" in mesh) {\n      const mat = mesh.material as THREE.MeshStandardMaterial[];\n      if (mat[0].opacity === 1) {\n        mesh.castShadow = true;\n        mesh.receiveShadow = true;\n      }\n    }\n  });\n});\n'})}),"\n",(0,s.jsx)(t.h3,{id:"-loading-a-fragments-model",children:"\ud83d\udcc2 Loading a Fragments Model"}),"\n",(0,s.jsx)(t.p,{children:"With the core setup complete, it's time to load a Fragments model into our scene. Fragments are optimized for fast loading and rendering, making them ideal for large-scale 3D models."}),"\n",(0,s.jsx)(t.admonition,{title:"Where can I find Fragment files?",type:"info",children:(0,s.jsx)(t.p,{children:"You can use the sample Fragment files available in our repository for testing. If you have an IFC model you'd like to convert to Fragments, check out the IfcImporter tutorial for detailed instructions."})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'const modelId = "test";\nconst fetched = await fetch("https://thatopen.github.io/engine_fragment/resources/frags/school_arq.frag");\nconst buffer = await fetched.arrayBuffer();\nconst model = await fragments.load(buffer, { modelId });\nawait fragments.update(true);\n'})}),"\n",(0,s.jsx)(t.h3,{id:"\ufe0f-how-editing-works",children:"\u270f\ufe0f\u2728\ud83e\udde8 How Editing Works"}),"\n",(0,s.jsx)(t.p,{children:"Now, let's edit the model. The Fragments Edit API is based on edit requests. Each edit request is an object that contains the type of edit to perform and the data to edit. In this tutorial we will cover the most common edit requests available. Let's get started!"}),"\n",(0,s.jsx)(t.admonition,{title:"How to go from simple edit requests to a modeller/configurator?",type:"info",children:(0,s.jsx)(t.p,{children:"Don't worry! Edit requests are the foundation of the Fragments Edit API. It's important to familiarize yourself with them first, but we also have other APIs that will make building a modeller/configurator a lot easier."})}),"\n",(0,s.jsx)(t.admonition,{title:"What about real time changes?",type:"warning",children:(0,s.jsx)(t.p,{children:"You may have noticed that applying edit requests to the model is not instantaneous; you can't make 60 edits per second. This is because the model is updated in the background to keep the Fragments' performance at a high level. But don't worry: there are ways to make changes in real time, and you'll learn about them in other tutorials."})}),"\n",(0,s.jsx)(t.h3,{id:"\ufe0f-editing-materials",children:"\u270f\ufe0f\ud83c\udfa8 Editing materials"}),"\n",(0,s.jsx)(t.p,{children:"We will define a function that will find the most used material and change its color to red."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"const editMaterials = async () => {\n  // Define edit requests\n  const requests: FRAGS.EditRequest[] = [];\n\n  // Find most used material\n  const samples = await model.getSamples();\n  const materialCounts = new Map<number, number>();\n  for (const [, sample] of samples) {\n    const material = sample.material;\n    const count = materialCounts.get(material) || 0;\n    materialCounts.set(material, count + 1);\n  }\n  let mostUsedMatId = 0;\n  let maxCount = 0;\n  for (const [material, count] of materialCounts) {\n    if (count > maxCount) {\n      maxCount = count;\n      mostUsedMatId = material;\n    }\n  }\n\n  // Create an edit request to update the material to red\n  const materials = await model.getMaterials([mostUsedMatId]);\n  const materialId = materials.keys().next().value as number;\n  const material = materials.get(materialId) as FRAGS.RawMaterial;\n  material.r = 255;\n  material.g = 0;\n  material.b = 0;\n  requests.push({\n    type: FRAGS.EditRequestType.UPDATE_MATERIAL,\n    localId: materialId,\n    data: material,\n  });\n\n  // Apply the edit requests to the model\n  await fragments.editor.edit(modelId, requests);\n\n  // Update the model to see the changes\n  await fragments.update(true);\n};\n"})}),"\n",(0,s.jsx)(t.h3,{id:"\ufe0f-editing-geometries",children:"\u270f\ufe0f\ud83e\uddca Editing geometries"}),"\n",(0,s.jsx)(t.p,{children:"We will define a function that will replace all geometries (representations) by a disk geometry."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"const editGeometries = async () => {\n  // Define edit requests\n  const requests: FRAGS.EditRequest[] = [];\n\n  // substitute all representations by a disk geometry\n  const representations = await model.getRepresentations();\n  for (const [localId, representation] of representations) {\n    representation.geometry = diskGeometry;\n    representation.bbox = diskBbox;\n    requests.push({\n      type: FRAGS.EditRequestType.UPDATE_REPRESENTATION,\n      localId,\n      data: representation,\n    });\n  }\n\n  // Apply the edit requests to the model\n  await fragments.editor.edit(modelId, requests);\n\n  // Update the model to see the changes\n  await fragments.update(true);\n};\n"})}),"\n",(0,s.jsx)(t.h3,{id:"\ufe0f-editing-instances",children:"\u270f\ufe0f\ud83c\udf63 Editing instances"}),"\n",(0,s.jsx)(t.p,{children:"We will define a function that will edit all instances (samples) by changing their material by the material of the first sample."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"const editInstances = async () => {\n  // Define edit requests\n  const requests: FRAGS.EditRequest[] = [];\n\n  // Get first sample\n  const samples = await model.getSamples();\n  const firstSample = samples.values().next().value!;\n\n  for (const [localId, sample] of samples) {\n    sample.material = firstSample.material;\n    requests.push({\n      type: FRAGS.EditRequestType.UPDATE_SAMPLE,\n      localId,\n      data: sample,\n    });\n  }\n\n  // Apply the edit requests to the model\n  await fragments.editor.edit(modelId, requests);\n\n  // Update the model to see the changes\n  await fragments.update(true);\n};\n"})}),"\n",(0,s.jsx)(t.h3,{id:"\ufe0f-editing-global-transforms",children:"\u270f\ufe0f\ud83c\udf0d Editing global transforms"}),"\n",(0,s.jsx)(t.p,{children:"We will define a function that will edit all global transforms by modifying it's y position."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"const editGlobalTransforms = async () => {\n  // Define edit requests\n  const requests: FRAGS.EditRequest[] = [];\n\n  // Get all global transforms\n  const gTransforms = await model.getGlobalTransforms();\n\n  // Edit all global transforms by multiplying it's y position by 5\n  for (const [localId, globalTransform] of gTransforms) {\n    globalTransform.position[1] *= 5;\n    requests.push({\n      type: FRAGS.EditRequestType.UPDATE_GLOBAL_TRANSFORM,\n      localId,\n      data: globalTransform,\n    });\n  }\n\n  // Apply the edit requests to the model\n  await fragments.editor.edit(modelId, requests);\n\n  // Update the model to see the changes\n  await fragments.update(true);\n};\n"})}),"\n",(0,s.jsx)(t.h3,{id:"\ufe0f-editing-local-transforms",children:"\u270f\ufe0f\ud83c\udf0d Editing local transforms"}),"\n",(0,s.jsx)(t.p,{children:"We will define a function that will edit all local transforms by modifying it's y position. We will skip the first local transform because it's the no-local transform (the local transform assigned to all the instances without a local transform)."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"const editLocalTransforms = async () => {\n  // Define edit requests\n  const requests: FRAGS.EditRequest[] = [];\n\n  // Get all local transforms\n  const lTransforms = await model.getLocalTransforms();\n\n  // Edit all local transforms by multiplying it's y position by 5 (except the first one)\n  let first = true;\n  for (const [localId, localTransform] of lTransforms) {\n    if (first) {\n      first = false;\n      continue;\n    }\n    localTransform.position[1] *= 5;\n    requests.push({\n      type: FRAGS.EditRequestType.UPDATE_LOCAL_TRANSFORM,\n      localId,\n      data: localTransform,\n    });\n  }\n\n  // Apply the edit requests to the model\n  await fragments.editor.edit(modelId, requests);\n\n  // Update the model to see the changes\n  await fragments.update(true);\n};\n"})}),"\n",(0,s.jsx)(t.h3,{id:"\ufe0f-editing-items",children:"\u270f\ufe0f\ud83d\udcc4 Editing items"}),"\n",(0,s.jsx)(t.p,{children:"We will define a function that will edit the attributes of all walls in the model."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'const editItems = async () => {\n  // Define edit requests\n  const requests: FRAGS.EditRequest[] = [];\n\n  // Get all walls items\n  const foundWalls = await model.getItemsOfCategories([/WALL/]);\n  const wallsIds = Object.values(foundWalls).flat();\n  const items = await model.getItems(wallsIds);\n\n  // Edit all walls items by overriding its attributes\n  for (const [localId, item] of items) {\n    item.data = { test: { value: "hello" } };\n    requests.push({\n      type: FRAGS.EditRequestType.UPDATE_ITEM,\n      localId,\n      data: item,\n    });\n  }\n\n  // Apply the edit requests to the model\n  await fragments.editor.edit(modelId, requests);\n\n  // Update the model to see the changes\n  await fragments.update(true);\n\n  // Now log the new data\n\n  const newItems = await model.getItems(wallsIds);\n  console.log("New items:", newItems);\n  alert("All wall attributes edited! Check the console to see them!");\n};\n'})}),"\n",(0,s.jsx)(t.h3,{id:"\ufe0f-editing-metadata",children:"\u270f\ufe0f\ud83d\udcf0 Editing metadata"}),"\n",(0,s.jsx)(t.p,{children:"We will define a function that will edit the metadata of the model."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'const editMetadata = async () => {\n  // Define edit requests\n  const requests: FRAGS.EditRequest[] = [];\n\n  // Get the metadata and edit it\n  const metadata = await model.getMetadata();\n  metadata.newMetadataAttribute = "newMetadataAttribute";\n  requests.push({\n    type: FRAGS.EditRequestType.UPDATE_METADATA,\n    localId: 0,\n    data: metadata,\n  });\n\n  // Apply the edit requests to the model\n  await fragments.editor.edit(modelId, requests);\n\n  // Update the model to see the changes\n  await fragments.update(true);\n\n  // Now log the new data\n\n  const newMetadata = await model.getMetadata();\n  console.log("New metadata:", newMetadata);\n  alert("Metadata edited! Check the console to see it!");\n};\n'})}),"\n",(0,s.jsx)(t.h3,{id:"\ufe0f-editing-the-spatial-structure",children:"\u270f\ufe0f\ud83c\udf33 Editing the spatial structure"}),"\n",(0,s.jsx)(t.p,{children:"We will define a function that will edit the spatial structure of the model."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'const editSpatialStructure = async () => {\n  // Define edit requests\n  const requests: FRAGS.EditRequest[] = [];\n\n  // Get the metadata and edit it\n  requests.push({\n    type: FRAGS.EditRequestType.UPDATE_SPATIAL_STRUCTURE,\n    localId: 0,\n    data: {\n      localId: 0,\n      category: "test",\n      children: [],\n    },\n  });\n  // Apply the edit requests to the model\n  await fragments.editor.edit(modelId, requests);\n\n  // Update the model to see the changes\n  await fragments.update(true);\n\n  // Now log the new data\n\n  const newSpatialStructure = await model.getSpatialStructure();\n  console.log("New empty spatial structure:", newSpatialStructure);\n  alert("Spatial structure edited! Check the console to see it!");\n};\n'})}),"\n",(0,s.jsx)(t.h3,{id:"-creating-materials",children:"\u2728\ud83c\udfa8 Creating materials"}),"\n",(0,s.jsx)(t.p,{children:"We will define a function that will create a new material with a random color and assign it to all the samples in the model."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'const createMaterials = async () => {\n  // Define edit requests\n  const requests: FRAGS.EditRequest[] = [];\n\n  // Define a new material\n  const newMaterial = {\n    r: 113,\n    g: 255,\n    b: 0,\n    a: 255,\n    renderedFaces: 0,\n    stroke: 0,\n  };\n\n  // We use this temp id to reference the new material\n  // before creating it and getting its local id\n  const tempId = "new-material";\n\n  // Create the new material\n  requests.push({\n    type: FRAGS.EditRequestType.CREATE_MATERIAL,\n    tempId,\n    data: newMaterial,\n  });\n\n  // Assign the new material to all the samples\n  const samples = await model.getSamples();\n  for (const [localId, sample] of samples) {\n    requests.push({\n      type: FRAGS.EditRequestType.UPDATE_SAMPLE,\n      localId,\n      data: { ...sample, material: tempId },\n    });\n  }\n\n  // Apply the edit requests to the model\n  await fragments.editor.edit(modelId, requests);\n\n  // Update the model to see the changes\n  await fragments.update(true);\n};\n'})}),"\n",(0,s.jsx)(t.h3,{id:"-creating-geometries",children:"\u2728\ud83e\uddca Creating geometries"}),"\n",(0,s.jsx)(t.p,{children:"We will define a function that will create a new shell geometry and assign it to all the samples in the model."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'const createGeometries = async () => {\n  // Define edit requests\n  const requests: FRAGS.EditRequest[] = [];\n\n  // We use this temp id to reference the new geometry\n  // before creating it and getting its local id\n  const tempId = "new-geometry";\n\n  // Create the new geometry\n  requests.push({\n    type: FRAGS.EditRequestType.CREATE_REPRESENTATION,\n    tempId,\n    data: {\n      bbox: diskBbox,\n      representationClass: FRAGS.RepresentationClass.SHELL,\n      geometry: diskGeometry,\n    },\n  });\n\n  // Assign the new geometry to all the samples\n  const samples = await model.getSamples();\n  for (const [localId, sample] of samples) {\n    requests.push({\n      type: FRAGS.EditRequestType.UPDATE_SAMPLE,\n      localId,\n      data: { ...sample, representation: tempId },\n    });\n  }\n\n  // Apply the edit requests to the model\n  await fragments.editor.edit(modelId, requests);\n\n  // Update the model to see the changes\n  await fragments.update(true);\n};\n'})}),"\n",(0,s.jsx)(t.h3,{id:"-creating-instances",children:"\u2728\ud83c\udf63 Creating instances"}),"\n",(0,s.jsx)(t.p,{children:"We will define a function that will create a new instance (sample) for each sample in the model, and give it the same geometry as the first sample. Basically, we will create an instance of one geometry on top of each existing instance."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"const createInstances = async () => {\n  // Define edit requests\n  const requests: FRAGS.EditRequest[] = [];\n\n  // Get all samples\n  const samples = await model.getSamples();\n\n  // Get the first sample\n  const firstSample = samples.values().next().value!;\n\n  // Create a new instance for each sample\n  for (const [, sample] of samples) {\n    requests.push({\n      type: FRAGS.EditRequestType.CREATE_SAMPLE,\n      data: { ...sample, representation: firstSample.representation },\n    });\n  }\n\n  // Apply the edit requests to the model\n  await fragments.editor.edit(modelId, requests);\n\n  // Update the model to see the changes\n  await fragments.update(true);\n};\n"})}),"\n",(0,s.jsx)(t.h3,{id:"-creating-global-transforms-and-items",children:"\u2728\ud83c\udf0d Creating global transforms (and items)"}),"\n",(0,s.jsx)(t.p,{children:"We will define a function that will create a new global transform and assign it to every instance in the model. Global transforms are bound to items, so we need to create an item too."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'const createGlobalTransforms = async () => {\n  // Define edit requests\n  const requests: FRAGS.EditRequest[] = [];\n\n  // We use these temp ids to reference the new item and global transform\n  // before creating them and getting their local ids\n  const tempItemId = "new-item";\n  const tempGlobalTransformId = "new-global-transform";\n\n  // Create the new item and the new global transform\n  requests.push(\n    {\n      type: FRAGS.EditRequestType.CREATE_ITEM,\n      tempId: tempItemId,\n      data: { data: { hello: { value: "world" } }, category: "test" },\n    },\n    {\n      type: FRAGS.EditRequestType.CREATE_GLOBAL_TRANSFORM,\n      tempId: tempGlobalTransformId,\n      data: {\n        position: [0, 0, 0],\n        xDirection: [1, 0, 0],\n        yDirection: [0, 1, 0],\n        itemId: tempItemId,\n      },\n    },\n  );\n\n  // Assign the new global transform to all the samples\n  const samples = await model.getSamples();\n  for (const [localId, sample] of samples) {\n    requests.push({\n      type: FRAGS.EditRequestType.UPDATE_SAMPLE,\n      localId,\n      data: { ...sample, item: tempGlobalTransformId },\n    });\n  }\n\n  // Apply the edit requests to the model\n  await fragments.editor.edit(modelId, requests);\n\n  // Update the model to see the changes\n  await fragments.update(true);\n};\n'})}),"\n",(0,s.jsx)(t.h3,{id:"-creating-local-transforms",children:"\u2728\ud83c\udf0d Creating local transforms"}),"\n",(0,s.jsx)(t.p,{children:"We will define a function that will create a new local transform and assign it to every instance in the model."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'const createLocalTransforms = async () => {\n  // Define edit requests\n  const requests: FRAGS.EditRequest[] = [];\n\n  // We use this temp id to reference the new local transform\n  // before creating it and getting its local id\n  const tempId = "new-local-transform";\n\n  // Create the new local transform\n  requests.push({\n    type: FRAGS.EditRequestType.CREATE_LOCAL_TRANSFORM,\n    tempId,\n    data: {\n      position: [0, 0, 0],\n      xDirection: [1, 0, 0],\n      yDirection: [0, 1, 0],\n    },\n  });\n\n  // Assign the new local transform to all the samples\n  const samples = await model.getSamples();\n  for (const [localId, sample] of samples) {\n    requests.push({\n      type: FRAGS.EditRequestType.UPDATE_SAMPLE,\n      localId,\n      data: { ...sample, localTransform: tempId },\n    });\n  }\n\n  // Apply the edit requests to the model\n  await fragments.editor.edit(modelId, requests);\n\n  // Update the model to see the changes\n  await fragments.update(true);\n};\n'})}),"\n",(0,s.jsx)(t.h3,{id:"-creating-items",children:"\u2728\ud83d\udcc4 Creating items"}),"\n",(0,s.jsx)(t.p,{children:"We will define a function that will create a new item in the model."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'const createItems = async () => {\n  // Define edit requests\n  const requests: FRAGS.EditRequest[] = [];\n\n  // Create the new item\n  requests.push({\n    type: FRAGS.EditRequestType.CREATE_ITEM,\n    data: { data: { hello: { value: "world" } }, category: "test" },\n  });\n\n  // Apply the edit requests to the model\n  const [localId] = await fragments.editor.edit(modelId, requests);\n\n  // Update the model to see the changes\n  await fragments.update(true);\n\n  // Now log the new data\n  const newItems = await model.getItems([localId]);\n  console.log("New items:", newItems);\n  alert("Item created! Check the console to see it!");\n};\n'})}),"\n",(0,s.jsx)(t.h3,{id:"-deleting-materials",children:"\ud83e\udde8\ud83c\udfa8 Deleting materials"}),"\n",(0,s.jsx)(t.p,{children:"We will define a function that will delete the most used material in the model."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"const deleteMaterials = async () => {\n  // Define edit requests\n  const requests: FRAGS.EditRequest[] = [];\n\n  // Find most used material and delete it\n\n  const samples = await model.getSamples();\n  const materialCounts = new Map<number, number>();\n  for (const [, sample] of samples) {\n    const material = sample.material;\n    const count = materialCounts.get(material) || 0;\n    materialCounts.set(material, count + 1);\n  }\n  let mostUsedMatId = 0;\n  let maxCount = 0;\n  for (const [material, count] of materialCounts) {\n    if (count > maxCount) {\n      maxCount = count;\n      mostUsedMatId = material;\n    }\n  }\n\n  // Find the second most used material\n  const materials = await model.getMaterials();\n  const materialIds = Array.from(materials.keys());\n  const secondMat =\n    materialIds[0] === mostUsedMatId ? materialIds[1] : materialIds[0];\n\n  requests.push({\n    type: FRAGS.EditRequestType.DELETE_MATERIAL,\n    localId: mostUsedMatId,\n  });\n\n  // We can't have samples referencing the deleted material, so we will update\n  // them to reference the second most used material\n  for (const [localId, sample] of samples) {\n    if (sample.material === mostUsedMatId) {\n      requests.push({\n        type: FRAGS.EditRequestType.UPDATE_SAMPLE,\n        localId,\n        data: { ...sample, material: secondMat },\n      });\n    }\n  }\n\n  // Apply the edit requests to the model\n  await fragments.editor.edit(modelId, requests);\n\n  // Update the model to see the changes\n  await fragments.update(true);\n};\n"})}),"\n",(0,s.jsx)(t.h3,{id:"-deleting-geometries",children:"\ud83e\udde8\ud83e\uddca Deleting geometries"}),"\n",(0,s.jsx)(t.p,{children:"We will define a function that will delete the most used representation in the model."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"const deleteGeometries = async () => {\n  // Define edit requests\n  const requests: FRAGS.EditRequest[] = [];\n\n  // Find most used representation\n\n  const samples = await model.getSamples();\n  const reprCounts = new Map<number, number>();\n\n  for (const [, sample] of samples) {\n    const repr = sample.representation;\n    const count = reprCounts.get(repr) || 0;\n    reprCounts.set(repr, count + 1);\n  }\n\n  let mostUsedReprId = 0;\n  let maxCount = 0;\n  for (const [repr, count] of reprCounts) {\n    if (count > maxCount) {\n      maxCount = count;\n      mostUsedReprId = repr;\n    }\n  }\n\n  const reprs = await model.getRepresentations();\n  const reprIds = Array.from(reprs.keys());\n  const secondRepr = reprIds[0] === mostUsedReprId ? reprIds[1] : reprIds[0];\n\n  // Delete the most used representation\n  requests.push({\n    type: FRAGS.EditRequestType.DELETE_REPRESENTATION,\n    localId: mostUsedReprId,\n  });\n\n  // Update the samples to reference the second most used representation\n  for (const [localId, sample] of samples) {\n    if (sample.representation === mostUsedReprId) {\n      requests.push({\n        type: FRAGS.EditRequestType.UPDATE_SAMPLE,\n        localId,\n        data: { ...sample, representation: secondRepr },\n      });\n    }\n  }\n\n  // Apply the edit requests to the model\n  await fragments.editor.edit(modelId, requests);\n\n  // Update the model to see the changes\n  await fragments.update(true);\n};\n"})}),"\n",(0,s.jsx)(t.h3,{id:"-deleting-instances",children:"\ud83e\udde8\ud83c\udf63 Deleting instances"}),"\n",(0,s.jsx)(t.p,{children:"We will define a function that will delete half of the instances in the model."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"const deleteInstances = async () => {\n  // Define edit requests\n  const requests: FRAGS.EditRequest[] = [];\n\n  // Delete half of the samples\n  const samples = await model.getSamples();\n  let toggle = false;\n  for (const [localId] of samples) {\n    toggle = !toggle;\n    if (toggle) {\n      continue;\n    }\n    requests.push({\n      type: FRAGS.EditRequestType.DELETE_SAMPLE,\n      localId,\n    });\n  }\n\n  // Apply the edit requests to the model\n  await fragments.editor.edit(modelId, requests);\n\n  // Update the model to see the changes\n  await fragments.update(true);\n};\n"})}),"\n",(0,s.jsx)(t.h3,{id:"-deleting-global-transforms",children:"\ud83e\udde8\ud83c\udf0d Deleting global transforms"}),"\n",(0,s.jsx)(t.p,{children:"We will define a function that will delete every global transform except the first one."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"const deleteGlobalTransforms = async () => {\n  // Define edit requests\n  const requests: FRAGS.EditRequest[] = [];\n\n  // Delete every global transforms except the first one\n  const gTransforms = Array.from((await model.getGlobalTransforms()).keys());\n  const gTransformsToDelete = new Set<number>();\n  for (let i = 1; i < gTransforms.length; i++) {\n    gTransformsToDelete.add(gTransforms[i]);\n  }\n\n  const firstGt = gTransforms[0];\n  for (const localId of gTransformsToDelete) {\n    requests.push({\n      type: FRAGS.EditRequestType.DELETE_GLOBAL_TRANSFORM,\n      localId,\n    });\n  }\n\n  // Update the samples to reference the first global transform\n  const samples = await model.getSamples();\n  for (const [localId, sample] of samples) {\n    if (gTransformsToDelete.has(sample.item)) {\n      requests.push({\n        type: FRAGS.EditRequestType.UPDATE_SAMPLE,\n        localId,\n        data: { ...sample, item: firstGt },\n      });\n    }\n  }\n\n  // Apply the edit requests to the model\n  await fragments.editor.edit(modelId, requests);\n\n  // Update the model to see the changes\n  await fragments.update(true);\n};\n"})}),"\n",(0,s.jsx)(t.h3,{id:"-deleting-local-transforms",children:"\ud83e\udde8\ud83c\udf0d Deleting local transforms"}),"\n",(0,s.jsx)(t.p,{children:"We will define a function that will delete every local transform except the first one."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"const deleteLocalTransforms = async () => {\n  // Define edit requests\n  const requests: FRAGS.EditRequest[] = [];\n\n  // Delete every local transform except the first one\n\n  const lTransforms = Array.from((await model.getLocalTransforms()).keys());\n  const lTransformsToDelete = new Set<number>();\n  for (let i = 1; i < lTransforms.length; i++) {\n    lTransformsToDelete.add(lTransforms[i]);\n  }\n\n  const firstLt = lTransforms[0];\n\n  for (const localId of lTransformsToDelete) {\n    requests.push({\n      type: FRAGS.EditRequestType.DELETE_LOCAL_TRANSFORM,\n      localId,\n    });\n  }\n\n  const samples = await model.getSamples();\n  for (const [localId, sample] of samples) {\n    if (lTransformsToDelete.has(sample.localTransform)) {\n      requests.push({\n        type: FRAGS.EditRequestType.UPDATE_SAMPLE,\n        localId,\n        data: { ...sample, localTransform: firstLt },\n      });\n    }\n  }\n\n  // Apply the edit requests to the model\n  await fragments.editor.edit(modelId, requests);\n\n  // Update the model to see the changes\n  await fragments.update(true);\n};\n"})}),"\n",(0,s.jsx)(t.h3,{id:"-deleting-items",children:"\ud83e\udde8\ud83c\udf0d Deleting items"}),"\n",(0,s.jsx)(t.p,{children:"We will define a function that will delete an item and its associated global transform."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"const deleteItems = async () => {\n  // Define edit requests\n  const requests: FRAGS.EditRequest[] = [];\n\n  // We need to edit the global transform associated with the item too\n  const items = await model.getItems();\n  const itemIds = Array.from(items.keys());\n  const firstItemId = itemIds[0];\n  const secondItemId = itemIds[1];\n  const gtIds = await model.getGlobalTranformsIdsOfItems([firstItemId]);\n\n  requests.push({\n    type: FRAGS.EditRequestType.DELETE_ITEM,\n    localId: firstItemId,\n  });\n\n  const gts = await model.getGlobalTransforms(gtIds);\n  for (const [id, gt] of gts) {\n    requests.push({\n      type: FRAGS.EditRequestType.UPDATE_GLOBAL_TRANSFORM,\n      localId: id,\n      data: { ...gt, itemId: secondItemId },\n    });\n  }\n\n  // Apply the edit requests to the model\n  await fragments.editor.edit(modelId, requests);\n\n  // Update the model to see the changes\n  await fragments.update(true);\n};\n"})}),"\n",(0,s.jsx)(t.h3,{id:"-saving-the-model",children:"\ud83d\udcbe Saving the model"}),"\n",(0,s.jsx)(t.p,{children:"We will define a function that will export the edited Fragments model to a new file."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'const exportModel = async () => {\n  await fragments.editor.save(model.modelId);\n  window.setTimeout(async () => {\n    const exportedBuffer = await model.getBuffer();\n    const exportedBytes = new Uint8Array(exportedBuffer);\n    const exportedBlob = new Blob([exportedBytes]);\n    const exportedUrl = URL.createObjectURL(exportedBlob);\n    const exportedLink = document.createElement("a");\n    exportedLink.href = exportedUrl;\n    exportedLink.download = "exported.frag";\n    document.body.appendChild(exportedLink);\n    exportedLink.click();\n    document.body.removeChild(exportedLink);\n    URL.revokeObjectURL(exportedUrl);\n  }, 1000);\n};\n'})}),"\n",(0,s.jsx)(t.h3,{id:"-adding-user-interface-optional",children:"\ud83e\udde9 Adding User Interface (optional)"}),"\n",(0,s.jsxs)(t.p,{children:["We will use the ",(0,s.jsx)(t.code,{children:"@thatopen/ui"})," library to add some simple and cool UI elements to our app. First, we need to call the ",(0,s.jsx)(t.code,{children:"init"})," method of the ",(0,s.jsx)(t.code,{children:"BUI.Manager"})," class to initialize the library:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"BUI.Manager.init();\n"})}),"\n",(0,s.jsx)(t.p,{children:"Now we will add some UI to handle the logic of this tutorial. For more information about the UI library, you can check the specific documentation for it!"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'const panel = BUI.Component.create<BUI.PanelSection>(() => {\n  return BUI.html`\n    <bim-panel id="controls-panel" active label="Raycasting" class="options-menu">\n      <bim-panel-section fixed label="Export operations">\n        <bim-button icon="mdi:file-export" label="Export model" @click=${exportModel}></bim-button>\n      </bim-panel-section>\n      <bim-panel-section fixed label="Edit operations">\n        <bim-button icon="icon-park-outline:material" label="Edit materials" @click=${editMaterials}></bim-button>\n        <bim-button icon="mdi:cube-outline" label="Edit geometries" @click=${editGeometries}></bim-button>\n        <bim-button icon="mingcute:cube-line" label="Edit instances" @click=${editInstances}></bim-button>\n        <bim-button icon="iconoir:axes" label="Edit global transforms" @click=${editGlobalTransforms}></bim-button>\n        <bim-button icon="iconoir:axes" label="Edit local transforms" @click=${editLocalTransforms}></bim-button>\n        <bim-button icon="mdi:paper-outline" label="Edit items" @click=${editItems}></bim-button>\n        <bim-button icon="bx:data" label="Edit metadata" @click=${editMetadata}></bim-button>\n        <bim-button icon="mdi:tree-outline" label="Edit spatial structure" @click=${editSpatialStructure}></bim-button>\n      </bim-panel-section>\n      <bim-panel-section fixed label="Create operations">\n        <bim-button icon="icon-park-outline:material" label="Create materials" @click=${createMaterials}></bim-button>\n        <bim-button icon="mdi:cube-outline" label="Create geometries" @click=${createGeometries}></bim-button>\n        <bim-button icon="mingcute:cube-line" label="Create instances" @click=${createInstances}></bim-button>\n        <bim-button icon="iconoir:axes" label="Create global transforms" @click=${createGlobalTransforms}></bim-button>\n        <bim-button icon="iconoir:axes" label="Create local transforms" @click=${createLocalTransforms}></bim-button>\n        <bim-button icon="mdi:paper-outline" label="Create items" @click=${createItems}></bim-button>\n      </bim-panel-section>\n      <bim-panel-section fixed label="Delete operations">\n        <bim-button icon="icon-park-outline:material" label="Delete materials" @click=${deleteMaterials}></bim-button>\n        <bim-button icon="mdi:cube-outline" label="Delete geometries" @click=${deleteGeometries}></bim-button>\n        <bim-button icon="mingcute:cube-line" label="Delete instances" @click=${deleteInstances}></bim-button>\n        <bim-button icon="iconoir:axes" label="Delete global transforms" @click=${deleteGlobalTransforms}></bim-button>\n        <bim-button icon="iconoir:axes" label="Delete local transforms" @click=${deleteLocalTransforms}></bim-button>\n        <bim-button icon="mdi:paper-outline" label="Delete items" @click=${deleteItems}></bim-button>\n      </bim-panel-section>\n\n    </bim-panel>\n  `;\n});\n\ndocument.body.append(panel);\n'})}),"\n",(0,s.jsx)(t.p,{children:"And we will make some logic that adds a button to the screen when the user is visiting our app from their phone, allowing to show or hide the menu. Otherwise, the menu would make the app unusable."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'const button = BUI.Component.create<BUI.PanelSection>(() => {\n  const onClick = () => {\n    if (panel.classList.contains("options-menu-visible")) {\n      panel.classList.remove("options-menu-visible");\n    } else {\n      panel.classList.add("options-menu-visible");\n    }\n  };\n\n  return BUI.html`\n    <bim-button class="phone-menu-toggler" icon="solar:settings-bold"\n      @click=${onClick}>\n    </bim-button>\n  `;\n});\n\ndocument.body.append(button);\n'})}),"\n",(0,s.jsx)(t.h3,{id:"\ufe0f-measuring-the-performance-optional",children:"\u23f1\ufe0f Measuring the performance (optional)"}),"\n",(0,s.jsxs)(t.p,{children:["We'll use the ",(0,s.jsx)(t.a,{href:"https://github.com/mrdoob/stats.js",children:"Stats.js"})," to measure the performance of our app. We will add it to the top left corner of the viewport. This way, we'll make sure that the memory consumption and the FPS of our app are under control."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'const stats = new Stats();\nstats.showPanel(2);\ndocument.body.append(stats.dom);\nstats.dom.style.left = "0px";\nstats.dom.style.zIndex = "unset";\nworld.renderer.onBeforeUpdate.add(() => stats.begin());\nworld.renderer.onAfterUpdate.add(() => stats.end());\n'})}),"\n",(0,s.jsx)(t.h3,{id:"-congratulations",children:"\ud83c\udf89 Congratulations!"}),"\n",(0,s.jsx)(t.p,{children:"You've successfully learned how to edit BIM models using the Fragments Edit API! \ud83d\ude80\nNow, generating the edit requests directly gives us full control over the model but it's not very convenient. Check out the other edit tutorials to learn how to use the Fragments Edit API more easily! \ud83d\udca1"})]})}function c(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(m,{...e})}):m(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>l});var s=n(6540);const a={},i=s.createContext(a);function o(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);