"use strict";(self.webpackChunkengine_docs=self.webpackChunkengine_docs||[]).push([[6132],{6512:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>i,metadata:()=>a,toc:()=>c});var o=t(4848),r=t(8453);const i={},s=void 0,a={id:"Tutorials/Fragments/Fragments/FragmentsModels/BuildingConfigurator",title:"BuildingConfigurator",description:'window.open("https://thatopen.github.io/engine_fragment/examples/FragmentsModels/BuildingConfigurator")} >Go Full Screen',source:"@site/docs/Tutorials/Fragments/Fragments/FragmentsModels/BuildingConfigurator.mdx",sourceDirName:"Tutorials/Fragments/Fragments/FragmentsModels",slug:"/Tutorials/Fragments/Fragments/FragmentsModels/BuildingConfigurator",permalink:"/Tutorials/Fragments/Fragments/FragmentsModels/BuildingConfigurator",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"FragmentsModels",permalink:"/Tutorials/Fragments/Fragments/FragmentsModels/"},next:{title:"EditApi",permalink:"/Tutorials/Fragments/Fragments/FragmentsModels/EditApi"}},l={},c=[{value:"Building a Configurator \ud83e\udd0f",id:"building-a-configurator-",level:2},{value:"\ud83d\udd96 Importing our Libraries",id:"-importing-our-libraries",level:3},{value:"\ud83c\udf0e Setting up a Simple Scene",id:"-setting-up-a-simple-scene",level:3},{value:"\ud83d\udee0\ufe0f Setting Up Fragments",id:"\ufe0f-setting-up-fragments",level:3},{value:"\ud83d\udcd0 Setting Up a global clipping plane",id:"-setting-up-a-global-clipping-plane",level:3},{value:"\ud83d\udcc2 Create a new Fragments Model",id:"-create-a-new-fragments-model",level:3},{value:"\ud83e\uddca Setting up the Geometry Engine",id:"-setting-up-the-geometry-engine",level:3},{value:"\ud83d\udd27 Creating Basic Geometries",id:"-creating-basic-geometries",level:3},{value:"\ud83c\udfd7\ufe0f Building Generation Logic",id:"\ufe0f-building-generation-logic",level:3},{value:"\ud83d\udcd0 Geometry Creation Process",id:"-geometry-creation-process",level:3},{value:"\ud83c\udfe2 Element Assembly",id:"-element-assembly",level:3},{value:"\ud83c\udfaf Final Steps",id:"-final-steps",level:3},{value:"\ud83d\udd04 Update Management",id:"-update-management",level:3},{value:"\ud83c\udfaf View Mode Management",id:"-view-mode-management",level:3},{value:"\ud83e\udde9 Adding User Interface",id:"-adding-user-interface",level:3},{value:"\ud83d\udcf1 Mobile-Friendly Menu",id:"-mobile-friendly-menu",level:3},{value:"\u23f1\ufe0f Measuring the Performance (optional)",id:"\ufe0f-measuring-the-performance-optional",level:3},{value:"\ud83c\udf89 Congratulations!",id:"-congratulations",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",hr:"hr",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)("div",{style:{position:"relative"},children:[(0,o.jsx)("iframe",{src:"https://thatopen.github.io/engine_fragment/examples/FragmentsModels/BuildingConfigurator"}),(0,o.jsx)("button",{class:"full-screen-btn",onClick:()=>window.open("https://thatopen.github.io/engine_fragment/examples/FragmentsModels/BuildingConfigurator"),children:"Go Full Screen"})]}),"\n",(0,o.jsx)(n.admonition,{title:"Source",type:"info",children:(0,o.jsxs)(n.p,{children:["Copying and pasting? We've got you covered! You can find the full source code of this tutorial ",(0,o.jsx)(n.a,{href:"https://github.com/ThatOpen/engine_fragment/blob/main/packages/fragments/src/FragmentsModels/examples/BuildingConfigurator/example.ts",children:"here"}),"."]})}),"\n",(0,o.jsx)(n.h2,{id:"building-a-configurator-",children:"Building a Configurator \ud83e\udd0f"}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.p,{children:"In this tutorial, we'll learn how to build a configurator using the Fragments API. We'll define some basic parameters (like building width and length) and generate one or multiple floors of a simple building based on them. Let\u2019s dive in!"}),"\n",(0,o.jsx)(n.h3,{id:"-importing-our-libraries",children:"\ud83d\udd96 Importing our Libraries"}),"\n",(0,o.jsx)(n.p,{children:"First things first, let's install all necessary dependencies to make this example work:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'import * as OBC from "@thatopen/components";\nimport * as OBF from "@thatopen/components-front";\nimport * as THREE from "three";\nimport * as BUI from "@thatopen/ui";\nimport * as WEBIFC from "web-ifc";\nimport Stats from "stats.js";\n// You have to import * as FRAGS from "@thatopen/fragments"\nimport * as FRAGS from "../../../index";\n'})}),"\n",(0,o.jsx)(n.h3,{id:"-setting-up-a-simple-scene",children:"\ud83c\udf0e Setting up a Simple Scene"}),"\n",(0,o.jsx)(n.p,{children:"To get started, let's set up a basic ThreeJS scene. This will serve as the foundation for our application and allow us to visualize the 3D models effectively:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'const container = document.getElementById("container")!;\n\nconst components = new OBC.Components();\n\nconst worlds = components.get(OBC.Worlds);\n\nconst world = worlds.create<\n  OBC.ShadowedScene,\n  OBC.OrthoPerspectiveCamera,\n  OBF.PostproductionRenderer\n>();\n\nworld.scene = new OBC.ShadowedScene(components);\nworld.renderer = new OBF.PostproductionRenderer(components, container);\nworld.camera = new OBC.OrthoPerspectiveCamera(components);\n\nworld.renderer.postproduction.enabled = true;\nworld.renderer.postproduction.style = OBF.PostproductionAspect.COLOR_PEN;\n\ncomponents.init();\n\nworld.camera.controls.setLookAt(12, 6, 8, 0, 0, -10);\n\nworld.renderer.three.shadowMap.enabled = true;\nworld.renderer.three.shadowMap.type = THREE.PCFSoftShadowMap;\n\nworld.scene.setup({\n  shadows: {\n    cascade: 1,\n    resolution: 1024,\n  },\n});\n\nconst prevBackground = world.scene.three.background;\n\nawait world.scene.updateShadows();\n\nworld.camera.controls.addEventListener("rest", async () => {\n  await world.scene.updateShadows();\n});\n\nconst axes = new THREE.AxesHelper(1);\nworld.scene.three.add(axes);\n'})}),"\n",(0,o.jsx)(n.p,{children:"We will also define some settings that will be used to create the building."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const settings = {\n  width: 20,\n  length: 30,\n  columnLengthDistance: 5,\n  columnWidthDistance: 5,\n  floorHeight: 4,\n  exteriorColumnWidth: 0.5,\n  exteriorColumnLength: 0.5,\n  interiorColumnWidth: 0.25,\n  interiorColumnLength: 0.25,\n  floorThickness: 0.3,\n  numberOfFloors: 10,\n  clipPlaneHeight: 1.5,\n  windowHeight: 2,\n  windowWidth: 1,\n  roofHeight: 2,\n};\n"})}),"\n",(0,o.jsx)(n.admonition,{title:"Do I need @thatopen/components?",type:"info",children:(0,o.jsx)(n.p,{children:"Not necessarily! While @thatopen/components simplifies the process of setting up a scene, you can always use plain ThreeJS to create your own custom scene setup. It's entirely up to your preference and project requirements! \ud83d\ude09"})}),"\n",(0,o.jsx)(n.h3,{id:"\ufe0f-setting-up-fragments",children:"\ud83d\udee0\ufe0f Setting Up Fragments"}),"\n",(0,o.jsx)(n.p,{children:"Now, let's configure the Fragments library core. This will allow us to load models effortlessly and start manipulating them with ease:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'const workerUrl = "https://thatopen.github.io/engine_fragment/resources/worker.mjs";\nconst fragments = components.get(OBC.FragmentsManager);\nfragments.init(workerUrl);\n\n// Temp until we publish the libraries, to be able to use postproduction\n// @ts-ignore\n\nfragments.core.settings.graphicsQuality = 1;\n\nworld.camera.controls.addEventListener("control", () => {\n  fragments.core.update();\n});\n\n// Once a model is available in the list, we can tell it\n// to use shadows and to use the clipping planes we are using\nfragments.core.models.list.onItemSet.add(({ value: model }) => {\n  model.tiles.onItemSet.add(({ value: mesh }) => {\n    if ("isMesh" in mesh) {\n      const mat = mesh.material as THREE.MeshStandardMaterial[];\n      if (mat[0].opacity === 1) {\n        mesh.castShadow = true;\n        mesh.receiveShadow = true;\n      }\n    }\n  });\n\n  model.getClippingPlanesEvent = () => {\n    return Array.from(world.renderer!.three.clippingPlanes) || [];\n  };\n});\n'})}),"\n",(0,o.jsx)(n.h3,{id:"-setting-up-a-global-clipping-plane",children:"\ud83d\udcd0 Setting Up a global clipping plane"}),"\n",(0,o.jsx)(n.p,{children:"Now, let's set up a global clipping plane. We'll use it to clip the building and see inside the floors."}),"\n",(0,o.jsx)(n.admonition,{title:"Clipping Planes?",type:"info",children:(0,o.jsx)(n.p,{children:"If you are unfamiliar with this API, check out the Clipping Planes and the ClipStyler tutorials!"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'const clipper = components.get(OBC.Clipper);\n\nconst clipStyler = components.get(OBF.ClipStyler);\nclipStyler.world = world;\n\nconst fillsMaterial = new THREE.MeshBasicMaterial({\n  color: 0x222222,\n  side: 2,\n});\n\nworld.renderer!.postproduction.excludedObjectsEnabled = true;\nworld.renderer!.postproduction.excludedObjectsPass.addExcludedMaterial(\n  fillsMaterial,\n);\n\nclipStyler.styles.set("BlackFill", {\n  fillsMaterial,\n});\n\nconst planeId = clipper.createFromNormalAndCoplanarPoint(\n  world,\n  new THREE.Vector3(0, -1, 0),\n  new THREE.Vector3(0, settings.clipPlaneHeight, 0),\n);\n\nconst plane = clipper.list.get(planeId)!;\nplane.visible = false;\n\nlet edges: OBF.ClipEdges | null = null;\n\nconst clearEdges = () => {\n  const keys = [...clipStyler.list.keys()];\n  for (const key of keys) clipStyler.list.delete(key);\n  clipStyler.list.clear();\n\n  edges = clipStyler.createFromClipping(planeId, {\n    items: { All: { style: "BlackFill" } },\n  });\n};\n\nlet planeTimeOut: any = null;\nconst planeTimeBuffer = 1000;\nconst updateClipPlane = () => {\n  plane.setFromNormalAndCoplanarPoint(\n    new THREE.Vector3(0, -1, 0),\n    new THREE.Vector3(0, settings.clipPlaneHeight, 0),\n  );\n  plane.update();\n\n  if (planeTimeOut) {\n    clearTimeout(planeTimeOut);\n  }\n  planeTimeOut = setTimeout(() => {\n    plane.onDraggingEnded.trigger();\n    if (edges) {\n      edges.three.frustumCulled = false;\n      for (const child of edges.three.children) {\n        child.frustumCulled = false;\n      }\n    }\n  }, planeTimeBuffer);\n};\n'})}),"\n",(0,o.jsx)(n.h3,{id:"-create-a-new-fragments-model",children:"\ud83d\udcc2 Create a new Fragments Model"}),"\n",(0,o.jsx)(n.p,{children:"Now, let's create a new empty Fragments model. We'll use it to store the building geometry."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'const bytes = FRAGS.EditUtils.newModel({ raw: true });\nconst model = await fragments.core.load(bytes, {\n  modelId: "example",\n  camera: world.camera.three,\n  raw: true,\n});\n\nworld.scene.three.add(model.object);\nawait fragments.core.update(true);\n'})}),"\n",(0,o.jsx)(n.h3,{id:"-setting-up-the-geometry-engine",children:"\ud83e\uddca Setting up the Geometry Engine"}),"\n",(0,o.jsx)(n.p,{children:"Now, let's set up the Geometry Engine. We'll use it to generate the building geometry."}),"\n",(0,o.jsx)(n.admonition,{title:"Geometry Engine?",type:"warning",children:(0,o.jsx)(n.p,{children:"The Geometry Engine is a library that allows us to easily generate geometry parametrically using the Fragments API."})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'const api = new WEBIFC.IfcAPI();\napi.SetWasmPath("https://unpkg.com/web-ifc@0.0.72/", true);\nawait api.Init();\nconst geometryEngine = new FRAGS.GeometryEngine(api);\n'})}),"\n",(0,o.jsx)(n.h3,{id:"-creating-basic-geometries",children:"\ud83d\udd27 Creating Basic Geometries"}),"\n",(0,o.jsx)(n.p,{children:"Now we'll create all the basic geometries that will be used to construct our building. These include materials, floor, columns, walls, windows, and more:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'// Materials\n\nconst defaultMat = new THREE.MeshLambertMaterial({ color: "white", side: 2 });\n\n// Floor\n\nconst ground = new THREE.Mesh<\n  THREE.BufferGeometry,\n  THREE.MeshLambertMaterial | THREE.MeshBasicMaterial\n>(new THREE.BufferGeometry(), defaultMat);\n\nworld.scene.three.add(ground);\nground.receiveShadow = true;\nground.frustumCulled = false;\n\n// Grid\n\n// Column\n\nconst exteriorColumnGeometry = new THREE.BufferGeometry();\nconst interiorColumnGeometry = new THREE.BufferGeometry();\nconst cornerWallGeometry = new THREE.BufferGeometry();\nconst windowFrameGeometry = new THREE.BufferGeometry();\nconst windowTopGeometry = new THREE.BufferGeometry();\nconst roofTopGeometry = new THREE.BufferGeometry();\nconst floorGeometry = new THREE.BufferGeometry();\nconst cutFloorGeometry = new THREE.BufferGeometry();\nconst staircaseHoleGeometry = new THREE.BufferGeometry();\n\nconst staircaseWallGeometry1 = new THREE.BufferGeometry();\nconst staircaseWallGeometry2 = new THREE.BufferGeometry();\n'})}),"\n",(0,o.jsx)(n.h3,{id:"\ufe0f-building-generation-logic",children:"\ud83c\udfd7\ufe0f Building Generation Logic"}),"\n",(0,o.jsx)(n.p,{children:"Now let's define the main function that will regenerate the building fragments based on our settings. This function will create all the building elements and position them correctly:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"let processing = false;\n\n// We'll use this for boolean operations\n\n// Corner cuts\nconst fullFloorMesh = new THREE.Mesh(floorGeometry);\nconst corner1Mesh = new THREE.Mesh(exteriorColumnGeometry);\nconst corner2Mesh = new THREE.Mesh(exteriorColumnGeometry);\nconst corner3Mesh = new THREE.Mesh(exteriorColumnGeometry);\nconst corner4Mesh = new THREE.Mesh(exteriorColumnGeometry);\n\nconst staircaseHoleMesh = new THREE.Mesh(staircaseHoleGeometry);\n\nconst regenerateFragments = async () => {\n  const elementsData: FRAGS.NewElementData[] = [];\n\n  await fragments.core.editor.reset(model.modelId);\n\n  // Create floor\n\n  const floorPadding = 10;\n  const fw = settings.width + floorPadding * 2;\n  const fl = settings.length + floorPadding * 2;\n\n  // prettier-ignore\n  geometryEngine.getExtrusion(ground.geometry, {\n  profilePoints: [\n    0, 0, 0,\n    0, 0, fl,\n    fw, 0, fl,\n    fw, 0, 0,\n    0, 0, 0,\n  ],\n  direction: [0, 1, 0],\n  cap: true,\n  length: settings.floorThickness,\n});\n\n  ground.position.y = -settings.floorThickness;\n  ground.position.x = -floorPadding;\n  ground.position.z = -floorPadding;\n  ground.geometry.computeBoundingBox();\n\n  // Create base items\n\n  const matId = fragments.core.editor.createMaterial(\n    model.modelId,\n    new THREE.MeshLambertMaterial({\n      color: new THREE.Color(1, 1, 1),\n      side: THREE.DoubleSide,\n    }),\n  );\n\n  const ltId = fragments.core.editor.createLocalTransform(\n    model.modelId,\n    new THREE.Matrix4().identity(),\n  );\n\n  // CREATE GEOMETRIES\n"})}),"\n",(0,o.jsx)(n.h3,{id:"-geometry-creation-process",children:"\ud83d\udcd0 Geometry Creation Process"}),"\n",(0,o.jsx)(n.p,{children:"Now we'll create all the individual geometries that make up our building. This includes exterior columns, interior columns, walls, windows, floors, and more. Each geometry is carefully calculated based on our building parameters:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'const w = settings.width;\n  const l = settings.length;\n\n  const corners = [\n    new THREE.Vector3(0, 0, 0),\n    new THREE.Vector3(settings.width, 0, 0),\n    new THREE.Vector3(settings.width, 0, settings.length),\n    new THREE.Vector3(0, 0, settings.length),\n    new THREE.Vector3(0, 0, 0), // Repeating this make facade iteration easier\n  ];\n\n  const extColumnX = settings.width - settings.exteriorColumnWidth;\n  const extColumnZ = settings.length - settings.exteriorColumnLength;\n\n  const exteriorColumnPositions: THREE.Vector3[] = [\n    new THREE.Vector3(0, 0, 0),\n    new THREE.Vector3(extColumnX, 0, 0),\n    new THREE.Vector3(extColumnX, 0, extColumnZ),\n    new THREE.Vector3(0, 0, extColumnZ),\n  ];\n\n  // Exterior column\n\n  const ecl = settings.exteriorColumnLength;\n  const ecw = settings.exteriorColumnWidth;\n  // prettier-ignore\n  geometryEngine.getExtrusion(exteriorColumnGeometry, {\n    profilePoints: [\n      0, 0, 0,\n      0, 0, ecl,\n      ecw, 0, ecl,\n      ecw, 0, 0,\n    ],\n    direction: [0, 1, 0],\n    cap: true,\n    length: settings.floorHeight,\n  });\n\n  const extColumnGeoId = fragments.core.editor.createShell(\n    model.modelId,\n    exteriorColumnGeometry,\n  );\n\n  // Corner wall\n\n  // Windows are 1 m wide, so we need this to solve the corners\n\n  const cwLength = settings.exteriorColumnLength * 2;\n  const cwWidth = 1 - ecw;\n\n  // prettier-ignore\n  geometryEngine.getExtrusion(cornerWallGeometry, {\n    profilePoints: [\n      0, 0, 0,\n      0, 0, cwLength,\n      cwWidth, 0, cwLength,\n      cwWidth, 0, 0,\n      0, 0, 0,\n    ],\n    direction: [0, 1, 0],\n    length: settings.floorHeight,\n  });\n\n  const cornerWallGeoId = fragments.core.editor.createShell(\n    model.modelId,\n    cornerWallGeometry,\n  );\n\n  // Interior column\n\n  const icProfilePoints = geometryEngine.getProfilePoints({\n    type: FRAGS.ProfileType.H,\n    width: settings.interiorColumnWidth,\n    depth: settings.interiorColumnLength,\n    thickness: 0.03,\n    flangeThickness: 0.02,\n  });\n\n  const icProfilePointsHorizontal = geometryEngine.transformPoints(\n    icProfilePoints,\n    new THREE.Matrix4().makeRotationX(Math.PI / 2),\n  );\n\n  // prettier-ignore\n  geometryEngine.getExtrusion(interiorColumnGeometry, {\n    profilePoints: icProfilePointsHorizontal,\n    direction: [0, 1, 0],\n    length: settings.floorHeight - settings.floorThickness,\n  });\n\n  const intColumnGeoId = fragments.core.editor.createShell(\n    model.modelId,\n    interiorColumnGeometry,\n  );\n\n  // Staircase hole\n\n  const stairCaseWidth = 3;\n  const stairCaseLength = 5;\n\n  // prettier-ignore\n  geometryEngine.getExtrusion(staircaseHoleGeometry, {\n    profilePoints: [\n      0, 0, 0,\n      0, 0, stairCaseLength,\n      stairCaseWidth, 0, stairCaseLength,\n      stairCaseWidth, 0, 0,\n    ],\n    direction: [0, 1, 0],\n    length: 1,\n  });\n\n  staircaseHoleMesh.position.set(0, -0.5, 0);\n\n  // Staircase walls\n\n  const wallThickness = 0.2;\n\n  // prettier-ignore\n  geometryEngine.getWall(staircaseWallGeometry1, {\n    start: [stairCaseWidth, 0, settings.windowWidth],\n    end: [stairCaseWidth, settings.floorHeight - settings.floorThickness, stairCaseLength + wallThickness / 2],\n    direction: [0, 1, 0],\n    elevation: 0,\n    offset: 0,\n    thickness: wallThickness,\n    cuttingPlaneNormal: [0, 0, 0],\n    cuttingPlanePosition: [0, 0, 0],\n    height: settings.floorHeight - settings.floorThickness,\n  });\n\n  const staircaseWall1GeoId = fragments.core.editor.createShell(\n    model.modelId,\n    staircaseWallGeometry1,\n  );\n\n  // prettier-ignore\n  geometryEngine.getWall(staircaseWallGeometry2, {\n    start: [0, 0, stairCaseLength],\n    end: [stairCaseWidth - wallThickness / 2, 0, stairCaseLength],\n    direction: [0, 1, 0],\n    elevation: 0,\n    offset: 0,\n    thickness: wallThickness,\n    cuttingPlaneNormal: [0, 0, 0],\n    cuttingPlanePosition: [0, 0, 0],\n    height: settings.floorHeight - settings.floorThickness,\n  });\n\n  const staircaseWall2GeoId = fragments.core.editor.createShell(\n    model.modelId,\n    staircaseWallGeometry2,\n  );\n\n  // Floor\n\n  // prettier-ignore\n  geometryEngine.getExtrusion(floorGeometry, {\n    profilePoints: [\n      0, 0, 0,\n      0, 0, l,\n      w, 0, l,\n      w, 0, 0,\n    ],\n    direction: [0, 1, 0],\n    cap: true,\n    length: settings.floorThickness,\n  });\n\n  // Subtract floor corners with columns using booleans\n\n  corner1Mesh.position.copy(exteriorColumnPositions[0]);\n  corner2Mesh.position.copy(exteriorColumnPositions[1]);\n  corner3Mesh.position.copy(exteriorColumnPositions[2]);\n  corner4Mesh.position.copy(exteriorColumnPositions[3]);\n  fullFloorMesh.updateMatrixWorld(true);\n  corner1Mesh.updateMatrixWorld(true);\n  corner2Mesh.updateMatrixWorld(true);\n  corner3Mesh.updateMatrixWorld(true);\n  corner4Mesh.updateMatrixWorld(true);\n  staircaseHoleMesh.updateMatrixWorld(true);\n  geometryEngine.getBooleanOperation(cutFloorGeometry, {\n    target: fullFloorMesh,\n    operands: [\n      corner1Mesh,\n      corner2Mesh,\n      corner3Mesh,\n      corner4Mesh,\n      staircaseHoleMesh,\n    ],\n    type: "DIFFERENCE",\n  });\n\n  const tempMesh6 = new THREE.Mesh(cutFloorGeometry, defaultMat);\n  world.scene.three.add(tempMesh6);\n  tempMesh6.position.y += 10;\n\n  const floorGeoId = fragments.core.editor.createShell(\n    model.modelId,\n    cutFloorGeometry,\n  );\n\n  // Window frame\n\n  // prettier-ignore\n  geometryEngine.getSweep(windowFrameGeometry, {\n    profilePoints: [\n      0, 0, 0,\n      0.1, 0, 0,\n      0.1, 0.1, 0,\n      0, 0.1, 0,\n      0, 0, 0,\n    ],\n    curvePoints: [\n      0, 0, 0,\n      0, settings.windowHeight, 0,\n      settings.windowWidth, settings.windowHeight, 0,\n      settings.windowWidth, 0, 0,\n      0, 0, 0,\n    ],\n  });\n\n  const windowFrameGeoId = fragments.core.editor.createShell(\n    model.modelId,\n    windowFrameGeometry,\n  );\n\n  // Window top\n\n  const wtHeight = settings.floorHeight - settings.windowHeight;\n\n  // prettier-ignore\n  geometryEngine.getExtrusion(windowTopGeometry, {\n      profilePoints: [\n        0, 0, 0,\n        0, wtHeight, 0,\n        settings.windowWidth, wtHeight, 0,\n        settings.windowWidth, 0, 0,\n      ],\n      direction: [0, 0, 1],\n      cap: true,\n      length: settings.floorThickness,\n    });\n\n  const windowTopGeoId = fragments.core.editor.createShell(\n    model.modelId,\n    windowTopGeometry,\n  );\n\n  // Roof top\n\n  const roofTopThickness = 0.15;\n  const roofTopWidth = 0.2;\n\n  // prettier-ignore\n  geometryEngine.getSweep(roofTopGeometry, {\n    profilePoints: [\n      0, 0, 0,\n      1, 0, 0,\n      1, roofTopThickness, 0,\n      0, roofTopThickness, 0,\n      0, 0, 0,\n    ],\n    curvePoints: [\n      0, 0, 0,\n      0, 0, roofTopWidth,\n      0, settings.windowHeight, roofTopWidth,\n      0, settings.windowHeight, 0,\n    ],\n  });\n\n  const roofTopGeoId = fragments.core.editor.createShell(\n    model.modelId,\n    roofTopGeometry,\n  );\n\n  // CREATE ELEMENTS\n'})}),"\n",(0,o.jsx)(n.h3,{id:"-element-assembly",children:"\ud83c\udfe2 Element Assembly"}),"\n",(0,o.jsx)(n.p,{children:"Now we'll create all the building elements by positioning our geometries throughout the building. This includes placing columns, floors, walls, windows, and other structural elements at the correct locations:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'const tempObject = new THREE.Object3D();\n\n  // Exterior columns\n\n  for (const position of exteriorColumnPositions) {\n    for (let i = 0; i < settings.numberOfFloors; i++) {\n      tempObject.position.copy(position);\n      tempObject.position.y = i * settings.floorHeight;\n      tempObject.updateMatrix();\n\n      elementsData.push({\n        attributes: {\n          _category: {\n            value: "test",\n          },\n        },\n        globalTransform: tempObject.matrix.clone(),\n        samples: [\n          {\n            localTransform: ltId,\n            representation: extColumnGeoId,\n            material: matId,\n          },\n        ],\n      });\n    }\n  }\n\n  // Interior columns\n\n  const interiorColumnPositions: THREE.Vector3[] = [];\n\n  const icLenthCount = Math.floor(\n    settings.length / settings.columnLengthDistance,\n  );\n\n  const icWidthCount = Math.floor(\n    settings.width / settings.columnWidthDistance,\n  );\n\n  for (let i = 0; i <= icLenthCount; i++) {\n    const z = i * settings.columnLengthDistance;\n    for (let j = 0; j <= icWidthCount; j++) {\n      const isCorner1 = i === 0 && j === 0;\n      const isCorner2 = i === 0 && j === icWidthCount;\n      const isCorner3 = i === icLenthCount && j === 0;\n      const isCorner4 = i === icLenthCount && j === icWidthCount;\n\n      if (isCorner1 || isCorner2 || isCorner3 || isCorner4) {\n        continue;\n      }\n\n      const x = j * settings.columnWidthDistance;\n      interiorColumnPositions.push(new THREE.Vector3(x, 0, z));\n    }\n  }\n\n  for (const position of interiorColumnPositions) {\n    for (let i = 0; i < settings.numberOfFloors; i++) {\n      tempObject.position.copy(position);\n      tempObject.position.y = i * settings.floorHeight;\n      tempObject.updateMatrix();\n\n      elementsData.push({\n        attributes: {\n          _category: {\n            value: "test",\n          },\n        },\n        globalTransform: tempObject.matrix.clone(),\n        samples: [\n          {\n            localTransform: ltId,\n            representation: intColumnGeoId,\n            material: matId,\n          },\n        ],\n      });\n    }\n  }\n\n  // Floors\n\n  for (let i = 0; i < settings.numberOfFloors; i++) {\n    const fh = (i + 1) * settings.floorHeight - settings.floorThickness;\n    tempObject.position.set(0, fh, 0);\n    tempObject.updateMatrix();\n\n    elementsData.push({\n      attributes: {\n        _category: {\n          value: "test",\n        },\n      },\n      globalTransform: tempObject.matrix.clone(),\n      samples: [\n        {\n          localTransform: ltId,\n          representation: floorGeoId,\n          material: matId,\n        },\n      ],\n    });\n  }\n\n  // Staircase walls\n\n  for (let i = 0; i < settings.numberOfFloors; i++) {\n    tempObject.position.set(0, i * settings.floorHeight, 0);\n    tempObject.rotation.set(0, 0, 0);\n    tempObject.updateMatrix();\n\n    elementsData.push({\n      attributes: {\n        _category: {\n          value: "test",\n        },\n      },\n      globalTransform: tempObject.matrix.clone(),\n      samples: [\n        {\n          localTransform: ltId,\n          representation: staircaseWall1GeoId,\n          material: matId,\n        },\n      ],\n    });\n\n    elementsData.push({\n      attributes: {\n        _category: {\n          value: "test",\n        },\n      },\n      globalTransform: tempObject.matrix.clone(),\n      samples: [\n        {\n          localTransform: ltId,\n          representation: staircaseWall2GeoId,\n          material: matId,\n        },\n      ],\n    });\n\n    // We\'ll reuse the window frame for the door\n\n    tempObject.position.set(\n      stairCaseWidth,\n      i * settings.floorHeight,\n      settings.windowWidth,\n    );\n\n    tempObject.rotation.y = Math.PI / 2;\n    tempObject.updateMatrix();\n\n    elementsData.push({\n      attributes: {\n        _category: {\n          value: "test",\n        },\n      },\n      globalTransform: tempObject.matrix.clone(),\n      samples: [\n        {\n          localTransform: ltId,\n          representation: windowFrameGeoId,\n          material: matId,\n        },\n      ],\n    });\n\n    tempObject.position.y += settings.windowHeight;\n    tempObject.position.x -= 0.1;\n    tempObject.updateMatrix();\n\n    elementsData.push({\n      attributes: {\n        _category: {\n          value: "test",\n        },\n      },\n      globalTransform: tempObject.matrix.clone(),\n      samples: [\n        {\n          localTransform: ltId,\n          representation: windowTopGeoId,\n          material: matId,\n        },\n      ],\n    });\n  }\n\n  // Corner walls\n\n  for (let j = 0; j < settings.numberOfFloors; j++) {\n    for (let i = 0; i < corners.length - 1; i++) {\n      const corner = corners[i];\n      const nextCorner = corners[i + 1];\n      const direction = nextCorner.clone().sub(corner).normalize();\n      const distance = corner.distanceTo(nextCorner);\n\n      const dirNormal = new THREE.Vector3();\n      dirNormal.crossVectors(direction, new THREE.Vector3(0, 1, 0));\n\n      tempObject.position.copy(corner);\n      tempObject.lookAt(nextCorner);\n      tempObject.rotateY(-Math.PI / 2);\n      tempObject.position.add(\n        direction.clone().multiplyScalar(settings.exteriorColumnLength),\n      );\n      tempObject.position.add(\n        dirNormal.clone().multiplyScalar(-settings.exteriorColumnWidth / 2),\n      );\n      tempObject.position.y = j * settings.floorHeight;\n      tempObject.updateMatrix();\n\n      // First wall\n\n      elementsData.push({\n        attributes: {\n          _category: {\n            value: "test",\n          },\n        },\n        globalTransform: tempObject.matrix.clone(),\n        samples: [\n          {\n            localTransform: ltId,\n            representation: cornerWallGeoId,\n            material: matId,\n          },\n        ],\n      });\n\n      // Second wall\n\n      // We subtract 2 because the first and last windows that are missing\n      const offsetToNextCornerWall = distance - 2 + cwWidth;\n\n      tempObject.position.add(\n        direction.clone().multiplyScalar(offsetToNextCornerWall),\n      );\n\n      tempObject.updateMatrix();\n\n      elementsData.push({\n        attributes: {\n          _category: {\n            value: "test",\n          },\n        },\n        globalTransform: tempObject.matrix.clone(),\n        samples: [\n          {\n            localTransform: ltId,\n            representation: cornerWallGeoId,\n            material: matId,\n          },\n        ],\n      });\n    }\n  }\n\n  // Window frames and tops\n\n  // Windows are 1m wide, so each meter has one window\n\n  for (let k = 0; k < settings.numberOfFloors; k++) {\n    for (let i = 0; i < corners.length - 1; i++) {\n      const corner = corners[i];\n      const nextCorner = corners[i + 1];\n      const distance = corner.distanceTo(nextCorner);\n      const direction = nextCorner.clone().sub(corner).normalize();\n\n      for (let j = 1; j < distance - 1; j++) {\n        tempObject.position.copy(corner);\n        tempObject.lookAt(nextCorner);\n        tempObject.rotateY(-Math.PI / 2);\n        tempObject.position.add(direction.clone().multiplyScalar(j));\n        tempObject.position.y = k * settings.floorHeight;\n        tempObject.updateMatrix();\n\n        const norDir = new THREE.Vector3();\n        norDir.crossVectors(direction, new THREE.Vector3(0, 1, 0));\n\n        // Window frame\n\n        elementsData.push({\n          attributes: {\n            _category: {\n              value: "test",\n            },\n          },\n          globalTransform: tempObject.matrix.clone(),\n          samples: [\n            {\n              localTransform: ltId,\n              representation: windowFrameGeoId,\n              material: matId,\n            },\n          ],\n        });\n\n        // Window top\n\n        tempObject.position.y += settings.windowHeight;\n        tempObject.position.add(norDir.clone().multiplyScalar(-0.3));\n        tempObject.updateMatrix();\n\n        elementsData.push({\n          attributes: {\n            _category: {\n              value: "test",\n            },\n          },\n          globalTransform: tempObject.matrix.clone(),\n          samples: [\n            {\n              localTransform: ltId,\n              representation: windowTopGeoId,\n              material: matId,\n            },\n          ],\n        });\n      }\n    }\n  }\n\n  // Roof\n\n  for (let i = 0; i < corners.length - 1; i++) {\n    const corner = corners[i];\n    const nextCorner = corners[i + 1];\n    const distance = corner.distanceTo(nextCorner);\n    const direction = nextCorner.clone().sub(corner).normalize();\n\n    for (let j = 0; j < distance; j++) {\n      tempObject.position.copy(corner);\n      tempObject.lookAt(nextCorner);\n      tempObject.rotateY(Math.PI / 2);\n      tempObject.position.add(direction.clone().multiplyScalar(j));\n      tempObject.position.y = settings.floorHeight * settings.numberOfFloors;\n      tempObject.updateMatrix();\n\n      elementsData.push({\n        attributes: {\n          _category: {\n            value: "test",\n          },\n        },\n        globalTransform: tempObject.matrix.clone(),\n        samples: [\n          {\n            localTransform: ltId,\n            representation: roofTopGeoId,\n            material: matId,\n          },\n        ],\n      });\n    }\n  }\n\n  await fragments.core.editor.createElements(model.modelId, elementsData);\n\n  clearEdges();\n\n  await fragments.core.update(true);\n\n  processing = false;\n};\n'})}),"\n",(0,o.jsx)(n.h3,{id:"-final-steps",children:"\ud83c\udfaf Final Steps"}),"\n",(0,o.jsx)(n.p,{children:"Once all elements are created, we update the fragments model and clear any processing flags to prepare for the next regeneration cycle."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"await regenerateFragments();\n"})}),"\n",(0,o.jsx)(n.h3,{id:"-update-management",children:"\ud83d\udd04 Update Management"}),"\n",(0,o.jsx)(n.p,{children:"To ensure smooth performance, we'll implement a throttled update system that prevents excessive regeneration of the building when parameters change rapidly:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"let lastUpdate: any = null;\nconst maxUpdateRate = 1000; // ms\nconst requestFragmentsUpdate = async () => {\n  if (processing) {\n    return;\n  }\n  processing = true;\n\n  if (lastUpdate) {\n    clearTimeout(lastUpdate);\n  }\n  lastUpdate = setTimeout(() => {\n    regenerateFragments();\n  }, maxUpdateRate);\n};\n"})}),"\n",(0,o.jsx)(n.h3,{id:"-view-mode-management",children:"\ud83c\udfaf View Mode Management"}),"\n",(0,o.jsx)(n.p,{children:"We'll implement different view modes to allow users to switch between 3D model view and floor plan view, enhancing the user experience:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'enum ViewMode {\n  MODEL,\n  PLAN,\n}\n\nconst viewModes: [ViewMode, string][] = [\n  [ViewMode.MODEL, "Model"],\n  [ViewMode.PLAN, "Plan"],\n];\n\nconst updateCamera = (\n  camera: THREE.PerspectiveCamera | THREE.OrthographicCamera,\n) => {\n  for (const [, model] of fragments.core.models.list) {\n    model.useCamera(camera);\n  }\n  world.renderer!.postproduction.updateCamera();\n};\n\nlet viewMode = ViewMode.MODEL;\nconst setViewMode = async (mode: ViewMode) => {\n  viewMode = mode;\n  if (viewMode === ViewMode.MODEL) {\n    world.camera.controls.setLookAt(5, 5, 5, 0, 0, 0);\n    await world.camera.projection.set("Perspective");\n    await world.camera.set("Orbit");\n    world.scene.three.background = prevBackground;\n    world.renderer!.postproduction.style = OBF.PostproductionAspect.COLOR_PEN;\n    world.scene.shadowsEnabled = true;\n    updateCamera(world.camera.three);\n  } else {\n    world.camera.controls.setLookAt(5, 5, 5, 5, 0, 5);\n    await world.camera.projection.set("Orthographic");\n    await world.camera.set("Plan");\n    world.renderer!.postproduction.style = OBF.PostproductionAspect.PEN;\n    world.scene.three.background = null;\n    world.scene.shadowsEnabled = false;\n    updateCamera(world.camera.three);\n  }\n};\n'})}),"\n",(0,o.jsx)(n.h3,{id:"-adding-user-interface",children:"\ud83e\udde9 Adding User Interface"}),"\n",(0,o.jsxs)(n.p,{children:["We will use the ",(0,o.jsx)(n.code,{children:"@thatopen/ui"})," library to add some simple and cool UI elements to our app. First, we need to call the ",(0,o.jsx)(n.code,{children:"init"})," method of the ",(0,o.jsx)(n.code,{children:"BUI.Manager"})," class to initialize the library:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'BUI.Manager.init();\n\nconst [panel] = BUI.Component.create<BUI.PanelSection, any>((_) => {\n  return BUI.html`\n    <bim-panel style="min-width: 25rem;" id="controls-panel" active label="Element Editor" class="options-menu">\n\n      <bim-panel-section label="Controls">\n\n      <bim-dropdown label="View mode" @change=${(e: any) => {\n        setViewMode(e.target.value[0]);\n      }}>\n        ${viewModes.map(([key, value]) => BUI.html`<bim-option label=${value} ?checked=${key === ViewMode.MODEL} value=${key}></bim-option>`)}\n      </bim-dropdown>\n\n      <bim-number-input label="Width" slider min=20 max=50 step=1 value=${settings.width} @change=${(\n        e: any,\n      ) => {\n        settings.width = e.target.value;\n        requestFragmentsUpdate();\n      }}></bim-number-input>\n\n      <bim-number-input label="Length" slider min=20 max=50 step=1 value=${settings.length} @change=${(\n        e: any,\n      ) => {\n        settings.length = e.target.value;\n        requestFragmentsUpdate();\n      }}></bim-number-input>\n\n      <bim-number-input label="Floor Height" slider min=3 max=5 step=0.1 value=${settings.floorHeight} @change=${(\n        e: any,\n      ) => {\n        settings.floorHeight = e.target.value;\n        requestFragmentsUpdate();\n      }}></bim-number-input>\n\n      <bim-number-input label="Number of floors" slider min=2 max=40 step=1 value=${settings.numberOfFloors} @change=${(\n        e: any,\n      ) => {\n        settings.numberOfFloors = e.target.value;\n        requestFragmentsUpdate();\n      }}></bim-number-input>\n\n      <bim-number-input label="Column Length Distance" slider min=5 max=10 step=1 value=${settings.columnLengthDistance} @change=${(\n        e: any,\n      ) => {\n        settings.columnLengthDistance = e.target.value;\n        requestFragmentsUpdate();\n      }}></bim-number-input>\n      \n      <bim-number-input label="Column Width Distance" slider min=5 max=10 step=1 value=${settings.columnWidthDistance} @change=${(\n        e: any,\n      ) => {\n        settings.columnWidthDistance = e.target.value;\n        requestFragmentsUpdate();\n      }}></bim-number-input>\n\n      <bim-number-input label="Clip Plane Height" slider min=0 max=100 step=0.1 value=${settings.clipPlaneHeight} @change=${(\n        e: any,\n      ) => {\n        settings.clipPlaneHeight = e.target.value;\n        updateClipPlane();\n      }}></bim-number-input>\n\n      </bim-panel-section>\n\n    </bim-panel>\n  `;\n}, {});\n\ndocument.body.append(panel);\n'})}),"\n",(0,o.jsx)(n.h3,{id:"-mobile-friendly-menu",children:"\ud83d\udcf1 Mobile-Friendly Menu"}),"\n",(0,o.jsx)(n.p,{children:"We will make some logic that adds a button to the screen when the user is visiting our app from their phone, allowing to show or hide the menu. Otherwise, the menu would make the app unusable."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'const button = BUI.Component.create<BUI.PanelSection>(() => {\n  const onClick = () => {\n    if (panel.classList.contains("options-menu-visible")) {\n      panel.classList.remove("options-menu-visible");\n    } else {\n      panel.classList.add("options-menu-visible");\n    }\n  };\n\n  return BUI.html`\n    <bim-button class="phone-menu-toggler" icon="solar:settings-bold"\n      @click=${onClick}>\n    </bim-button>\n  `;\n});\n\ndocument.body.append(button);\n'})}),"\n",(0,o.jsx)(n.h3,{id:"\ufe0f-measuring-the-performance-optional",children:"\u23f1\ufe0f Measuring the Performance (optional)"}),"\n",(0,o.jsxs)(n.p,{children:["We'll use the ",(0,o.jsx)(n.a,{href:"https://github.com/mrdoob/stats.js",children:"Stats.js"})," to measure the performance of our app. We will add it to the top left corner of the viewport. This way, we'll make sure that the memory consumption and the FPS of our app are under control."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'const stats = new Stats();\nstats.showPanel(2);\ndocument.body.append(stats.dom);\nstats.dom.style.left = "0px";\nstats.dom.style.zIndex = "unset";\nworld.renderer.onBeforeUpdate.add(() => stats.begin());\nworld.renderer.onAfterUpdate.add(() => stats.end());\n'})}),"\n",(0,o.jsx)(n.h3,{id:"-congratulations",children:"\ud83c\udf89 Congratulations!"}),"\n",(0,o.jsx)(n.p,{children:"You've successfully built a building configurator using the Fragments API! \ud83d\ude80\nNow you can create parametric buildings with customizable dimensions, floors, and structural elements. Ready to explore more? Check out our other tutorials to unlock the full potential of Fragments! \ud83d\udca1"})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var o=t(6540);const r={},i=o.createContext(r);function s(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);