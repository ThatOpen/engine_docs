"use strict";(self.webpackChunkengine_docs=self.webpackChunkengine_docs||[]).push([[4556],{1230:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>s,default:()=>c,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var a=t(4848),o=t(8453);const r={},s=void 0,l={id:"Tutorials/Components/Front/PostproductionRenderer",title:"PostproductionRenderer",description:'window.open("https://thatopen.github.io/engine_components/examples/PostproductionRenderer")} >Go Full Screen',source:"@site/docs/Tutorials/Components/Front/PostproductionRenderer.mdx",sourceDirName:"Tutorials/Components/Front",slug:"/Tutorials/Components/Front/PostproductionRenderer",permalink:"/Tutorials/Components/Front/PostproductionRenderer",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Outliner",permalink:"/Tutorials/Components/Front/Outliner"},next:{title:"VolumeMeasurement",permalink:"/Tutorials/Components/Front/VolumeMeasurement"}},i={},d=[{value:"\ud83c\udfa5 Great graphics",id:"-great-graphics",level:3},{value:"\ud83c\udf0e Setting up a simple scene",id:"-setting-up-a-simple-scene",level:3},{value:"\ud83d\udee0\ufe0f Setting Up Fragments",id:"\ufe0f-setting-up-fragments",level:3},{value:"\ud83d\udcc2 Loading Fragments Models",id:"-loading-fragments-models",level:3},{value:"\ud83c\udfac Turning on the Postproduction",id:"-turning-on-the-postproduction",level:3},{value:"\ud83d\udcf9 Switching the camera",id:"-switching-the-camera",level:3},{value:"\u23f1\ufe0f Measuring the performance (optional)",id:"\ufe0f-measuring-the-performance-optional",level:3},{value:"\ud83e\udde9 Adding some UI",id:"-adding-some-ui",level:3}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)("div",{style:{position:"relative"},children:[(0,a.jsx)("iframe",{src:"https://thatopen.github.io/engine_components/examples/PostproductionRenderer"}),(0,a.jsx)("button",{class:"full-screen-btn",onClick:()=>window.open("https://thatopen.github.io/engine_components/examples/PostproductionRenderer"),children:"Go Full Screen"})]}),"\n",(0,a.jsx)(n.admonition,{title:"Source",type:"info",children:(0,a.jsxs)(n.p,{children:["Copying and pasting? We've got you covered! You can find the full source code of this tutorial ",(0,a.jsx)(n.a,{href:"https://github.com/ThatOpen/engine_components/blob/main/packages/front/src/core/PostproductionRenderer/example.ts",children:"here"}),"."]})}),"\n",(0,a.jsx)(n.h3,{id:"-great-graphics",children:"\ud83c\udfa5 Great graphics"}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.p,{children:"Postproduction effects enrich your 3D scenes. There are several post-production effects, such as adding shadows, rendering outlines, adding ambient occlusion and applying bloom, that can enhance and make your scene look cool. In this tutorial, you'll learn how to do it."}),"\n",(0,a.jsx)(n.admonition,{title:"Postproduction?",type:"tip",children:(0,a.jsx)(n.p,{children:"The simple Three.js renderer isn't bad, but it's pretty basic. Postproduction are a collection of effects you can add to your scene to make it look much better. Of course, this means consuming more resources, but luckily for us, the power of devices is proportional to the size of its screen, so we should be able to enjoy this beauty in most scene even from our smartphones!"})}),"\n",(0,a.jsx)(n.p,{children:"In this tutorial, we will import:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"three"})," to create some 3D items."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"@thatopen/components"})," to set up the barebone of our app."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"@thatopen/ui"})," to add some simple and cool UI menus."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"@thatopen/components-front"})," to use some frontend-oriented components."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Stats.js"})," (optional) to measure the performance of our app."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"GTAOPass"})," (optional) to control the ambient occlusion parameters."]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'import * as THREE from "three";\nimport * as OBC from "@thatopen/components";\nimport Stats from "stats.js";\nimport * as BUI from "@thatopen/ui";\n// You have to import * as OBF from "@thatopen/components-front"\nimport * as OBF from "../..";\n'})}),"\n",(0,a.jsx)(n.h3,{id:"-setting-up-a-simple-scene",children:"\ud83c\udf0e Setting up a simple scene"}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.p,{children:"We will start by creating a simple scene with a camera and a renderer. If you don't know how to set up a scene, you can check the Worlds tutorial. Notice how we use the PostproductionRenderer in this case. We will also instantiate fragments right away to load BIM models."}),"\n",(0,a.jsx)(n.admonition,{title:"Fragments?",type:"tip",children:(0,a.jsx)(n.p,{children:"If you are not familiar with fragments, check out the IfcLoader tutorial!"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'const components = new OBC.Components();\n\nconst worlds = components.get(OBC.Worlds);\nconst world = worlds.create<\n  OBC.SimpleScene,\n  OBC.OrthoPerspectiveCamera,\n  OBF.PostproductionRenderer\n>();\n\nworld.scene = new OBC.SimpleScene(components);\nworld.scene.setup();\nworld.scene.three.background = null;\n\nconst container = document.getElementById("container")!;\nworld.renderer = new OBF.PostproductionRenderer(components, container);\nworld.camera = new OBC.OrthoPerspectiveCamera(components);\nawait world.camera.controls.setLookAt(68, 23, -8.5, 21.5, -5.5, 23);\n\ncomponents.init();\n\nconst grids = components.get(OBC.Grids);\nconst grid = grids.create(world);\ngrid.config.color.set(0x666666);\n'})}),"\n",(0,a.jsx)(n.p,{children:"We'll make the background of the scene transparent so that it looks good in our docs page, but you don't have to do that in your app!"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"world.scene.three.background = null;\n"})}),"\n",(0,a.jsx)(n.p,{children:"We'll also set up the update logic for the renderer in manual mode (if enabled)."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'const updateIfManualMode = () => {\n  if (world.renderer!.mode === OBC.RendererMode.MANUAL) {\n    world.renderer!.needsUpdate = true;\n  }\n};\n\nworld.camera.controls.addEventListener("update", updateIfManualMode);\nworld.renderer.onResize.add(updateIfManualMode);\n'})}),"\n",(0,a.jsx)(n.h3,{id:"\ufe0f-setting-up-fragments",children:"\ud83d\udee0\ufe0f Setting Up Fragments"}),"\n",(0,a.jsx)(n.p,{children:"Now, let's configure the FragmentsManager. This will allow us to load models effortlessly and start manipulating them with ease:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'const githubUrl =\n  "https://thatopen.github.io/engine_fragment/resources/worker.mjs";\nconst fetchedUrl = await fetch(githubUrl);\nconst workerBlob = await fetchedUrl.blob();\nconst workerFile = new File([workerBlob], "worker.mjs", {\n  type: "text/javascript",\n});\nconst workerUrl = URL.createObjectURL(workerFile);\nconst fragments = components.get(OBC.FragmentsManager);\nfragments.init(workerUrl);\n\nworld.camera.controls.addEventListener("rest", () =>\n  fragments.core.update(true),\n);\n\nworld.onCameraChanged.add((camera) => {\n  for (const [, model] of fragments.list) {\n    model.useCamera(camera.three);\n  }\n  fragments.core.update(true);\n});\n\nfragments.list.onItemSet.add(({ value: model }) => {\n  model.useCamera(world.camera.three);\n  world.scene.three.add(model.object);\n  fragments.core.update(true);\n});\n\n// Remove z fighting\nfragments.core.models.materials.list.onItemSet.add(({ value: material }) => {\n  if (!("isLodMaterial" in material && material.isLodMaterial)) {\n    material.polygonOffset = true;\n    material.polygonOffsetUnits = 1;\n    material.polygonOffsetFactor = Math.random();\n  }\n});\n'})}),"\n",(0,a.jsx)(n.h3,{id:"-loading-fragments-models",children:"\ud83d\udcc2 Loading Fragments Models"}),"\n",(0,a.jsx)(n.p,{children:"With the core setup complete, it's time to load a Fragments model into our scene. Fragments are optimized for fast loading and rendering, making them ideal for large-scale 3D models."}),"\n",(0,a.jsx)(n.admonition,{title:"Where can I find Fragment files?",type:"info",children:(0,a.jsx)(n.p,{children:"You can use the sample Fragment files available in our repository for testing. If you have an IFC model you'd like to convert to Fragments, check out the IfcImporter tutorial for detailed instructions."})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'const fragPaths = ["https://thatopen.github.io/engine_components/resources/frags/school_arq.frag"];\nawait Promise.all(\n  fragPaths.map(async (path) => {\n    const modelId = path.split("/").pop()?.split(".").shift();\n    if (!modelId) return null;\n    const file = await fetch(path);\n    const buffer = await file.arrayBuffer();\n    return fragments.core.load(buffer, { modelId });\n  }),\n);\n'})}),"\n",(0,a.jsx)(n.h3,{id:"-turning-on-the-postproduction",children:"\ud83c\udfac Turning on the Postproduction"}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.p,{children:"Now we will activate the postproduction effect and enable the visibility for postproduction layer."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'world.renderer.postproduction.enabled = true;\nworld.dynamicAnchor = false;\n\n// We will exclude LOD objects from all the passes except the base pass:\n\nfragments.core.models.materials.list.onItemSet.add(({ value: material }) => {\n  const isLod = "isLodMaterial" in material && material.isLodMaterial;\n  if (isLod) {\n    world.renderer!.postproduction.basePass.isolatedMaterials.push(material);\n  }\n});\n\n// Outline\n\nconst model = fragments.list.values().next().value!;\nconst outliner = components.get(OBF.Outliner);\noutliner.world = world;\nconst walls = await model.getItemsOfCategories([/IFCWALL/]);\nconst wallsIds = walls.IFCWALL;\nconst [wall1, wall2] = wallsIds;\noutliner.addItems({ [model.modelId]: new Set([wall1, wall2]) });\n'})}),"\n",(0,a.jsx)(n.h3,{id:"-switching-the-camera",children:"\ud83d\udcf9 Switching the camera"}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.p,{children:"If you are using an orthoperspective camera, you need to update the postproduction renderer camera:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'// To update the camera\n\n// window.addEventListener("dblclick", () => {\n//   world.camera.projection.toggle();\n//   model.useCamera(world.camera.three);\n//   world.renderer.postproduction.updateCamera();\n// });\n'})}),"\n",(0,a.jsx)(n.h3,{id:"\ufe0f-measuring-the-performance-optional",children:"\u23f1\ufe0f Measuring the performance (optional)"}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsxs)(n.p,{children:["We'll use the ",(0,a.jsx)(n.a,{href:"https://github.com/mrdoob/stats.js",children:"Stats.js"})," to measure the performance of our app. We will add it to the top left corner of the viewport. This way, we'll make sure that the memory consumption and the FPS of our app are under control."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'const stats = new Stats();\nstats.showPanel(2);\ndocument.body.append(stats.dom);\nstats.dom.style.left = "0px";\nstats.dom.style.zIndex = "unset";\nworld.renderer.onBeforeUpdate.add(() => stats.begin());\nworld.renderer.onAfterUpdate.add(() => stats.end());\n'})}),"\n",(0,a.jsx)(n.h3,{id:"-adding-some-ui",children:"\ud83e\udde9 Adding some UI"}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsxs)(n.p,{children:["We will use the ",(0,a.jsx)(n.code,{children:"@thatopen/ui"})," library to add some simple and cool UI elements to our app. First, we need to call the ",(0,a.jsx)(n.code,{children:"init"})," method of the ",(0,a.jsx)(n.code,{children:"BUI.Manager"})," class to initialize the library:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"BUI.Manager.init();\n"})}),"\n",(0,a.jsx)(n.p,{children:"Now we will add some UI to control some of the most common postproduction parameters. For more information about the UI library, you can check the specific documentation for it!"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'const { aoPass, outlinePass, edgesPass, defaultAoParameters } =\n  world.renderer.postproduction;\n\nconst pdParameters = {\n  lumaPhi: 10,\n  depthPhi: 2,\n  normalPhi: 3,\n  radius: 4,\n  radiusExponent: 1,\n  rings: 2,\n  samples: 16,\n};\n\naoPass.updateGtaoMaterial(defaultAoParameters);\naoPass.updatePdMaterial(pdParameters);\n\nconst cube = new THREE.Mesh(\n  new THREE.BoxGeometry(1, 1, 1),\n  new THREE.MeshLambertMaterial({ color: 0x00ff00 }),\n);\ncube.position.set(10, 0, 0);\nworld.scene.three.add(cube);\nworld.renderer.postproduction.excludedObjectsPass.addExcludedMaterial(\n  cube.material,\n);\n\nconst panel = BUI.Component.create<BUI.PanelSection>(() => {\n  return BUI.html`\n  <bim-panel active label="Postproduction Tutorial" class="options-menu">\n\n    <bim-panel-section label="General">\n\n      <bim-checkbox checked label="Postproduction enabled"\n        @change="${({ target }: { target: BUI.Checkbox }) => {\n          world.renderer!.postproduction.enabled = target.value;\n          updateIfManualMode();\n        }}">\n      </bim-checkbox>\n\n      <bim-checkbox checked label="Outlines enabled"\n        ?checked=${world.renderer!.postproduction.outlinesEnabled}\n        @change="${({ target }: { target: BUI.Checkbox }) => {\n          world.renderer!.postproduction.outlinesEnabled = target.value;\n          updateIfManualMode();\n        }}">\n      </bim-checkbox>\n\n      <bim-checkbox checked label="Excluded objects enabled"\n        ?checked=${world.renderer!.postproduction.excludedObjectsEnabled}\n        @change="${({ target }: { target: BUI.Checkbox }) => {\n          world.renderer!.postproduction.excludedObjectsEnabled = target.value;\n          updateIfManualMode();\n        }}">\n      </bim-checkbox>\n\n      <bim-dropdown required label="Postproduction style"\n        @change="${({ target }: { target: BUI.Dropdown }) => {\n          const result = target.value[0] as OBF.PostproductionAspect;\n          world.renderer!.postproduction.style = result;\n          updateIfManualMode();\n        }}">\n\n        <bim-option checked label="Basic" value="${OBF.PostproductionAspect.COLOR}"></bim-option>\n        <bim-option label="Pen" value="${OBF.PostproductionAspect.PEN}"></bim-option>\n        <bim-option label="Shadowed Pen" value="${OBF.PostproductionAspect.PEN_SHADOWS}"></bim-option>\n        <bim-option label="Color Pen" value="${OBF.PostproductionAspect.COLOR_PEN}"></bim-option>\n        <bim-option label="Color Shadows" value="${OBF.PostproductionAspect.COLOR_SHADOWS}"></bim-option>\n        <bim-option label="Color Pen Shadows" value="${OBF.PostproductionAspect.COLOR_PEN_SHADOWS}"></bim-option>\n      </bim-dropdown>\n\n    </bim-panel-section>\n\n      <bim-panel-section label="Edges">\n\n      <bim-number-input\n          slider step="0.1" label="Width"\n          value="${world.renderer!.postproduction.edgesPass.width}" min="1" max="3"\n          @change="${({ target }: { target: BUI.NumberInput }) => {\n            world.renderer!.postproduction.edgesPass.width = target.value;\n            updateIfManualMode();\n          }}">\n      </bim-number-input>\n\n      <bim-color-input label="Edges color"\n        color="#${edgesPass.color.getHexString()}"\n        @input="${({ target }: { target: BUI.ColorInput }) => {\n          edgesPass.color.set(target.value.color);\n          updateIfManualMode();\n        }}">\n      </bim-color-input>\n\n    </bim-panel-section>\n\n    <bim-panel-section label="Outline">\n\n      <bim-number-input\n          slider step="0.1" label="Outline thickness"\n          value="${outlinePass.thickness}" min="1" max="10"\n          @change="${({ target }: { target: BUI.NumberInput }) => {\n            outlinePass.thickness = target.value;\n            updateIfManualMode();\n          }}">\n      </bim-number-input>\n\n      <bim-number-input\n          slider step="0.01" label="Fill opacity"\n          value="${outlinePass.fillOpacity}" min="0" max="1"\n          @change="${({ target }: { target: BUI.NumberInput }) => {\n            outlinePass.fillOpacity = target.value;\n            updateIfManualMode();\n          }}">\n      </bim-number-input>\n\n      <bim-color-input label="Line color"\n        color="#${outlinePass.outlineColor.getHexString()}"\n        @input="${({ target }: { target: BUI.ColorInput }) => {\n          outlinePass.outlineColor.set(target.value.color);\n          updateIfManualMode();\n        }}">\n      </bim-color-input>\n\n      <bim-color-input label="Fill color"\n        color="#${outlinePass.fillColor.getHexString()}"\n        @input="${({ target }: { target: BUI.ColorInput }) => {\n          outlinePass.fillColor.set(target.value.color);\n          updateIfManualMode();\n        }}">\n      </bim-color-input>\n\n    </bim-panel-section>\n\n  \n    <bim-panel-section label="Gloss">\n\n      <bim-checkbox label="Enabled"\n        ?checked=${world.renderer!.postproduction.glossEnabled}\n        @change="${({ target }: { target: BUI.Checkbox }) => {\n          world.renderer!.postproduction.glossEnabled = target.value;\n          updateIfManualMode();\n        }}">\n      </bim-checkbox>\n\n      <bim-number-input\n        slider step="0.01" label="Min gloss"\n        value="${world.renderer!.postproduction.glossPass.minGloss}" min="-1" max="1"\n        @change="${({ target }: { target: BUI.NumberInput }) => {\n          world.renderer!.postproduction.glossPass.minGloss = target.value;\n          updateIfManualMode();\n        }}">\n      </bim-number-input>\n\n      <bim-number-input\n        slider step="0.01" label="Max gloss"\n        value="${world.renderer!.postproduction.glossPass.maxGloss}" min="-1" max="1"\n        @change="${({ target }: { target: BUI.NumberInput }) => {\n          world.renderer!.postproduction.glossPass.maxGloss = target.value;\n          updateIfManualMode();\n        }}">\n      </bim-number-input>\n\n      <bim-number-input\n        slider step="0.01" label="Gloss exponent"\n        value="${world.renderer!.postproduction.glossPass.glossExponent}" min="0.1" max="20"\n        @change="${({ target }: { target: BUI.NumberInput }) => {\n          world.renderer!.postproduction.glossPass.glossExponent = target.value;\n          updateIfManualMode();\n        }}">\n      </bim-number-input>\n\n      <bim-number-input\n        slider step="0.01" label="Fresnel exponent"\n        value="${world.renderer!.postproduction.glossPass.fresnelExponent}" min="0.1" max="50"\n        @change="${({ target }: { target: BUI.NumberInput }) => {\n          world.renderer!.postproduction.glossPass.fresnelExponent =\n            target.value;\n          updateIfManualMode();\n        }}">\n      </bim-number-input>\n\n      <bim-number-input\n        slider step="0.01" label="Gloss factor"\n        value="${world.renderer!.postproduction.glossPass.glossFactor}" min="0" max="1"\n        @change="${({ target }: { target: BUI.NumberInput }) => {\n          world.renderer!.postproduction.glossPass.glossFactor = target.value;\n          updateIfManualMode();\n        }}">\n      </bim-number-input>\n\n      <bim-number-input\n        slider step="0.01" label="Fresnel factor"\n        value="${world.renderer!.postproduction.glossPass.fresnelFactor}" min="0" max="10"\n        @change="${({ target }: { target: BUI.NumberInput }) => {\n          world.renderer!.postproduction.glossPass.fresnelFactor = target.value;\n          updateIfManualMode();\n        }}">\n      </bim-number-input>\n\n    </bim-panel-section>\n\n    <bim-panel-section label="Manual mode">\n      <bim-checkbox label="Enabled"\n        ?checked=${world.renderer!.mode === OBC.RendererMode.MANUAL}\n        @change="${({ target }: { target: BUI.Checkbox }) => {\n          world.renderer!.mode = target.value\n            ? OBC.RendererMode.MANUAL\n            : OBC.RendererMode.AUTO;\n        }}">\n      </bim-checkbox>\n\n      <bim-number-input label="Delay"\n        value="${world.renderer!.manualModeDelay}" min="10" max="1000"\n        @change="${({ target }: { target: BUI.NumberInput }) => {\n          world.renderer!.manualModeDelay = target.value;\n          updateIfManualMode();\n        }}">\n      </bim-number-input>\n\n      <bim-checkbox label="Turn off on manual mode"\n        ?checked=${world.renderer!.turnOffOnManualMode}\n        @change="${({ target }: { target: BUI.Checkbox }) => {\n          world.renderer!.turnOffOnManualMode = target.value;\n          updateIfManualMode();\n        }}">\n      </bim-checkbox>\n\n      <bim-dropdown label="Default style"\n        @change="${({ target }: { target: BUI.Dropdown }) => {\n          const result = target.value[0] as OBF.PostproductionAspect;\n          world.renderer!.manualDefaultStyle = result;\n          updateIfManualMode();\n        }}">\n        <bim-option label="Basic" value="${OBF.PostproductionAspect.COLOR}"></bim-option>\n        <bim-option label="Pen" value="${OBF.PostproductionAspect.PEN}"></bim-option>\n        <bim-option label="Pen Shadows" value="${OBF.PostproductionAspect.PEN_SHADOWS}"></bim-option>\n        <bim-option label="Color Pen" value="${OBF.PostproductionAspect.COLOR_PEN}"></bim-option>\n        <bim-option label="Color Shadows" value="${OBF.PostproductionAspect.COLOR_SHADOWS}"></bim-option>\n        <bim-option label="Color Pen Shadows" value="${OBF.PostproductionAspect.COLOR_PEN_SHADOWS}"></bim-option>\n      </bim-dropdown>\n\n\n    </bim-panel-section>\n\n    <bim-panel-section label="Ambient Occlusion">\n\n        <bim-checkbox checked label="Screen Space Radius"\n          ?checked=${defaultAoParameters.screenSpaceRadius}\n          @change="${({ target }: { target: BUI.Checkbox }) => {\n            defaultAoParameters.screenSpaceRadius = target.value;\n            aoPass.updateGtaoMaterial(defaultAoParameters);\n            updateIfManualMode();\n          }}">\n        </bim-checkbox>\n\n        <bim-number-input\n          slider step="0.01" label="Blend intensity"\n          value="${aoPass.blendIntensity}" min="0" max="1"\n          @change="${({ target }: { target: BUI.NumberInput }) => {\n            aoPass.blendIntensity = target.value;\n            updateIfManualMode();\n          }}">\n        </bim-number-input>\n\n        <bim-number-input\n          slider step="0.01" label="Radius"\n          value="${defaultAoParameters.radius}" min="0.01" max="1"\n          @change="${({ target }: { target: BUI.NumberInput }) => {\n            defaultAoParameters.radius = target.value;\n            aoPass.updateGtaoMaterial(defaultAoParameters);\n            updateIfManualMode();\n          }}">\n        </bim-number-input>\n\n        <bim-number-input\n          slider step="0.01" label="Distance exponent"\n          value="${defaultAoParameters.distanceExponent}" min="1" max="10"\n          @change="${({ target }: { target: BUI.NumberInput }) => {\n            defaultAoParameters.distanceExponent = target.value;\n            aoPass.updateGtaoMaterial(defaultAoParameters);\n            updateIfManualMode();\n          }}">\n        </bim-number-input>\n\n        <bim-number-input\n          slider step="0.01" label="Thickness"\n          value="${defaultAoParameters.thickness}" min="0.01" max="10"\n          @change="${({ target }: { target: BUI.NumberInput }) => {\n            defaultAoParameters.thickness = target.value;\n            aoPass.updateGtaoMaterial(defaultAoParameters);\n            updateIfManualMode();\n          }}">\n        </bim-number-input>\n\n        <bim-number-input\n          slider step="0.01" label="Distance falloff"\n          value="${defaultAoParameters.distanceFallOff}" min="0" max="1"\n          @change="${({ target }: { target: BUI.NumberInput }) => {\n            defaultAoParameters.distanceFallOff = target.value;\n            aoPass.updateGtaoMaterial(defaultAoParameters);\n            updateIfManualMode();\n          }}">\n        </bim-number-input>\n\n        <bim-number-input\n          slider step="0.01" label="Scale"\n          value="${defaultAoParameters.scale}" min="0.01" max="10"\n          @change="${({ target }: { target: BUI.NumberInput }) => {\n            defaultAoParameters.scale = target.value;\n            aoPass.updateGtaoMaterial(defaultAoParameters);\n            updateIfManualMode();\n          }}">\n        </bim-number-input>\n\n        <bim-number-input\n          slider step="1" label="Samples"\n          value="${defaultAoParameters.samples}" min="2" max="32"\n          @change="${({ target }: { target: BUI.NumberInput }) => {\n            defaultAoParameters.samples = target.value;\n            aoPass.updateGtaoMaterial(defaultAoParameters);\n            updateIfManualMode();\n          }}">\n        </bim-number-input>\n\n        <bim-number-input\n          slider step="0.1" label="PD Luma Phi"\n          value="${pdParameters.lumaPhi}" min="0" max="20"\n          @change="${({ target }: { target: BUI.NumberInput }) => {\n            pdParameters.lumaPhi = target.value;\n            aoPass.updatePdMaterial(pdParameters);\n            updateIfManualMode();\n          }}">\n        </bim-number-input>\n\n        <bim-number-input\n          slider step="0.1" label="PD Depth Phi"\n          value="${pdParameters.depthPhi}" min="0.01" max="20"\n          @change="${({ target }: { target: BUI.NumberInput }) => {\n            pdParameters.depthPhi = target.value;\n            aoPass.updatePdMaterial(pdParameters);\n            updateIfManualMode();\n          }}">\n        </bim-number-input>\n\n        <bim-number-input\n          slider step="0.1" label="PD Normal Phi"\n          value="${pdParameters.normalPhi}" min="0.01" max="20"\n          @change="${({ target }: { target: BUI.NumberInput }) => {\n            pdParameters.normalPhi = target.value;\n            aoPass.updatePdMaterial(pdParameters);\n            updateIfManualMode();\n          }}">\n        </bim-number-input>\n\n        <bim-number-input\n          slider step="1" label="PD Radius"\n          value="${pdParameters.radius}" min="0" max="32"\n          @change="${({ target }: { target: BUI.NumberInput }) => {\n            pdParameters.radius = target.value;\n            aoPass.updatePdMaterial(pdParameters);\n            updateIfManualMode();\n          }}">\n        </bim-number-input>\n\n        <bim-number-input\n          slider step="0.1" label="PD Radius Exponent"\n          value="${pdParameters.radiusExponent}" min="0.1" max="4"\n          @change="${({ target }: { target: BUI.NumberInput }) => {\n            pdParameters.radiusExponent = target.value;\n            aoPass.updatePdMaterial(pdParameters);\n            updateIfManualMode();\n          }}">\n        </bim-number-input>\n\n        <bim-number-input\n          slider step="0.125" label="PD Rings"\n          value="${pdParameters.rings}" min="1" max="16"\n          @change="${({ target }: { target: BUI.NumberInput }) => {\n            pdParameters.rings = target.value;\n            aoPass.updatePdMaterial(pdParameters);\n            updateIfManualMode();\n          }}">\n        </bim-number-input>\n\n        <bim-number-input\n          slider step="1" label="PD Samples"\n          value="${pdParameters.samples}" min="2" max="32"\n          @change="${({ target }: { target: BUI.NumberInput }) => {\n            pdParameters.samples = target.value;\n            aoPass.updatePdMaterial(pdParameters);\n            updateIfManualMode();\n          }}">\n        </bim-number-input>\n\n      </bim-panel-section>\n\n\n    </bim-panel>\n    `;\n});\n\ndocument.body.append(panel);\n'})}),"\n",(0,a.jsx)(n.p,{children:"And we will make some logic that adds a button to the screen when the user is visiting our app from their phone, allowing to show or hide the menu. Otherwise, the menu would make the app unusable."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'const button = BUI.Component.create<BUI.PanelSection>(() => {\n  return BUI.html`\n      <bim-button class="phone-menu-toggler" icon="solar:settings-bold"\n        @click="${() => {\n          if (panel.classList.contains("options-menu-visible")) {\n            panel.classList.remove("options-menu-visible");\n          } else {\n            panel.classList.add("options-menu-visible");\n          }\n        }}">\n      </bim-button>\n    `;\n});\n\ndocument.body.append(button);\n\n//\n'})}),"\n",(0,a.jsx)(n.p,{children:"//   ### \ud83c\udf89 Wrap up\n//   ---\n//   That's it! You have created an app that looks great thanks to postproduction and exposes a menu to allow the user control it in real time.\n//"})]})}function c(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>l});var a=t(6540);const o={},r=a.createContext(o);function s(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);