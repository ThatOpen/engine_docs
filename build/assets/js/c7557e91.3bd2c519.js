"use strict";(self.webpackChunkengine_docs=self.webpackChunkengine_docs||[]).push([[5069],{9158:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var r=t(4848),o=t(8453);const i={},a=void 0,s={id:"Tutorials/Fragments/Fragments/FragmentsModels/Rebars",title:"Rebars",description:'window.open("https://thatopen.github.io/engine_fragment/examples/FragmentsModels/Rebars")} >Go Full Screen',source:"@site/docs/Tutorials/Fragments/Fragments/FragmentsModels/Rebars.mdx",sourceDirName:"Tutorials/Fragments/Fragments/FragmentsModels",slug:"/Tutorials/Fragments/Fragments/FragmentsModels/Rebars",permalink:"/Tutorials/Fragments/Fragments/FragmentsModels/Rebars",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Raycasting",permalink:"/Tutorials/Fragments/Fragments/FragmentsModels/Raycasting"},next:{title:"SteelDetailing",permalink:"/Tutorials/Fragments/Fragments/FragmentsModels/SteelDetailing"}},l={},c=[{value:"Working with Rebars \ud83d\udd29",id:"working-with-rebars-",level:2},{value:"\ud83d\udd96 Importing our Libraries",id:"-importing-our-libraries",level:3},{value:"\ud83c\udf0e Setting up a Simple Scene",id:"-setting-up-a-simple-scene",level:3},{value:"\ud83d\udee0\ufe0f Setting Up Fragments",id:"\ufe0f-setting-up-fragments",level:3},{value:"\ud83d\udcc2 Creating a New Fragments Model",id:"-creating-a-new-fragments-model",level:3},{value:"\ud83e\uddca Setting up the Geometry Engine",id:"-setting-up-the-geometry-engine",level:3},{value:"\u2699\ufe0f Configuration Settings",id:"\ufe0f-configuration-settings",level:3},{value:"\ud83d\udd04 Fragment Regeneration Logic",id:"-fragment-regeneration-logic",level:3},{value:"\ud83c\udfd7\ufe0f Model Regeneration",id:"\ufe0f-model-regeneration",level:3},{value:"\ud83d\udcbe Save Functionality",id:"-save-functionality",level:3},{value:"\ud83e\udde9 Adding User Interface",id:"-adding-user-interface",level:3},{value:"\ud83d\udcf1 Mobile-Friendly Menu",id:"-mobile-friendly-menu",level:3},{value:"\ud83c\udf89 Congratulations!",id:"-congratulations",level:3}];function d(n){const e={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",hr:"hr",p:"p",pre:"pre",...(0,o.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)("div",{style:{position:"relative"},children:[(0,r.jsx)("iframe",{src:"https://thatopen.github.io/engine_fragment/examples/FragmentsModels/Rebars"}),(0,r.jsx)("button",{class:"full-screen-btn",onClick:()=>window.open("https://thatopen.github.io/engine_fragment/examples/FragmentsModels/Rebars"),children:"Go Full Screen"})]}),"\n",(0,r.jsx)(e.admonition,{title:"Source",type:"info",children:(0,r.jsxs)(e.p,{children:["Copying and pasting? We've got you covered! You can find the full source code of this tutorial ",(0,r.jsx)(e.a,{href:"https://github.com/ThatOpen/engine_fragment/blob/main/packages/fragments/src/FragmentsModels/examples/Rebars/example.ts",children:"here"}),"."]})}),"\n",(0,r.jsx)(e.h2,{id:"working-with-rebars-",children:"Working with Rebars \ud83d\udd29"}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.p,{children:"In this tutorial, we'll explore how to create and work with reinforced concrete elements using the Fragments API. We'll learn how to generate column and footing rebars with proper spacing, colors, and geometric relationships. Let's dive in!"}),"\n",(0,r.jsx)(e.h3,{id:"-importing-our-libraries",children:"\ud83d\udd96 Importing our Libraries"}),"\n",(0,r.jsx)(e.p,{children:"First things first, let's install all necessary dependencies to make this example work:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'import * as OBC from "@thatopen/components";\nimport * as THREE from "three";\nimport * as BUI from "@thatopen/ui";\nimport * as WEBIFC from "web-ifc";\nimport * as FRAGS from "../../../index";\n'})}),"\n",(0,r.jsx)(e.h3,{id:"-setting-up-a-simple-scene",children:"\ud83c\udf0e Setting up a Simple Scene"}),"\n",(0,r.jsx)(e.p,{children:"To get started, let's set up a basic ThreeJS scene. This will serve as the foundation for our application and allow us to visualize the reinforced concrete elements with proper lighting and shadows:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'const container = document.getElementById("container")!;\n\nconst components = new OBC.Components();\n\nconst worlds = components.get(OBC.Worlds);\n\nconst world = worlds.create<\n  OBC.ShadowedScene,\n  OBC.OrthoPerspectiveCamera,\n  OBC.SimpleRenderer\n>();\n\nworld.scene = new OBC.ShadowedScene(components);\nworld.renderer = new OBC.SimpleRenderer(components, container);\nworld.camera = new OBC.OrthoPerspectiveCamera(components);\n\ncomponents.init();\n\nworld.camera.controls.setLookAt(12, 6, 8, 0, 0, -10);\n\nworld.renderer.three.shadowMap.enabled = true;\nworld.renderer.three.shadowMap.type = THREE.PCFSoftShadowMap;\n\nworld.scene.setup({\n  shadows: {\n    cascade: 1,\n    resolution: 1024,\n  },\n});\n\nawait world.scene.updateShadows();\n\nworld.camera.controls.addEventListener("rest", async () => {\n  await world.scene.updateShadows();\n});\n\n// Add axes helper\nconst axesHelper = new THREE.AxesHelper();\nworld.scene.three.add(axesHelper);\n'})}),"\n",(0,r.jsx)(e.h3,{id:"\ufe0f-setting-up-fragments",children:"\ud83d\udee0\ufe0f Setting Up Fragments"}),"\n",(0,r.jsx)(e.p,{children:"Now, let's configure the Fragments library core. This will allow us to load models effortlessly and start working with reinforced concrete elements:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'// prettier-ignore\nconst workerUrl = "https://thatopen.github.io/engine_fragment/resources/worker.mjs";\n// const workerUrl = "../../dist/Worker/worker.mjs";\nconst fragments = new FRAGS.FragmentsModels(workerUrl);\n\nworld.camera.controls.addEventListener("control", () => fragments.update());\n\nfragments.models.list.onItemSet.add(({ value: model }) => {\n  model.tiles.onItemSet.add(({ value: mesh }) => {\n    if ("isMesh" in mesh) {\n      const mat = mesh.material as THREE.MeshStandardMaterial[];\n      if (mat[0].opacity === 1) {\n        mesh.castShadow = true;\n        mesh.receiveShadow = true;\n      }\n    }\n  });\n\n  for (const child of model.object.children) {\n    child.castShadow = true;\n    child.receiveShadow = true;\n  }\n});\n'})}),"\n",(0,r.jsx)(e.h3,{id:"-creating-a-new-fragments-model",children:"\ud83d\udcc2 Creating a New Fragments Model"}),"\n",(0,r.jsx)(e.p,{children:"We'll create a new empty Fragments model to store our reinforced concrete elements. This model will be built programmatically with concrete and rebar elements:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'const bytes = FRAGS.EditUtils.newModel({ raw: true });\nconst model = await fragments.load(bytes, {\n  modelId: "example",\n  camera: world.camera.three,\n  raw: true,\n});\n\nworld.scene.three.add(model.object);\n\nawait fragments.update(true);\n'})}),"\n",(0,r.jsx)(e.h3,{id:"-setting-up-the-geometry-engine",children:"\ud83e\uddca Setting up the Geometry Engine"}),"\n",(0,r.jsx)(e.p,{children:"Now, let's set up the Geometry Engine. We'll use it to generate the concrete and rebar geometries:"}),"\n",(0,r.jsx)(e.admonition,{title:"Geometry Engine?",type:"warning",children:(0,r.jsx)(e.p,{children:"The Geometry Engine is a library that allows us to easily generate geometry parametrically using the Fragments API."})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'const api = new WEBIFC.IfcAPI();\napi.SetWasmPath("https://unpkg.com/web-ifc@0.0.72/", true);\nawait api.Init();\nconst geometryEngine = new FRAGS.GeometryEngine(api);\n'})}),"\n",(0,r.jsx)(e.h3,{id:"\ufe0f-configuration-settings",children:"\u2699\ufe0f Configuration Settings"}),"\n",(0,r.jsx)(e.p,{children:"We'll define all the parameters that control the dimensions and properties of our reinforced concrete elements. These settings will allow us to create customizable footings and columns with proper rebar placement:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'const settings = {\n  footingWidth: 1,\n  footingLength: 1,\n  footingHeight: 0.4,\n  columnHeight: 1,\n  columnWidth: 0.3,\n  columnLength: 0.3,\n  columnPadding: 0.05,\n  bottomPadding: 0.05,\n  columnLongRebarRadius: 0.01,\n  columnTransRebarRadius: 0.01,\n  columnTransRebarOffset: 0.15,\n  transOverlap: 0.1,\n  topColumnRebarOffset: 0.3,\n  footingRebarRadius: 0.01,\n  footingRebarOffset: 0.15,\n  footingOverlap: 0.1,\n  footingBendRadius: 0.05,\n};\n\nconst temp = {\n  clrx1: 0, // Column Long Rebar X1\n  clrx2: 0, // Column Long Rebar X2\n  cBottom: 0, // Column Bottom\n  clrz1: 0, // Column Long Rebar Z1\n  clrz2: 0, // Column Long Rebar Z2\n  cTop: 0, // Column Top\n};\n\nconst rebars: FRAGS.RawCircleExtrusion[] = [];\nconst materialMap = {\n  red: "red",\n  blue: "blue",\n  green: "green",\n};\n\nenum Colors {\n  RED,\n  BLUE,\n  GREEN,\n}\n\nconst colors: Colors[] = [];\n\n// Create lines geometry\n\nconst concreteMat = new THREE.MeshLambertMaterial({\n  color: "gray",\n  transparent: true,\n  opacity: 1,\n  side: THREE.DoubleSide,\n});\n\nconst footing = new THREE.Mesh(new THREE.BufferGeometry(), concreteMat);\nworld.scene.three.add(footing);\nfooting.frustumCulled = false;\n\nconst column = new THREE.Mesh(new THREE.BufferGeometry(), concreteMat);\nworld.scene.three.add(column);\ncolumn.frustumCulled = false;\n\nconst wireGeom = new THREE.BufferGeometry();\nconst wireMat = new THREE.LineBasicMaterial({\n  color: 0xff0000,\n  depthTest: false,\n});\nconst wireLines = new THREE.LineSegments(wireGeom, wireMat);\nwireLines.frustumCulled = false;\nworld.scene.three.add(wireLines);\n\nwireGeom.computeBoundingSphere();\n\n// Reconstruct the fragments model\n\n// const processing = false;\n\n// Geometries\n\nlet timeout: any = null;\n\nlet updating = false;\n\nconst getLineRebar = (\n  radius: number,\n  x1: number,\n  y1: number,\n  z1: number,\n  x2: number,\n  y2: number,\n  z2: number,\n) => {\n  return {\n    radius: [radius],\n    axes: [\n      {\n        wires: [[x1, y1, z1, x2, y2, z2]],\n        order: [0],\n        parts: [FRAGS.AxisPartClass.WIRE],\n        wireSets: [],\n        circleCurves: [],\n      },\n    ],\n  };\n};\n\nconst getColumnTransRebar = (\n  radius: number,\n  height: number,\n): FRAGS.RawCircleExtrusion => {\n  //   p1 ---- p2\n  // p8          p3\n  // |           |\n  // |           |\n  // |           |\n  // |           |\n  // |           |\n  // p7          p4\n  //   p6 ---- p5\n\n  const x1 = temp.clrx1;\n  const z1 = temp.clrz1;\n  const x2 = temp.clrx2;\n  const z2 = temp.clrz2;\n  const h = height;\n  // Long Rebar Radius\n  const ol = settings.columnLongRebarRadius;\n  // Trans Rebar Radius\n  const ot = settings.columnTransRebarRadius;\n\n  const o = ol + ot;\n\n  const p1x = x1;\n  const p1z = z1 + o;\n  const p2x = x2;\n  const p2z = z1 + o;\n  const p3x = x2 - o;\n  const p3z = z1;\n  const p4x = x2 - o;\n  const p4z = z2;\n  const p5x = x2;\n  const p5z = z2 - o;\n  const p6x = x1;\n  const p6z = z2 - o;\n  const p7x = x1 + o;\n  const p7z = z2;\n  const p8x = x1 + o;\n  const p8z = z1;\n\n  // We\'ll make the points for the overlap too\n  const start1X = x1 + o;\n  const start1Z = z1;\n  const start2X = x1 + o;\n  const start2Z = z1 - settings.transOverlap;\n\n  const end1X = x1;\n  const end1Z = z1 + o;\n  const end2X = x1 - settings.transOverlap;\n  const end2Z = z1 + o;\n\n  const zRot = new THREE.Matrix4().makeRotationZ(Math.PI / 2);\n  const yRot = new THREE.Matrix4().makeRotationY(-Math.PI / 2);\n  const xDir1 = new THREE.Vector3(1, 0, 0);\n  const yDir1 = new THREE.Vector3(0, 1, 0);\n  xDir1.applyMatrix4(zRot);\n  yDir1.applyMatrix4(zRot);\n\n  const xDir2 = new THREE.Vector3(1, 0, 0);\n  const yDir2 = new THREE.Vector3(0, 1, 0);\n  xDir2.applyMatrix4(zRot);\n  yDir2.applyMatrix4(zRot);\n  xDir2.applyMatrix4(yRot);\n  yDir2.applyMatrix4(yRot);\n\n  const xDir3 = new THREE.Vector3(1, 0, 0);\n  const yDir3 = new THREE.Vector3(0, 1, 0);\n  xDir3.applyMatrix4(zRot);\n  yDir3.applyMatrix4(zRot);\n  xDir3.applyMatrix4(yRot);\n  xDir3.applyMatrix4(yRot);\n  yDir3.applyMatrix4(yRot);\n  yDir3.applyMatrix4(yRot);\n\n  const xDir4 = new THREE.Vector3(1, 0, 0);\n  const yDir4 = new THREE.Vector3(0, 1, 0);\n  xDir4.applyMatrix4(zRot);\n  yDir4.applyMatrix4(zRot);\n  xDir4.applyMatrix4(yRot);\n  xDir4.applyMatrix4(yRot);\n  xDir4.applyMatrix4(yRot);\n  yDir4.applyMatrix4(yRot);\n  yDir4.applyMatrix4(yRot);\n  yDir4.applyMatrix4(yRot);\n\n  return {\n    radius: [radius],\n    axes: [\n      {\n        wires: [\n          [start1X, h, start1Z, start2X, h, start2Z],\n          [p1x, h, p1z, p2x, h, p2z],\n          [p3x, h, p3z, p4x, h, p4z],\n          [p5x, h, p5z, p6x, h, p6z],\n          [p7x, h, p7z, p8x, h - ot * 2, p8z],\n          [end1X, h - ot * 2, end1Z, end2X, h - ot * 2, end2Z],\n        ],\n        order: [0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5],\n        parts: [\n          FRAGS.AxisPartClass.WIRE,\n          FRAGS.AxisPartClass.CIRCLE_CURVE,\n          FRAGS.AxisPartClass.WIRE,\n          FRAGS.AxisPartClass.CIRCLE_CURVE,\n          FRAGS.AxisPartClass.WIRE,\n          FRAGS.AxisPartClass.CIRCLE_CURVE,\n          FRAGS.AxisPartClass.WIRE,\n          FRAGS.AxisPartClass.CIRCLE_CURVE,\n          FRAGS.AxisPartClass.WIRE,\n          FRAGS.AxisPartClass.CIRCLE_CURVE,\n          FRAGS.AxisPartClass.WIRE,\n        ],\n        wireSets: [],\n        circleCurves: [\n          {\n            aperture: Math.PI / 2,\n            position: [x1, h, z1],\n            radius: o,\n            xDirection: [xDir4.x, xDir4.y, xDir4.z],\n            yDirection: [yDir4.x, yDir4.y, yDir4.z],\n          },\n          {\n            aperture: Math.PI / 2,\n            position: [x2, h, z1],\n            radius: o,\n            xDirection: [xDir1.x, xDir1.y, xDir1.z],\n            yDirection: [yDir1.x, yDir1.y, yDir1.z],\n          },\n          {\n            aperture: Math.PI / 2,\n            position: [x2, h, z2],\n            radius: o,\n            xDirection: [xDir2.x, xDir2.y, xDir2.z],\n            yDirection: [yDir2.x, yDir2.y, yDir2.z],\n          },\n          {\n            aperture: Math.PI / 2,\n            position: [x1, h, z2],\n            radius: o,\n            xDirection: [xDir3.x, xDir3.y, xDir3.z],\n            yDirection: [yDir3.x, yDir3.y, yDir3.z],\n          },\n          {\n            aperture: Math.PI / 2,\n            position: [x1, h - ot * 2, z1],\n            radius: o,\n            xDirection: [xDir4.x, xDir4.y, xDir4.z],\n            yDirection: [yDir4.x, yDir4.y, yDir4.z],\n          },\n        ],\n      },\n    ],\n  };\n};\n\nconst getFootingRebar = (\n  radius: number,\n  x1: number,\n  y1: number,\n  z1: number,\n  x2: number,\n  y2: number,\n  z2: number,\n) => {\n  //  p1                  p6\n  //  |                   |\n  //  p2                 p5\n  //  A p3 ---------- p4 B\n\n  const bRadius = settings.footingBendRadius;\n  const overlap = settings.footingOverlap;\n\n  const a = new THREE.Vector3(x1, y1, z1);\n  const b = new THREE.Vector3(x2, y2, z2);\n  const dir = b.clone().sub(a.clone()).normalize();\n  const up = new THREE.Vector3(0, 1, 0);\n\n  const p1 = a.clone().add(up.clone().multiplyScalar(overlap));\n  const p2 = a.clone().add(up.clone().multiplyScalar(bRadius));\n  const p3 = a.clone().add(dir.clone().multiplyScalar(bRadius));\n  const p4 = b.clone().sub(dir.clone().multiplyScalar(bRadius));\n  const p5 = b.clone().add(up.clone().multiplyScalar(bRadius));\n  const p6 = b.clone().add(up.clone().multiplyScalar(overlap));\n\n  const c1 = a.clone();\n  c1.y += bRadius;\n  c1.add(dir.clone().multiplyScalar(bRadius));\n\n  const c2 = b.clone();\n  c2.y += bRadius;\n  c2.sub(dir.clone().multiplyScalar(bRadius));\n\n  let xDir1 = new THREE.Vector3(1, 0, 0);\n  const yDir1 = new THREE.Vector3(0, 1, 0);\n  let xDir2 = new THREE.Vector3(1, 0, 0);\n  const yDir2 = new THREE.Vector3(0, 1, 0);\n\n  const isZAxis = dir.x === 0 && dir.y === 0 && dir.z === 1;\n  if (!isZAxis) {\n    xDir1 = new THREE.Vector3(0, 0, 1);\n    xDir2 = new THREE.Vector3(0, 0, 1);\n  }\n\n  if (isZAxis) {\n    const xRotation = new THREE.Matrix4().makeRotationX(Math.PI / 2);\n    xDir1.applyMatrix4(xRotation);\n    xDir1.applyMatrix4(xRotation);\n    yDir1.applyMatrix4(xRotation);\n    yDir1.applyMatrix4(xRotation);\n\n    xDir2.applyMatrix4(xRotation);\n    yDir2.applyMatrix4(xRotation);\n  } else {\n    const zRotation = new THREE.Matrix4().makeRotationZ(Math.PI / 2);\n\n    xDir1.applyMatrix4(zRotation);\n    yDir1.applyMatrix4(zRotation);\n\n    xDir2.applyMatrix4(zRotation);\n    yDir2.applyMatrix4(zRotation);\n    xDir2.applyMatrix4(zRotation);\n    yDir2.applyMatrix4(zRotation);\n  }\n\n  return {\n    radius: [radius],\n    axes: [\n      {\n        wires: [\n          [p1.x, p1.y, p1.z, p2.x, p2.y, p2.z],\n          [p3.x, p3.y, p3.z, p4.x, p4.y, p4.z],\n          [p5.x, p5.y, p5.z, p6.x, p6.y, p6.z],\n        ],\n        order: [0, 0, 1, 1, 2],\n        parts: [\n          FRAGS.AxisPartClass.WIRE,\n          FRAGS.AxisPartClass.CIRCLE_CURVE,\n          FRAGS.AxisPartClass.WIRE,\n          FRAGS.AxisPartClass.CIRCLE_CURVE,\n          FRAGS.AxisPartClass.WIRE,\n        ],\n        wireSets: [],\n        circleCurves: [\n          {\n            aperture: Math.PI / 2,\n            position: [c1.x, c1.y, c1.z],\n            radius: bRadius,\n            xDirection: [xDir1.x, xDir1.y, xDir1.z],\n            yDirection: [yDir1.x, yDir1.y, yDir1.z],\n          },\n          {\n            aperture: Math.PI / 2,\n            position: [c2.x, c2.y, c2.z],\n            radius: bRadius,\n            xDirection: [xDir2.x, xDir2.y, xDir2.z],\n            yDirection: [yDir2.x, yDir2.y, yDir2.z],\n          },\n        ],\n      },\n    ],\n  };\n};\n'})}),"\n",(0,r.jsx)(e.h3,{id:"-fragment-regeneration-logic",children:"\ud83d\udd04 Fragment Regeneration Logic"}),"\n",(0,r.jsx)(e.p,{children:"This function handles the regeneration of fragments when parameters change. It creates the necessary materials and processes all rebar elements with their assigned colors:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'const regenerateFragments = async () => {\n  if (timeout) {\n    clearTimeout(timeout);\n  }\n\n  timeout = setTimeout(async () => {\n    if (updating) {\n      return;\n    }\n    updating = true;\n\n    const elementsData: FRAGS.NewElementData[] = [];\n\n    await fragments.editor.reset(model.modelId);\n    fragments.settings.graphicsQuality = 1;\n\n    const redMatId = fragments.editor.createMaterial(\n      model.modelId,\n      new THREE.MeshLambertMaterial({\n        color: new THREE.Color(1, 0, 0),\n      }),\n    );\n\n    materialMap.red = redMatId;\n\n    const blueMatId = fragments.editor.createMaterial(\n      model.modelId,\n      new THREE.MeshLambertMaterial({\n        color: new THREE.Color(0, 0, 1),\n      }),\n    );\n\n    materialMap.blue = blueMatId;\n\n    const greenMatId = fragments.editor.createMaterial(\n      model.modelId,\n      new THREE.MeshLambertMaterial({\n        color: new THREE.Color(0, 1, 0),\n      }),\n    );\n\n    materialMap.green = greenMatId;\n\n    const ltId = fragments.editor.createLocalTransform(\n      model.modelId,\n      new THREE.Matrix4().identity(),\n    );\n\n    let colorCounter = 0;\n    for (const rebar of rebars) {\n      const foundColor = colors[colorCounter];\n      let colorId: string | null = null;\n      if (foundColor === Colors.RED) {\n        colorId = materialMap.red;\n      } else if (foundColor === Colors.BLUE) {\n        colorId = materialMap.blue;\n      } else if (foundColor === Colors.GREEN) {\n        colorId = materialMap.green;\n      }\n      if (!colorId) {\n        throw new Error("Color not found");\n      }\n      colorCounter++;\n\n      const rebarGeoId = fragments.editor.createCircleExtrusion(\n        model.modelId,\n        rebar,\n      );\n\n      const tempObject = new THREE.Object3D();\n\n      elementsData.push({\n        attributes: {\n          _category: {\n            value: "test",\n          },\n        },\n        globalTransform: tempObject.matrix.clone(),\n        samples: [\n          {\n            localTransform: ltId,\n            representation: rebarGeoId,\n            material: colorId,\n          },\n        ],\n      });\n    }\n\n    await fragments.editor.createElements(model.modelId, elementsData);\n    await fragments.update(true);\n\n    updating = false;\n  }, 500);\n};\n'})}),"\n",(0,r.jsx)(e.h3,{id:"\ufe0f-model-regeneration",children:"\ud83c\udfd7\ufe0f Model Regeneration"}),"\n",(0,r.jsx)(e.p,{children:"This function regenerates the entire model including concrete elements and rebar placement. It calculates all the geometric relationships and creates the appropriate rebar configurations:"}),"\n",(0,r.jsx)(e.admonition,{title:"Rebar Types",type:"info",children:(0,r.jsx)(e.p,{children:"We'll create three types of rebars: longitudinal column rebars (red), transversal column rebars (blue), and footing rebars (green). Each type has specific spacing and geometric requirements."})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'const regenerateModel = async () => {\n  rebars.length = 0;\n  colors.length = 0;\n\n  await fragments.editor.reset(model.modelId);\n\n  const fw = settings.footingWidth;\n  const fl = settings.footingLength;\n  const fh = settings.footingHeight;\n\n  const cw = settings.columnWidth;\n  const cl = settings.columnLength;\n  const ch = settings.columnHeight;\n\n  // Regenerate wire\n\n  const points: THREE.Vector3[] = [];\n\n  // Concrete elements\n\n  // prettier-ignore\n  geometryEngine.getExtrusion(footing.geometry, {\n    profilePoints: [\n      0, 0, 0,\n      fw, 0, 0,\n      fw, 0, fl,\n      0, 0, fl,\n    ],\n    direction: [0, 1, 0],\n    length: fh,\n  });\n\n  // prettier-ignore\n  geometryEngine.getExtrusion(column.geometry, {\n    profilePoints: [\n      0, 0, 0,\n      cw, 0, 0,\n      cw, 0, cl,\n      0, 0, cl,\n    ],\n    direction: [0, 1, 0],\n    length: ch,\n  });\n\n  const cCenterX = fw / 2 - cw / 2;\n  temp.cBottom = fh;\n  const cCenterZ = fl / 2 - cl / 2;\n  column.position.set(cCenterX, temp.cBottom, cCenterZ);\n\n  // Rebars\n\n  temp.cTop = temp.cBottom + ch;\n  temp.clrx1 = fw / 2 + cw / 2 - settings.columnPadding;\n  temp.clrz1 = fl / 2 + cl / 2 - settings.columnPadding;\n  temp.clrx2 = fw / 2 - cw / 2 + settings.columnPadding;\n  temp.clrz2 = fl / 2 - cl / 2 + settings.columnPadding;\n\n  // Longitudinal Column Rebars\n\n  const clrx1 = temp.clrx1;\n  const clrz1 = temp.clrz1;\n  const clrx2 = temp.clrx2;\n  const clrz2 = temp.clrz2;\n  const fBottom = settings.bottomPadding;\n  const cTop = temp.cTop;\n  const rTop = cTop + settings.topColumnRebarOffset;\n\n  const lRadius = settings.columnLongRebarRadius;\n\n  rebars.push(getLineRebar(lRadius, clrx1, fBottom, clrz1, clrx1, rTop, clrz1));\n  rebars.push(getLineRebar(lRadius, clrx2, fBottom, clrz2, clrx2, rTop, clrz2));\n  rebars.push(getLineRebar(lRadius, clrx1, fBottom, clrz2, clrx1, rTop, clrz2));\n  rebars.push(getLineRebar(lRadius, clrx2, fBottom, clrz1, clrx2, rTop, clrz1));\n\n  colors.push(Colors.RED);\n  colors.push(Colors.RED);\n  colors.push(Colors.RED);\n  colors.push(Colors.RED);\n\n  // Transversal Column Rebars\n\n  const cTransIterations = Math.floor(cTop / settings.columnTransRebarOffset);\n\n  for (let i = 1; i < cTransIterations; i++) {\n    const h = fBottom + settings.columnTransRebarOffset * i;\n    rebars.push(getColumnTransRebar(lRadius, h));\n    colors.push(Colors.BLUE);\n  }\n\n  // Footing Rebars\n\n  const fIterationsX = Math.ceil(fw / settings.footingRebarOffset);\n  const fIterationsY = Math.ceil(fl / settings.footingRebarOffset);\n  const fRadius = settings.footingRebarRadius;\n\n  for (let i = 1; i < fIterationsX; i++) {\n    const x = settings.footingRebarOffset * i;\n    const y = settings.bottomPadding;\n    const z1 = 0 + settings.bottomPadding;\n    const z2 = fl - settings.bottomPadding;\n    rebars.push(getFootingRebar(fRadius, x, y, z1, x, y, z2));\n    colors.push(Colors.GREEN);\n  }\n\n  for (let i = 1; i < fIterationsY; i++) {\n    const z = settings.footingRebarOffset * i;\n    const y = settings.bottomPadding;\n    const x1 = 0 + settings.bottomPadding;\n    const x2 = fw - settings.bottomPadding;\n    rebars.push(\n      getFootingRebar(fRadius, x1, y + fRadius, z, x2, y + fRadius, z),\n    );\n    colors.push(Colors.GREEN);\n  }\n\n  // Create rebar preview\n\n  for (const rebar of rebars) {\n    for (const axe of rebar.axes) {\n      for (const wire of axe.wires) {\n        for (let i = 0; i < wire.length - 2; i += 3) {\n          const x = wire[i];\n          const y = wire[i + 1];\n          const z = wire[i + 2];\n          points.push(new THREE.Vector3(x, y, z));\n        }\n      }\n    }\n  }\n\n  wireGeom.deleteAttribute("position");\n  wireGeom.setFromPoints(points);\n\n  // Update fragments\n  await regenerateFragments();\n};\n\nawait regenerateModel();\n'})}),"\n",(0,r.jsx)(e.h3,{id:"-save-functionality",children:"\ud83d\udcbe Save Functionality"}),"\n",(0,r.jsx)(e.p,{children:"We'll implement a save function that allows users to export their reinforced concrete model as a Fragment file:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'const save = async () => {\n  await fragments.editor.save(model.modelId);\n  console.log("saved");\n  window.setTimeout(async () => {\n    const exportedBuffer = await model.getBuffer();\n    const exportedBytes = new Uint8Array(exportedBuffer);\n    const exportedBlob = new Blob([exportedBytes]);\n    const exportedUrl = URL.createObjectURL(exportedBlob);\n    const exportedLink = document.createElement("a");\n    exportedLink.href = exportedUrl;\n    exportedLink.download = "exported.frag";\n    document.body.appendChild(exportedLink);\n    exportedLink.click();\n    document.body.removeChild(exportedLink);\n    URL.revokeObjectURL(exportedUrl);\n  }, 1000);\n};\n'})}),"\n",(0,r.jsx)(e.h3,{id:"-adding-user-interface",children:"\ud83e\udde9 Adding User Interface"}),"\n",(0,r.jsxs)(e.p,{children:["We will use the ",(0,r.jsx)(e.code,{children:"@thatopen/ui"})," library to add some simple and cool UI elements to our app. First, we need to call the ",(0,r.jsx)(e.code,{children:"init"})," method of the ",(0,r.jsx)(e.code,{children:"BUI.Manager"})," class to initialize the library:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'BUI.Manager.init();\n\nconst [panel] = BUI.Component.create<BUI.PanelSection, any>((_) => {\n  return BUI.html`\n    <bim-panel style="min-width: 25rem;" id="controls-panel" active label="Element Editor" class="options-menu">\n\n      <bim-panel-section label="Controls">\n\n      <bim-number-input label="Opacity" slider min=0 max=1 step=0.1 value=${concreteMat.opacity} @change=${(\n        e: any,\n      ) => {\n        concreteMat.opacity = e.target.value;\n        regenerateModel();\n      }}></bim-number-input>\n\n      <bim-number-input label="Length" slider min=0.5 max=3 step=0.1 value=${settings.footingLength} @change=${(\n        e: any,\n      ) => {\n        settings.footingLength = e.target.value;\n        regenerateModel();\n      }}></bim-number-input>\n\n      <bim-number-input label="Width" slider min=0.5 max=3 step=0.1 value=${settings.footingWidth} @change=${(\n        e: any,\n      ) => {\n        settings.footingWidth = e.target.value;\n        regenerateModel();\n      }}></bim-number-input>\n\n      <bim-number-input label="Height" slider min=0.3 max=1 step=0.1 value=${settings.footingHeight} @change=${(\n        e: any,\n      ) => {\n        settings.footingHeight = e.target.value;\n        regenerateModel();\n      }}></bim-number-input>\n\n      <bim-number-input label="Column Width" slider min=0.05 max=0.5 step=0.01 value=${settings.columnWidth} @change=${(\n        e: any,\n      ) => {\n        settings.columnWidth = e.target.value;\n        regenerateModel();\n      }}></bim-number-input>\n      \n      <bim-number-input label="Column Length" slider min=0.05 max=0.5 step=0.01 value=${settings.columnLength} @change=${(\n        e: any,\n      ) => {\n        settings.columnLength = e.target.value;\n        regenerateModel();\n      }}></bim-number-input>\n\n      <bim-number-input label="Column Height" slider min=0.3 max=1 step=0.1 value=${settings.columnHeight} @change=${(\n        e: any,\n      ) => {\n        settings.columnHeight = e.target.value;\n        regenerateModel();\n      }}></bim-number-input>\n\n      <bim-number-input label="Column Padding" slider min=0.05 max=0.3 step=0.01 value=${settings.columnPadding} @change=${(\n        e: any,\n      ) => {\n        settings.columnPadding = e.target.value;\n        regenerateModel();\n      }}></bim-number-input>\n\n      <bim-number-input label="Column Long Rebar Radius" slider min=0.005 max=0.015 step=0.001 value=${settings.columnLongRebarRadius} @change=${(\n        e: any,\n      ) => {\n        settings.columnLongRebarRadius = e.target.value;\n        regenerateModel();\n      }}></bim-number-input>\n\n      <bim-number-input label="Column Trans Rebar Radius" slider min=0.005 max=0.015 step=0.001 value=${settings.columnTransRebarRadius} @change=${(\n        e: any,\n      ) => {\n        settings.columnTransRebarRadius = e.target.value;\n        regenerateModel();\n      }}></bim-number-input>\n\n      <bim-number-input label="Column Trans Rebar Offset" slider min=0.05 max=0.3 step=0.01 value=${settings.columnTransRebarOffset} @change=${(\n        e: any,\n      ) => {\n        settings.columnTransRebarOffset = e.target.value;\n        regenerateModel();\n      }}></bim-number-input>\n\n      <bim-number-input label="Column Trans Overlap" slider min=0.05 max=0.3 step=0.01 value=${settings.transOverlap} @change=${(\n        e: any,\n      ) => {\n        settings.transOverlap = e.target.value;\n        regenerateModel();\n      }}></bim-number-input>\n\n      <bim-number-input label="Column Top Rebar Offset" slider min=0.05 max=0.3 step=0.01 value=${settings.topColumnRebarOffset} @change=${(\n        e: any,\n      ) => {\n        settings.topColumnRebarOffset = e.target.value;\n        regenerateModel();\n      }}></bim-number-input>\n\n      <bim-number-input label="Footing Rebar Radius" slider min=0.005 max=0.015 step=0.001 value=${settings.footingRebarRadius} @change=${(\n        e: any,\n      ) => {\n        settings.footingRebarRadius = e.target.value;\n        regenerateModel();\n      }}></bim-number-input>\n\n      <bim-number-input label="Footing Rebar Offset" slider min=0.05 max=0.3 step=0.01 value=${settings.footingRebarOffset} @change=${(\n        e: any,\n      ) => {\n        settings.footingRebarOffset = e.target.value;\n        regenerateModel();\n      }}></bim-number-input>\n\n      <bim-number-input label="Footing Overlap" slider min=0.05 max=0.3 step=0.01 value=${settings.footingOverlap} @change=${(\n        e: any,\n      ) => {\n        settings.footingOverlap = e.target.value;\n        regenerateModel();\n      }}></bim-number-input>\n\n      <bim-number-input label="Footing Bend Radius" slider min=0.005 max=0.015 step=0.001 value=${settings.footingBendRadius} @change=${(\n        e: any,\n      ) => {\n        settings.footingBendRadius = e.target.value;\n        regenerateModel();\n      }}></bim-number-input>\n\n      <bim-button icon="material-symbols:save" label="Save" @click=${save}></bim-button>\n\n      </bim-panel-section>\n\n    </bim-panel>\n  `;\n}, {});\n\ndocument.body.append(panel);\n'})}),"\n",(0,r.jsx)(e.h3,{id:"-mobile-friendly-menu",children:"\ud83d\udcf1 Mobile-Friendly Menu"}),"\n",(0,r.jsx)(e.p,{children:"We will make some logic that adds a button to the screen when the user is visiting our app from their phone, allowing to show or hide the menu. Otherwise, the menu would make the app unusable."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'const button = BUI.Component.create<BUI.PanelSection>(() => {\n  const onClick = () => {\n    if (panel.classList.contains("options-menu-visible")) {\n      panel.classList.remove("options-menu-visible");\n    } else {\n      panel.classList.add("options-menu-visible");\n    }\n  };\n\n  return BUI.html`\n    <bim-button class="phone-menu-toggler" icon="solar:settings-bold"\n      @click=${onClick}>\n    </bim-button>\n  `;\n});\n\ndocument.body.append(button);\n'})}),"\n",(0,r.jsx)(e.h3,{id:"-congratulations",children:"\ud83c\udf89 Congratulations!"}),"\n",(0,r.jsx)(e.p,{children:"You've successfully learned how to work with rebars and reinforced concrete elements using the Fragments API! \ud83d\ude80\nNow you can create parametric reinforced concrete structures with customizable dimensions, rebar spacing, and colors. Ready to explore more? Check out our other tutorials to unlock the full potential of Fragments! \ud83d\udca1"})]})}function m(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>a,x:()=>s});var r=t(6540);const o={},i=r.createContext(o);function a(n){const e=r.useContext(i);return r.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:a(n.components),r.createElement(i.Provider,{value:e},n.children)}}}]);