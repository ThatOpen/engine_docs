"use strict";(self.webpackChunkengine_docs=self.webpackChunkengine_docs||[]).push([[8206],{1069:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>a,metadata:()=>r,toc:()=>c});var s=t(4848),o=t(8453);const a={},i=void 0,r={id:"Tutorials/Components/Core/Classifier",title:"Classifier",description:'window.open("https://thatopen.github.io/engine_components/examples/Classifier")} >Go Full Screen',source:"@site/docs/Tutorials/Components/Core/Classifier.mdx",sourceDirName:"Tutorials/Components/Core",slug:"/Tutorials/Components/Core/Classifier",permalink:"/Tutorials/Components/Core/Classifier",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"BoundingBoxer",permalink:"/Tutorials/Components/Core/BoundingBoxer"},next:{title:"Clipper",permalink:"/Tutorials/Components/Core/Clipper"}},l={},c=[{value:"\ud83d\udcc4 Making Items Groupings",id:"-making-items-groupings",level:2},{value:"\ud83d\udd96 Importing our Libraries",id:"-importing-our-libraries",level:3},{value:"\ud83c\udf0e Setting up a Simple Scene",id:"-setting-up-a-simple-scene",level:3},{value:"\ud83d\udee0\ufe0f Setting Up Fragments",id:"\ufe0f-setting-up-fragments",level:3},{value:"\ud83d\udcc2 Loading Fragments Models",id:"-loading-fragments-models",level:3},{value:"\u2728 Using The Classifier Component",id:"-using-the-classifier-component",level:3},{value:"\ud83e\udde9 Adding Dynamic Items",id:"-adding-dynamic-items",level:3},{value:"\ud83c\udff7\ufe0f Built-in Ways to Classify",id:"\ufe0f-built-in-ways-to-classify",level:3},{value:"\ud83e\udde9 Adding some UI (optional but recommended)",id:"-adding-some-ui-optional-but-recommended",level:3},{value:"\u23f1\ufe0f Measuring the performance (optional)",id:"\ufe0f-measuring-the-performance-optional",level:3},{value:"\ud83c\udf89 Wrap up",id:"-wrap-up",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",hr:"hr",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)("div",{style:{position:"relative"},children:[(0,s.jsx)("iframe",{src:"https://thatopen.github.io/engine_components/examples/Classifier"}),(0,s.jsx)("button",{class:"full-screen-btn",onClick:()=>window.open("https://thatopen.github.io/engine_components/examples/Classifier"),children:"Go Full Screen"})]}),"\n",(0,s.jsx)(n.admonition,{title:"Source",type:"info",children:(0,s.jsxs)(n.p,{children:["Copying and pasting? We've got you covered! You can find the full source code of this tutorial ",(0,s.jsx)(n.a,{href:"https://github.com/ThatOpen/engine_components/blob/main/packages/core/src/fragments/Classifier/example.ts",children:"here"}),"."]})}),"\n",(0,s.jsx)(n.h2,{id:"-making-items-groupings",children:"\ud83d\udcc4 Making Items Groupings"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"Classifications are a powerful way to organize your BIM models. They allow you to group them according to different parameters. For example: getting all the walls, or all the items that belong to a specific floor or room. In this tutorial, you'll learn how to classify your BIM models by different criterias, and how to get the list of items that belong to a specific category. Let's go!"}),"\n",(0,s.jsx)(n.h3,{id:"-importing-our-libraries",children:"\ud83d\udd96 Importing our Libraries"}),"\n",(0,s.jsx)(n.p,{children:"First things first, let's install all necessary dependencies to make this example work:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'import Stats from "stats.js";\nimport * as BUI from "@thatopen/ui";\n// You have to import * as OBC from "@thatopen/components"\nimport * as OBC from "../..";\n'})}),"\n",(0,s.jsx)(n.h3,{id:"-setting-up-a-simple-scene",children:"\ud83c\udf0e Setting up a Simple Scene"}),"\n",(0,s.jsx)(n.p,{children:"To get started, let's set up a basic ThreeJS scene. This will serve as the foundation for our application and allow us to visualize the 3D models effectively:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const components = new OBC.Components();\n\nconst worlds = components.get(OBC.Worlds);\nconst world = worlds.create<\n  OBC.SimpleScene,\n  OBC.OrthoPerspectiveCamera,\n  OBC.SimpleRenderer\n>();\n\nworld.scene = new OBC.SimpleScene(components);\nworld.scene.setup();\nworld.scene.three.background = null;\n\nconst container = document.getElementById("container")!;\nworld.renderer = new OBC.SimpleRenderer(components, container);\nworld.camera = new OBC.OrthoPerspectiveCamera(components);\nawait world.camera.controls.setLookAt(78, 20, -2.2, 26, -4, 25);\n\ncomponents.init();\n'})}),"\n",(0,s.jsx)(n.h3,{id:"\ufe0f-setting-up-fragments",children:"\ud83d\udee0\ufe0f Setting Up Fragments"}),"\n",(0,s.jsx)(n.p,{children:"Now, let's configure the FragmentsManager. This will allow us to load models effortlessly and start manipulating them with ease:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const githubUrl =\n  "https://thatopen.github.io/engine_fragment/resources/worker.mjs";\nconst fetchedUrl = await fetch(githubUrl);\nconst workerBlob = await fetchedUrl.blob();\nconst workerFile = new File([workerBlob], "worker.mjs", {\n  type: "text/javascript",\n});\nconst workerUrl = URL.createObjectURL(workerFile);\nconst fragments = components.get(OBC.FragmentsManager);\nfragments.init(workerUrl);\n\nworld.camera.controls.addEventListener("rest", () =>\n  fragments.core.update(true),\n);\n\nworld.onCameraChanged.add((camera) => {\n  for (const [, model] of fragments.list) {\n    model.useCamera(camera.three);\n  }\n  fragments.core.update(true);\n});\n\nfragments.list.onItemSet.add(({ value: model }) => {\n  model.useCamera(world.camera.three);\n  world.scene.three.add(model.object);\n  fragments.core.update(true);\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"-loading-fragments-models",children:"\ud83d\udcc2 Loading Fragments Models"}),"\n",(0,s.jsx)(n.p,{children:"With the core setup complete, it's time to load a Fragments model into our scene. Fragments are optimized for fast loading and rendering, making them ideal for large-scale 3D models."}),"\n",(0,s.jsx)(n.admonition,{title:"Where can I find Fragment files?",type:"info",children:(0,s.jsx)(n.p,{children:"You can use the sample Fragment files available in our repository for testing. If you have an IFC model you'd like to convert to Fragments, check out the IfcImporter tutorial for detailed instructions."})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const fragPaths = [\n  "https://thatopen.github.io/engine_components/resources/frags/school_arq.frag",\n  "https://thatopen.github.io/engine_components/resources/frags/school_str.frag",\n];\nawait Promise.all(\n  fragPaths.map(async (path) => {\n    const modelId = path.split("/").pop()?.split(".").shift();\n    if (!modelId) return null;\n    const file = await fetch(path);\n    const buffer = await file.arrayBuffer();\n    return fragments.core.load(buffer, { modelId });\n  }),\n);\n'})}),"\n",(0,s.jsx)(n.h3,{id:"-using-the-classifier-component",children:"\u2728 Using The Classifier Component"}),"\n",(0,s.jsx)(n.p,{children:"The classifier component is straightforward to use. Groups can be static, dynamic, or combined. Static groups consist of a fixed set of elements that you specify, while dynamic groups use queries to define the elements within the group. Combined groups, on the other hand, includes both static and dynamic elements. To begin, let's obtain an instance of the component:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const classifier = components.get(OBC.Classifier);\n"})}),"\n",(0,s.jsx)(n.p,{children:"The most common use case for static groups is to allow users to manually assign selected elements to a group. However, for demonstration purposes, let's add some elements programmatically. Let's start by creating a group:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const classificationName = "Custom Classification";\nconst groupName = "My Group";\nclassifier.getGroupData("Custom Classification", "My Group");\n'})}),"\n",(0,s.jsx)(n.p,{children:"To replicate the functionality of adding static elements, let's programmatically include the first two slabs from each model. After retrieving these elements, we can add them to the group."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const slabsModelIdMap: OBC.ModelIdMap = {};\nfor (const [modelId, model] of fragments.list) {\n  const items = await model.getItemsOfCategories([/SLAB/]);\n  const localIds = Object.values(items).flat().slice(0, 2);\n  slabsModelIdMap[modelId] = new Set(localIds);\n}\n\nclassifier.addGroupItems(classificationName, groupName, slabsModelIdMap);\n"})}),"\n",(0,s.jsx)(n.admonition,{title:"Multi-Model Compatibility",type:"note",children:(0,s.jsx)(n.p,{children:"You don't need to worry about making the Classifier component work with multiple models; it handles this automatically (as do all other components) using the modelIdMap."})}),"\n",(0,s.jsx)(n.h3,{id:"-adding-dynamic-items",children:"\ud83e\udde9 Adding Dynamic Items"}),"\n",(0,s.jsx)(n.p,{children:"While adding static items to classifier groups is useful, the component truly shines when you define queries to assign items dynamically. This is an advanced feature because if you load additional models after the dynamic group has been set, it will automatically update with the new items. To do it, let's first configure some simple query using the corresponding component:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const finder = components.get(OBC.ItemsFinder);\nconst queryName = "First Floor Walls";\nfinder.create("First Floor Walls", [\n  {\n    categories: [/WALL/],\n    relation: {\n      name: "ContainedInStructure",\n      query: {\n        categories: [/STOREY/],\n        attributes: { queries: [{ name: /Name/, value: /01/ }] },\n      },\n    },\n  },\n]);\n'})}),"\n",(0,s.jsx)(n.admonition,{title:"Advanced Queries",type:"note",children:(0,s.jsx)(n.p,{children:"For more information about the query system in the engine, please refer to the Items Finder tutorial in the documentation."})}),"\n",(0,s.jsx)(n.p,{children:"Once the query has been set, it is just a matter of adding it to the group:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"classifier.setGroupQuery(classificationName, groupName, {\n  name: queryName,\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"From this point forward, when we get the items from the classifier group we have created, the result will include the combination of the static items (the first two slabs of each model) plus all the dynamic items (all the walls in the first floor of each model)."}),"\n",(0,s.jsx)(n.h3,{id:"\ufe0f-built-in-ways-to-classify",children:"\ud83c\udff7\ufe0f Built-in Ways to Classify"}),"\n",(0,s.jsx)(n.p,{children:"While is very convinient to do custom groupings based on static and dynamic items, the classifier comes with some methods to classify the model in the most common ways: by category, levels and models. Let's do it as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const addDefaultGroupings = async () => {\n  await classifier.byCategory();\n  await classifier.byIfcBuildingStorey({ classificationName: "Levels" });\n};\n'})}),"\n",(0,s.jsx)(n.h3,{id:"-adding-some-ui-optional-but-recommended",children:"\ud83e\udde9 Adding some UI (optional but recommended)"}),"\n",(0,s.jsxs)(n.p,{children:["We will use the ",(0,s.jsx)(n.code,{children:"@thatopen/ui"})," library to add some simple and cool UI elements to our app. First, we need to call the ",(0,s.jsx)(n.code,{children:"init"})," method of the ",(0,s.jsx)(n.code,{children:"BUI.Manager"})," class to initialize the library:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"BUI.Manager.init();\n"})}),"\n",(0,s.jsx)(n.p,{children:"Now we will add some UI to play around with the actions in this tutorial. For more information about the UI library, you can check the specific documentation for it!"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'type GroupsTableData = {\n  Classification: string;\n  Name: string;\n  Actions: string;\n};\n\ninterface GroupsTableState {\n  components: OBC.Components;\n}\n\nconst groupsTableTemplate = (_state: GroupsTableState) => {\n  const onCreated = (e?: Element) => {\n    if (!e) return;\n    const table = e as BUI.Table<GroupsTableData>;\n\n    table.loadFunction = async () => {\n      const data: BUI.TableGroupData<GroupsTableData>[] = [];\n\n      for (const [classification, groups] of classifier.list) {\n        for (const [name] of groups) {\n          data.push({\n            data: { Name: name, Classification: classification, Actions: "" },\n          });\n        }\n      }\n\n      return data;\n    };\n\n    table.loadData(true);\n  };\n\n  return BUI.html`\n    <bim-table ${BUI.ref(onCreated)}></bim-table>\n  `;\n};\n\nconst [groupsTable, updateTable] = BUI.Component.create<\n  BUI.Table<GroupsTableData>,\n  GroupsTableState\n>(groupsTableTemplate, {\n  components,\n});\n\ngroupsTable.style.maxHeight = "25rem";\ngroupsTable.hiddenColumns = ["Classification"];\ngroupsTable.columns = ["Name", { name: "Actions", width: "auto" }];\ngroupsTable.noIndentation = true;\ngroupsTable.headersHidden = true;\ngroupsTable.dataTransform = {\n  Actions: (_, rowData) => {\n    const { Name, Classification } = rowData;\n    if (!(Name && Classification)) return _;\n    const classification = classifier.list.get(Classification);\n    if (!classification) return _;\n    const groupData = classification.get(Name);\n    if (!groupData) return _;\n\n    const hider = components.get(OBC.Hider);\n    const onClick = async ({ target }: { target: BUI.Button }) => {\n      target.loading = true;\n      const modelIdMap = await groupData.get();\n      await hider.isolate(modelIdMap);\n      target.loading = false;\n    };\n\n    return BUI.html`<bim-button icon="solar:cursor-bold" @click=${onClick}></bim-button>`;\n  },\n};\n\nclassifier.list.onItemSet.add(() => setTimeout(() => updateTable()));\n\nconst panel = BUI.Component.create<BUI.PanelSection>(() => {\n  const onResetVisibility = async ({ target }: { target: BUI.Button }) => {\n    target.loading = true;\n    const hider = components.get(OBC.Hider);\n    await hider.set(true);\n    target.loading = false;\n  };\n\n  const onAddDefaults = async () => {\n    await addDefaultGroupings();\n  };\n\n  return BUI.html`\n    <bim-panel active label="Classifier Tutorial" class="options-menu">\n      <bim-panel-section style="min-width: 14rem" label="General">\n        <bim-button label="Reset Visibility" @click=${onResetVisibility}></bim-button>\n      </bim-panel-section>\n      <bim-panel-section label="Groupings">\n        <bim-button label="Add Defaults" @click=${onAddDefaults}></bim-button>\n        ${groupsTable}\n      </bim-panel-section>\n    </bim-panel>\n  `;\n});\n\ndocument.body.append(panel);\n'})}),"\n",(0,s.jsx)(n.p,{children:"And we will make some logic that adds a button to the screen when the user is visiting our app from their phone, allowing to show or hide the menu. Otherwise, the menu would make the app unusable."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const button = BUI.Component.create<BUI.PanelSection>(() => {\n  return BUI.html`\n      <bim-button class="phone-menu-toggler" icon="solar:settings-bold"\n        @click="${() => {\n          if (panel.classList.contains("options-menu-visible")) {\n            panel.classList.remove("options-menu-visible");\n          } else {\n            panel.classList.add("options-menu-visible");\n          }\n        }}">\n      </bim-button>\n    `;\n});\n\ndocument.body.append(button);\n'})}),"\n",(0,s.jsx)(n.h3,{id:"\ufe0f-measuring-the-performance-optional",children:"\u23f1\ufe0f Measuring the performance (optional)"}),"\n",(0,s.jsxs)(n.p,{children:["We'll use the ",(0,s.jsx)(n.a,{href:"https://github.com/mrdoob/stats.js",children:"Stats.js"})," to measure the performance of our app. We will add it to the top left corner of the viewport. This way, we'll make sure that the memory consumption and the FPS of our app are under control."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const stats = new Stats();\nstats.showPanel(2);\ndocument.body.append(stats.dom);\nstats.dom.style.left = "0px";\nstats.dom.style.zIndex = "unset";\nworld.renderer.onBeforeUpdate.add(() => stats.begin());\nworld.renderer.onAfterUpdate.add(() => stats.end());\n'})}),"\n",(0,s.jsx)(n.h3,{id:"-wrap-up",children:"\ud83c\udf89 Wrap up"}),"\n",(0,s.jsx)(n.p,{children:"That's it! Now you're able to classify your BIM models using static and dynamic groups. Congratulations! Keep going with more tutorials in the documentation."})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>r});var s=t(6540);const o={},a=s.createContext(o);function i(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);